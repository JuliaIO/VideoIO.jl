module libffmpeg

using FFMPEG
export FFMPEG

const intptr_t = UInt
const time_t = Int

const AV_NOPTS_VALUE = 0x8000000000000000 % Int64
AV_VERSION_INT(a, b, c) = (a << 16 | b << 8) | c
AV_VERSION(a,b,c) = nothing
const AVPROBE_SCORE_MAX = 100
MKTAG(a,b,c,d) = (UInt32(a) | (UInt32(b) << 8) | (UInt32(c) << 16) | UInt32(d) << 24)
FFERRTAG(a,b,c,d) = -MKTAG(a,b,c,d)
macro AV_PIX_FMT_NE(be, le)
    Symbol("AV_PIX_FMT_"*string(le))
end


const VdpChromaType = UInt32

const VdpDevice = UInt32

const VdpDecoderProfile = UInt32

const VdpDecoder = UInt32

const VkBool32 = UInt32

mutable struct VkImage_T end

const VkImage = Ptr{VkImage_T}

mutable struct VkInstance_T end

const VkInstance = Ptr{VkInstance_T}

mutable struct VkPhysicalDevice_T end

const VkPhysicalDevice = Ptr{VkPhysicalDevice_T}

mutable struct VkDevice_T end

const VkDevice = Ptr{VkDevice_T}

mutable struct VkSemaphore_T end

const VkSemaphore = Ptr{VkSemaphore_T}

mutable struct VkDeviceMemory_T end

const VkDeviceMemory = Ptr{VkDeviceMemory_T}

const VkStructureType = UInt32
const VK_STRUCTURE_TYPE_APPLICATION_INFO = 0 % UInt32
const VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3 % UInt32
const VK_STRUCTURE_TYPE_SUBMIT_INFO = 4 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5 % UInt32
const VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6 % UInt32
const VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7 % UInt32
const VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9 % UInt32
const VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10 % UInt32
const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15 % UInt32
const VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27 % UInt32
const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28 % UInt32
const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34 % UInt32
const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35 % UInt32
const VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46 % UInt32
const VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47 % UInt32
const VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000 % UInt32
const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006 % UInt32
const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003 % UInt32
const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001 % UInt32
const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004 % UInt32
const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006 % UInt32
const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES = 1000120000 % UInt32
const VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES = 1000063000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES = 49 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES = 50 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES = 51 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES = 52 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO = 1000147000 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2 = 1000109000 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2 = 1000109001 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2 = 1000109002 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2 = 1000109003 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2 = 1000109004 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO = 1000109005 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_END_INFO = 1000109006 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES = 1000177000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES = 1000196000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES = 1000180000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES = 1000082000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES = 1000197000 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES = 1000161001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES = 1000161002 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO = 1000161003 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT = 1000161004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES = 1000199000 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE = 1000199001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES = 1000221000 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO = 1000246000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES = 1000130000 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO = 1000130001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES = 1000211000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES = 1000108000 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO = 1000108001 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO = 1000108002 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO = 1000108003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES = 1000253000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES = 1000175000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES = 1000241000 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT = 1000241001 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT = 1000241002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES = 1000261000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES = 1000207000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES = 1000207001 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO = 1000207002 % UInt32
const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO = 1000207003 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO = 1000207004 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO = 1000207005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES = 1000257000 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO = 1000244001 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO = 1000257002 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO = 1000257003 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO = 1000257004 % UInt32
const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000 % UInt32
const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009 % UInt32
const VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000 % UInt32
const VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000 % UInt32
const VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000 % UInt32
const VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000 % UInt32
const VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000 % UInt32
const VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002 % UInt32
const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000 % UInt32
const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001 % UInt32
const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT = 1000028000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT = 1000028001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT = 1000028002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX = 1000030000 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX = 1000030001 % UInt32
const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000 % UInt32
const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP = 1000049000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV = 1000050000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001 % UInt32
const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000 % UInt32
const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000 % UInt32
const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT = 1000066000 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT = 1000067000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT = 1000067001 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002 % UInt32
const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001 % UInt32
const VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001 % UInt32
const VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002 % UInt32
const VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002 % UInt32
const VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003 % UInt32
const VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT = 1000102000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT = 1000102001 % UInt32
const VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000 % UInt32
const VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001 % UInt32
const VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000 % UInt32
const VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001 % UInt32
const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR = 1000116003 % UInt32
const VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR = 1000116004 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR = 1000116005 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR = 1000116006 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004 % UInt32
const VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000 % UInt32
const VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004 % UInt32
const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000 % UInt32
const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001 % UInt32
const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT = 1000138000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT = 1000138001 % UInt32
const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT = 1000138002 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT = 1000138003 % UInt32
const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003 % UInt32
const VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000 % UInt32
const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR = 1000150007 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR = 1000150000 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR = 1000150002 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR = 1000150003 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR = 1000150004 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR = 1000150005 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR = 1000150006 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR = 1000150009 % UInt32
const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR = 1000150010 % UInt32
const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR = 1000150011 % UInt32
const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR = 1000150012 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR = 1000150013 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR = 1000150014 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR = 1000150017 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR = 1000150020 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR = 1000347000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR = 1000347001 % UInt32
const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR = 1000150015 % UInt32
const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR = 1000150016 % UInt32
const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR = 1000150018 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR = 1000348013 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV = 1000154000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV = 1000154001 % UInt32
const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005 % UInt32
const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000 % UInt32
const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV = 1000164000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV = 1000164001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV = 1000164002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV = 1000164005 % UInt32
const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV = 1000165000 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV = 1000165001 % UInt32
const VK_STRUCTURE_TYPE_GEOMETRY_NV = 1000165003 % UInt32
const VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV = 1000165004 % UInt32
const VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV = 1000165005 % UInt32
const VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV = 1000165006 % UInt32
const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV = 1000165007 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV = 1000165008 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV = 1000165009 % UInt32
const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV = 1000165011 % UInt32
const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV = 1000165012 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV = 1000166000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV = 1000166001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT = 1000170000 % UInt32
const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT = 1000170001 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR = 1000181000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD = 1000183000 % UInt32
const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT = 1000184000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD = 1000189000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT = 1000190002 % UInt32
const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP = 1000191000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT = 1000192000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV = 1000201000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV = 1000202000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV = 1000202001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV = 1000203000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV = 1000204000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV = 1000205000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV = 1000205002 % UInt32
const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000 % UInt32
const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL = 1000209000 % UInt32
const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL = 1000210000 % UInt32
const VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL = 1000210001 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL = 1000210002 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL = 1000210003 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL = 1000210004 % UInt32
const VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL = 1000210005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT = 1000212000 % UInt32
const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD = 1000213000 % UInt32
const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD = 1000213001 % UInt32
const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA = 1000214000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR = 1000215000 % UInt32
const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT = 1000217000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT = 1000218000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT = 1000218001 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT = 1000218002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT = 1000225000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT = 1000225001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT = 1000225002 % UInt32
const VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR = 1000226000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR = 1000226001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR = 1000226002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR = 1000226003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR = 1000226004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD = 1000227000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD = 1000229000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT = 1000234000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT = 1000237000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT = 1000238000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT = 1000238001 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR = 1000239000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV = 1000240000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT = 1000244000 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT = 1000244002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT = 1000245000 % UInt32
const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT = 1000247000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV = 1000249000 % UInt32
const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV = 1000249002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV = 1000250000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV = 1000250001 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV = 1000250002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT = 1000251000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT = 1000252000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT = 1000254000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT = 1000254001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT = 1000254002 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT = 1000255000 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT = 1000255002 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT = 1000255001 % UInt32
const VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT = 1000256000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT = 1000259000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT = 1000259001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT = 1000259002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT = 1000260000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT = 1000265000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT = 1000267000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR = 1000269000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR = 1000269001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR = 1000269002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR = 1000269003 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR = 1000269004 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR = 1000269005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT = 1000276000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV = 1000277000 % UInt32
const VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV = 1000277001 % UInt32
const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV = 1000277002 % UInt32
const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV = 1000277003 % UInt32
const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV = 1000277004 % UInt32
const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV = 1000277005 % UInt32
const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV = 1000277006 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV = 1000277007 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV = 1000278000 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV = 1000278001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT = 1000281000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT = 1000281001 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM = 1000282000 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM = 1000282001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT = 1000284000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT = 1000284001 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT = 1000284002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT = 1000286000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT = 1000286001 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT = 1000287000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT = 1000287001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT = 1000287002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR = 1000290000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT = 1000295000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT = 1000295001 % UInt32
const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT = 1000295002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT = 1000297000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV = 1000300000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV = 1000300001 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR = 1000314000 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR = 1000314001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR = 1000314002 % UInt32
const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR = 1000314003 % UInt32
const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR = 1000314004 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR = 1000314005 % UInt32
const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR = 1000314006 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR = 1000314007 % UInt32
const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV = 1000314008 % UInt32
const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV = 1000314009 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR = 1000325000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV = 1000326000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV = 1000326001 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV = 1000326002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT = 1000330000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT = 1000332000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT = 1000332001 % UInt32
const VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM = 1000333000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT = 1000335000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR = 1000336000 % UInt32
const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR = 1000337000 % UInt32
const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR = 1000337001 % UInt32
const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR = 1000337002 % UInt32
const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR = 1000337003 % UInt32
const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR = 1000337004 % UInt32
const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR = 1000337005 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR = 1000337006 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR = 1000337007 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR = 1000337008 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR = 1000337009 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR = 1000337010 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT = 1000340000 % UInt32
const VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT = 1000346000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE = 1000351000 % UInt32
const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE = 1000351002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT = 1000352000 % UInt32
const VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT = 1000352001 % UInt32
const VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT = 1000352002 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA = 1000364001 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000364002 % UInt32
const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365000 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA = 1000365001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT = 1000377000 % UInt32
const VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX = 1000378000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT = 1000381000 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT = 1000381001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000 % UInt32
const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = 1000053000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = 1000053001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = 1000053002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001 % UInt32
const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004 % UInt32
const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006 % UInt32
const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = 1000059008 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = 1000060000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = 1000060003 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = 1000060004 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = 1000060005 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = 1000060006 % UInt32
const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060013 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = 1000060014 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = 1000070000 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = 1000070001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = 1000071000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = 1000076000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR = 1000082000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR = 1000082000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000 % UInt32
const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = 1000090000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR = 1000108000 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR = 1000108001 % UInt32
const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR = 1000108002 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR = 1000108003 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000 % UInt32
const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001 % UInt32
const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 1000113000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = 1000117000 % UInt32
const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = 1000117001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = 1000117002 % UInt32
const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = 1000117003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR = 1000120000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = 1000120000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146002 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 1000146003 % UInt32
const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = 1000156000 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = 1000156001 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = 1000156002 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = 1000156003 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = 1000156004 % UInt32
const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = 1000156005 % UInt32
const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = 1000157000 % UInt32
const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = 1000157001 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = 1000168000 % UInt32
const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = 1000168001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR = 1000175000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR = 1000180000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR = 1000196000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR = 1000197000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR = 1000199000 % UInt32
const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR = 1000199001 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR = 1000207000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR = 1000207001 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR = 1000207002 % UInt32
const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR = 1000207003 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR = 1000207004 % UInt32
const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR = 1000207005 % UInt32
const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL = 1000210000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR = 1000211000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT = 1000221000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR = 1000241000 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR = 1000241001 % UInt32
const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR = 1000241002 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT = 1000244000 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT = 1000244001 % UInt32
const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT = 1000246000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR = 1000253000 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR = 1000257000 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR = 1000244001 % UInt32
const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR = 1000257002 % UInt32
const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR = 1000257003 % UInt32
const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR = 1000257004 % UInt32
const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT = 1000261000 % UInt32
const VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647 % UInt32

const VkImageLayout = UInt32
const VK_IMAGE_LAYOUT_UNDEFINED = 0 % UInt32
const VK_IMAGE_LAYOUT_GENERAL = 1 % UInt32
const VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4 % UInt32
const VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5 % UInt32
const VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6 % UInt32
const VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7 % UInt32
const VK_IMAGE_LAYOUT_PREINITIALIZED = 8 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001 % UInt32
const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002 % UInt32
const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003 % UInt32
const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002 % UInt32
const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000 % UInt32
const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003 % UInt32
const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000 % UInt32
const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000 % UInt32
const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001 % UInt32
const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000 % UInt32
const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001 % UInt32
const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002 % UInt32
const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003 % UInt32
const VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647 % UInt32

const VkFormat = UInt32
const VK_FORMAT_UNDEFINED = 0 % UInt32
const VK_FORMAT_R4G4_UNORM_PACK8 = 1 % UInt32
const VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2 % UInt32
const VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3 % UInt32
const VK_FORMAT_R5G6B5_UNORM_PACK16 = 4 % UInt32
const VK_FORMAT_B5G6R5_UNORM_PACK16 = 5 % UInt32
const VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6 % UInt32
const VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7 % UInt32
const VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8 % UInt32
const VK_FORMAT_R8_UNORM = 9 % UInt32
const VK_FORMAT_R8_SNORM = 10 % UInt32
const VK_FORMAT_R8_USCALED = 11 % UInt32
const VK_FORMAT_R8_SSCALED = 12 % UInt32
const VK_FORMAT_R8_UINT = 13 % UInt32
const VK_FORMAT_R8_SINT = 14 % UInt32
const VK_FORMAT_R8_SRGB = 15 % UInt32
const VK_FORMAT_R8G8_UNORM = 16 % UInt32
const VK_FORMAT_R8G8_SNORM = 17 % UInt32
const VK_FORMAT_R8G8_USCALED = 18 % UInt32
const VK_FORMAT_R8G8_SSCALED = 19 % UInt32
const VK_FORMAT_R8G8_UINT = 20 % UInt32
const VK_FORMAT_R8G8_SINT = 21 % UInt32
const VK_FORMAT_R8G8_SRGB = 22 % UInt32
const VK_FORMAT_R8G8B8_UNORM = 23 % UInt32
const VK_FORMAT_R8G8B8_SNORM = 24 % UInt32
const VK_FORMAT_R8G8B8_USCALED = 25 % UInt32
const VK_FORMAT_R8G8B8_SSCALED = 26 % UInt32
const VK_FORMAT_R8G8B8_UINT = 27 % UInt32
const VK_FORMAT_R8G8B8_SINT = 28 % UInt32
const VK_FORMAT_R8G8B8_SRGB = 29 % UInt32
const VK_FORMAT_B8G8R8_UNORM = 30 % UInt32
const VK_FORMAT_B8G8R8_SNORM = 31 % UInt32
const VK_FORMAT_B8G8R8_USCALED = 32 % UInt32
const VK_FORMAT_B8G8R8_SSCALED = 33 % UInt32
const VK_FORMAT_B8G8R8_UINT = 34 % UInt32
const VK_FORMAT_B8G8R8_SINT = 35 % UInt32
const VK_FORMAT_B8G8R8_SRGB = 36 % UInt32
const VK_FORMAT_R8G8B8A8_UNORM = 37 % UInt32
const VK_FORMAT_R8G8B8A8_SNORM = 38 % UInt32
const VK_FORMAT_R8G8B8A8_USCALED = 39 % UInt32
const VK_FORMAT_R8G8B8A8_SSCALED = 40 % UInt32
const VK_FORMAT_R8G8B8A8_UINT = 41 % UInt32
const VK_FORMAT_R8G8B8A8_SINT = 42 % UInt32
const VK_FORMAT_R8G8B8A8_SRGB = 43 % UInt32
const VK_FORMAT_B8G8R8A8_UNORM = 44 % UInt32
const VK_FORMAT_B8G8R8A8_SNORM = 45 % UInt32
const VK_FORMAT_B8G8R8A8_USCALED = 46 % UInt32
const VK_FORMAT_B8G8R8A8_SSCALED = 47 % UInt32
const VK_FORMAT_B8G8R8A8_UINT = 48 % UInt32
const VK_FORMAT_B8G8R8A8_SINT = 49 % UInt32
const VK_FORMAT_B8G8R8A8_SRGB = 50 % UInt32
const VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51 % UInt32
const VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52 % UInt32
const VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53 % UInt32
const VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54 % UInt32
const VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55 % UInt32
const VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56 % UInt32
const VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57 % UInt32
const VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58 % UInt32
const VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59 % UInt32
const VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60 % UInt32
const VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61 % UInt32
const VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62 % UInt32
const VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63 % UInt32
const VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64 % UInt32
const VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65 % UInt32
const VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66 % UInt32
const VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67 % UInt32
const VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68 % UInt32
const VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69 % UInt32
const VK_FORMAT_R16_UNORM = 70 % UInt32
const VK_FORMAT_R16_SNORM = 71 % UInt32
const VK_FORMAT_R16_USCALED = 72 % UInt32
const VK_FORMAT_R16_SSCALED = 73 % UInt32
const VK_FORMAT_R16_UINT = 74 % UInt32
const VK_FORMAT_R16_SINT = 75 % UInt32
const VK_FORMAT_R16_SFLOAT = 76 % UInt32
const VK_FORMAT_R16G16_UNORM = 77 % UInt32
const VK_FORMAT_R16G16_SNORM = 78 % UInt32
const VK_FORMAT_R16G16_USCALED = 79 % UInt32
const VK_FORMAT_R16G16_SSCALED = 80 % UInt32
const VK_FORMAT_R16G16_UINT = 81 % UInt32
const VK_FORMAT_R16G16_SINT = 82 % UInt32
const VK_FORMAT_R16G16_SFLOAT = 83 % UInt32
const VK_FORMAT_R16G16B16_UNORM = 84 % UInt32
const VK_FORMAT_R16G16B16_SNORM = 85 % UInt32
const VK_FORMAT_R16G16B16_USCALED = 86 % UInt32
const VK_FORMAT_R16G16B16_SSCALED = 87 % UInt32
const VK_FORMAT_R16G16B16_UINT = 88 % UInt32
const VK_FORMAT_R16G16B16_SINT = 89 % UInt32
const VK_FORMAT_R16G16B16_SFLOAT = 90 % UInt32
const VK_FORMAT_R16G16B16A16_UNORM = 91 % UInt32
const VK_FORMAT_R16G16B16A16_SNORM = 92 % UInt32
const VK_FORMAT_R16G16B16A16_USCALED = 93 % UInt32
const VK_FORMAT_R16G16B16A16_SSCALED = 94 % UInt32
const VK_FORMAT_R16G16B16A16_UINT = 95 % UInt32
const VK_FORMAT_R16G16B16A16_SINT = 96 % UInt32
const VK_FORMAT_R16G16B16A16_SFLOAT = 97 % UInt32
const VK_FORMAT_R32_UINT = 98 % UInt32
const VK_FORMAT_R32_SINT = 99 % UInt32
const VK_FORMAT_R32_SFLOAT = 100 % UInt32
const VK_FORMAT_R32G32_UINT = 101 % UInt32
const VK_FORMAT_R32G32_SINT = 102 % UInt32
const VK_FORMAT_R32G32_SFLOAT = 103 % UInt32
const VK_FORMAT_R32G32B32_UINT = 104 % UInt32
const VK_FORMAT_R32G32B32_SINT = 105 % UInt32
const VK_FORMAT_R32G32B32_SFLOAT = 106 % UInt32
const VK_FORMAT_R32G32B32A32_UINT = 107 % UInt32
const VK_FORMAT_R32G32B32A32_SINT = 108 % UInt32
const VK_FORMAT_R32G32B32A32_SFLOAT = 109 % UInt32
const VK_FORMAT_R64_UINT = 110 % UInt32
const VK_FORMAT_R64_SINT = 111 % UInt32
const VK_FORMAT_R64_SFLOAT = 112 % UInt32
const VK_FORMAT_R64G64_UINT = 113 % UInt32
const VK_FORMAT_R64G64_SINT = 114 % UInt32
const VK_FORMAT_R64G64_SFLOAT = 115 % UInt32
const VK_FORMAT_R64G64B64_UINT = 116 % UInt32
const VK_FORMAT_R64G64B64_SINT = 117 % UInt32
const VK_FORMAT_R64G64B64_SFLOAT = 118 % UInt32
const VK_FORMAT_R64G64B64A64_UINT = 119 % UInt32
const VK_FORMAT_R64G64B64A64_SINT = 120 % UInt32
const VK_FORMAT_R64G64B64A64_SFLOAT = 121 % UInt32
const VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122 % UInt32
const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123 % UInt32
const VK_FORMAT_D16_UNORM = 124 % UInt32
const VK_FORMAT_X8_D24_UNORM_PACK32 = 125 % UInt32
const VK_FORMAT_D32_SFLOAT = 126 % UInt32
const VK_FORMAT_S8_UINT = 127 % UInt32
const VK_FORMAT_D16_UNORM_S8_UINT = 128 % UInt32
const VK_FORMAT_D24_UNORM_S8_UINT = 129 % UInt32
const VK_FORMAT_D32_SFLOAT_S8_UINT = 130 % UInt32
const VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131 % UInt32
const VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132 % UInt32
const VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133 % UInt32
const VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134 % UInt32
const VK_FORMAT_BC2_UNORM_BLOCK = 135 % UInt32
const VK_FORMAT_BC2_SRGB_BLOCK = 136 % UInt32
const VK_FORMAT_BC3_UNORM_BLOCK = 137 % UInt32
const VK_FORMAT_BC3_SRGB_BLOCK = 138 % UInt32
const VK_FORMAT_BC4_UNORM_BLOCK = 139 % UInt32
const VK_FORMAT_BC4_SNORM_BLOCK = 140 % UInt32
const VK_FORMAT_BC5_UNORM_BLOCK = 141 % UInt32
const VK_FORMAT_BC5_SNORM_BLOCK = 142 % UInt32
const VK_FORMAT_BC6H_UFLOAT_BLOCK = 143 % UInt32
const VK_FORMAT_BC6H_SFLOAT_BLOCK = 144 % UInt32
const VK_FORMAT_BC7_UNORM_BLOCK = 145 % UInt32
const VK_FORMAT_BC7_SRGB_BLOCK = 146 % UInt32
const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147 % UInt32
const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148 % UInt32
const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149 % UInt32
const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150 % UInt32
const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151 % UInt32
const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152 % UInt32
const VK_FORMAT_EAC_R11_UNORM_BLOCK = 153 % UInt32
const VK_FORMAT_EAC_R11_SNORM_BLOCK = 154 % UInt32
const VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155 % UInt32
const VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156 % UInt32
const VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157 % UInt32
const VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158 % UInt32
const VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159 % UInt32
const VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160 % UInt32
const VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161 % UInt32
const VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162 % UInt32
const VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163 % UInt32
const VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164 % UInt32
const VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165 % UInt32
const VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166 % UInt32
const VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167 % UInt32
const VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168 % UInt32
const VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169 % UInt32
const VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170 % UInt32
const VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171 % UInt32
const VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172 % UInt32
const VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173 % UInt32
const VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174 % UInt32
const VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175 % UInt32
const VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176 % UInt32
const VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177 % UInt32
const VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178 % UInt32
const VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179 % UInt32
const VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180 % UInt32
const VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181 % UInt32
const VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182 % UInt32
const VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183 % UInt32
const VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184 % UInt32
const VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000 % UInt32
const VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002 % UInt32
const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004 % UInt32
const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006 % UInt32
const VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007 % UInt32
const VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008 % UInt32
const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009 % UInt32
const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010 % UInt32
const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012 % UInt32
const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014 % UInt32
const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016 % UInt32
const VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017 % UInt32
const VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018 % UInt32
const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019 % UInt32
const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020 % UInt32
const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022 % UInt32
const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024 % UInt32
const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026 % UInt32
const VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027 % UInt32
const VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029 % UInt32
const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031 % UInt32
const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033 % UInt32
const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000 % UInt32
const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001 % UInt32
const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002 % UInt32
const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003 % UInt32
const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004 % UInt32
const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005 % UInt32
const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006 % UInt32
const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007 % UInt32
const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000 % UInt32
const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001 % UInt32
const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002 % UInt32
const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003 % UInt32
const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004 % UInt32
const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005 % UInt32
const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006 % UInt32
const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007 % UInt32
const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008 % UInt32
const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009 % UInt32
const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010 % UInt32
const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011 % UInt32
const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012 % UInt32
const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013 % UInt32
const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT = 1000330000 % UInt32
const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT = 1000330001 % UInt32
const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT = 1000330002 % UInt32
const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT = 1000330003 % UInt32
const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000 % UInt32
const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001 % UInt32
const VK_FORMAT_G8B8G8R8_422_UNORM_KHR = 1000156000 % UInt32
const VK_FORMAT_B8G8R8G8_422_UNORM_KHR = 1000156001 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = 1000156002 % UInt32
const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = 1000156003 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = 1000156004 % UInt32
const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = 1000156005 % UInt32
const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = 1000156006 % UInt32
const VK_FORMAT_R10X6_UNORM_PACK16_KHR = 1000156007 % UInt32
const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = 1000156008 % UInt32
const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = 1000156009 % UInt32
const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = 1000156010 % UInt32
const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = 1000156011 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = 1000156012 % UInt32
const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = 1000156013 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = 1000156014 % UInt32
const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = 1000156015 % UInt32
const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = 1000156016 % UInt32
const VK_FORMAT_R12X4_UNORM_PACK16_KHR = 1000156017 % UInt32
const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = 1000156018 % UInt32
const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = 1000156019 % UInt32
const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = 1000156020 % UInt32
const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = 1000156021 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = 1000156022 % UInt32
const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = 1000156023 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = 1000156024 % UInt32
const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = 1000156025 % UInt32
const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = 1000156026 % UInt32
const VK_FORMAT_G16B16G16R16_422_UNORM_KHR = 1000156027 % UInt32
const VK_FORMAT_B16G16R16G16_422_UNORM_KHR = 1000156028 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = 1000156029 % UInt32
const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = 1000156030 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = 1000156031 % UInt32
const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = 1000156032 % UInt32
const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = 1000156033 % UInt32
const VK_FORMAT_MAX_ENUM = 2147483647 % UInt32

const VkImageTiling = UInt32
const VK_IMAGE_TILING_OPTIMAL = 0 % UInt32
const VK_IMAGE_TILING_LINEAR = 1 % UInt32
const VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000 % UInt32
const VK_IMAGE_TILING_MAX_ENUM = 2147483647 % UInt32

const VkAccessFlagBits = UInt32
const VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1 % UInt32
const VK_ACCESS_INDEX_READ_BIT = 2 % UInt32
const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4 % UInt32
const VK_ACCESS_UNIFORM_READ_BIT = 8 % UInt32
const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16 % UInt32
const VK_ACCESS_SHADER_READ_BIT = 32 % UInt32
const VK_ACCESS_SHADER_WRITE_BIT = 64 % UInt32
const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128 % UInt32
const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256 % UInt32
const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512 % UInt32
const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024 % UInt32
const VK_ACCESS_TRANSFER_READ_BIT = 2048 % UInt32
const VK_ACCESS_TRANSFER_WRITE_BIT = 4096 % UInt32
const VK_ACCESS_HOST_READ_BIT = 8192 % UInt32
const VK_ACCESS_HOST_WRITE_BIT = 16384 % UInt32
const VK_ACCESS_MEMORY_READ_BIT = 32768 % UInt32
const VK_ACCESS_MEMORY_WRITE_BIT = 65536 % UInt32
const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432 % UInt32
const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864 % UInt32
const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728 % UInt32
const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576 % UInt32
const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288 % UInt32
const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR = 2097152 % UInt32
const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR = 4194304 % UInt32
const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 8388608 % UInt32
const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216 % UInt32
const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV = 131072 % UInt32
const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV = 262144 % UInt32
const VK_ACCESS_NONE_KHR = 0 % UInt32
const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152 % UInt32
const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304 % UInt32
const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR = 8388608 % UInt32
const VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32

const VkImageUsageFlagBits = UInt32
const VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1 % UInt32
const VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2 % UInt32
const VK_IMAGE_USAGE_SAMPLED_BIT = 4 % UInt32
const VK_IMAGE_USAGE_STORAGE_BIT = 8 % UInt32
const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16 % UInt32
const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32 % UInt32
const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64 % UInt32
const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128 % UInt32
const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV = 256 % UInt32
const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT = 512 % UInt32
const VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR = 256 % UInt32
const VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32

const VkMemoryPropertyFlagBits = UInt32
const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1 % UInt32
const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2 % UInt32
const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4 % UInt32
const VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8 % UInt32
const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16 % UInt32
const VK_MEMORY_PROPERTY_PROTECTED_BIT = 32 % UInt32
const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 64 % UInt32
const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 128 % UInt32
const VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 2147483647 % UInt32

# typedef void * ( VKAPI_PTR * PFN_vkAllocationFunction ) ( void * pUserData , size_t size , size_t alignment , VkSystemAllocationScope allocationScope )
const PFN_vkAllocationFunction = Ptr{Cvoid}

# typedef void ( VKAPI_PTR * PFN_vkFreeFunction ) ( void * pUserData , void * pMemory )
const PFN_vkFreeFunction = Ptr{Cvoid}

# typedef void ( VKAPI_PTR * PFN_vkInternalAllocationNotification ) ( void * pUserData , size_t size , VkInternalAllocationType allocationType , VkSystemAllocationScope allocationScope )
const PFN_vkInternalAllocationNotification = Ptr{Cvoid}

# typedef void ( VKAPI_PTR * PFN_vkInternalFreeNotification ) ( void * pUserData , size_t size , VkInternalAllocationType allocationType , VkSystemAllocationScope allocationScope )
const PFN_vkInternalFreeNotification = Ptr{Cvoid}

# typedef void * ( VKAPI_PTR * PFN_vkReallocationFunction ) ( void * pUserData , void * pOriginal , size_t size , size_t alignment , VkSystemAllocationScope allocationScope )
const PFN_vkReallocationFunction = Ptr{Cvoid}

struct VkAllocationCallbacks
    pUserData::Ptr{Cvoid}
    pfnAllocation::PFN_vkAllocationFunction
    pfnReallocation::PFN_vkReallocationFunction
    pfnFree::PFN_vkFreeFunction
    pfnInternalAllocation::PFN_vkInternalAllocationNotification
    pfnInternalFree::PFN_vkInternalFreeNotification
end

struct VkPhysicalDeviceFeatures
    robustBufferAccess::VkBool32
    fullDrawIndexUint32::VkBool32
    imageCubeArray::VkBool32
    independentBlend::VkBool32
    geometryShader::VkBool32
    tessellationShader::VkBool32
    sampleRateShading::VkBool32
    dualSrcBlend::VkBool32
    logicOp::VkBool32
    multiDrawIndirect::VkBool32
    drawIndirectFirstInstance::VkBool32
    depthClamp::VkBool32
    depthBiasClamp::VkBool32
    fillModeNonSolid::VkBool32
    depthBounds::VkBool32
    wideLines::VkBool32
    largePoints::VkBool32
    alphaToOne::VkBool32
    multiViewport::VkBool32
    samplerAnisotropy::VkBool32
    textureCompressionETC2::VkBool32
    textureCompressionASTC_LDR::VkBool32
    textureCompressionBC::VkBool32
    occlusionQueryPrecise::VkBool32
    pipelineStatisticsQuery::VkBool32
    vertexPipelineStoresAndAtomics::VkBool32
    fragmentStoresAndAtomics::VkBool32
    shaderTessellationAndGeometryPointSize::VkBool32
    shaderImageGatherExtended::VkBool32
    shaderStorageImageExtendedFormats::VkBool32
    shaderStorageImageMultisample::VkBool32
    shaderStorageImageReadWithoutFormat::VkBool32
    shaderStorageImageWriteWithoutFormat::VkBool32
    shaderUniformBufferArrayDynamicIndexing::VkBool32
    shaderSampledImageArrayDynamicIndexing::VkBool32
    shaderStorageBufferArrayDynamicIndexing::VkBool32
    shaderStorageImageArrayDynamicIndexing::VkBool32
    shaderClipDistance::VkBool32
    shaderCullDistance::VkBool32
    shaderFloat64::VkBool32
    shaderInt64::VkBool32
    shaderInt16::VkBool32
    shaderResourceResidency::VkBool32
    shaderResourceMinLod::VkBool32
    sparseBinding::VkBool32
    sparseResidencyBuffer::VkBool32
    sparseResidencyImage2D::VkBool32
    sparseResidencyImage3D::VkBool32
    sparseResidency2Samples::VkBool32
    sparseResidency4Samples::VkBool32
    sparseResidency8Samples::VkBool32
    sparseResidency16Samples::VkBool32
    sparseResidencyAliased::VkBool32
    variableMultisampleRate::VkBool32
    inheritedQueries::VkBool32
end

struct VkPhysicalDeviceFeatures2
    sType::VkStructureType
    pNext::Ptr{Cvoid}
    features::VkPhysicalDeviceFeatures
end

"""
    av_ac3_parse_header(buf, size::Csize_t, bitstream_id, frame_size)

Extract the bitstream ID and the frame size from AC-3 data.
"""
function av_ac3_parse_header(buf, size::Csize_t, bitstream_id, frame_size)
    ccall((:av_ac3_parse_header, libavcodec), Cint, (Ptr{UInt8}, Csize_t, Ptr{UInt8}, Ptr{UInt16}), buf, size, bitstream_id, frame_size)
end

"""
    av_adts_header_parse(buf, samples, frames)

Extract the number of samples and frames from AAC data. 

### Parameters
* `buf`:\\[in\\] pointer to AAC data buffer 

* `samples`:\\[out\\] Pointer to where number of samples is written 

* `frames`:\\[out\\] Pointer to where number of frames is written 

### Returns
Returns 0 on success, error code on failure.
"""
function av_adts_header_parse(buf, samples, frames)
    ccall((:av_adts_header_parse, libavcodec), Cint, (Ptr{UInt8}, Ptr{UInt32}, Ptr{UInt8}), buf, samples, frames)
end

"""
    AVDiscard

` lavc_decoding`
"""
const AVDiscard = Int32
const AVDISCARD_NONE = -16 % Int32
const AVDISCARD_DEFAULT = 0 % Int32
const AVDISCARD_NONREF = 8 % Int32
const AVDISCARD_BIDIR = 16 % Int32
const AVDISCARD_NONINTRA = 24 % Int32
const AVDISCARD_NONKEY = 32 % Int32
const AVDISCARD_ALL = 48 % Int32

const AVAudioServiceType = UInt32
const AV_AUDIO_SERVICE_TYPE_MAIN = 0 % UInt32
const AV_AUDIO_SERVICE_TYPE_EFFECTS = 1 % UInt32
const AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2 % UInt32
const AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3 % UInt32
const AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4 % UInt32
const AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5 % UInt32
const AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6 % UInt32
const AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7 % UInt32
const AV_AUDIO_SERVICE_TYPE_KARAOKE = 8 % UInt32
const AV_AUDIO_SERVICE_TYPE_NB = 9 % UInt32

"""
    RcOverride

` lavc_encoding`
"""
struct RcOverride
    start_frame::Cint
    end_frame::Cint
    qscale::Cint
    quality_factor::Cfloat
end

"""
    AVPanScan

Pan Scan area. This specifies the area which should be displayed. Note there may be multiple such areas for one frame.
"""
struct AVPanScan
    id::Cint
    width::Cint
    height::Cint
    position::NTuple{3, NTuple{2, Int16}}
end

"""
    AVCPBProperties

This structure describes the bitrate properties of an encoded bitstream. It roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD parameters for H.264/HEVC.
"""
struct AVCPBProperties
    max_bitrate::Cint
    min_bitrate::Cint
    avg_bitrate::Cint
    buffer_size::Cint
    vbv_delay::UInt64
end

"""
    AVProducerReferenceTime

This structure supplies correlation between a packet timestamp and a wall clock production time. The definition follows the Producer Reference Time ('prft') as defined in ISO/IEC 14496-12
"""
struct AVProducerReferenceTime
    wallclock::Int64
    flags::Cint
end

"""
    AVOptionType

` avoptions AVOptions`

` lavu_data`

@{ AVOptions provide a generic system to declare options on arbitrary structs ("objects"). An option can have a help text, a type and a range of possible values. Options may then be enumerated, read and written to.

` avoptions_implement Implementing AVOptions`

This section describes how to add AVOptions capabilities to a struct.

All AVOptions-related information is stored in an [`AVClass`](@ref). Therefore the first member of the struct should be a pointer to an [`AVClass`](@ref) describing it. The option field of the [`AVClass`](@ref) must be set to a NULL-terminated static array of AVOptions. Each [`AVOption`](@ref) must have a non-empty name, a type, a default value and for number-type AVOptions also a range of allowed values. It must also declare an offset in bytes from the start of the struct, where the field associated with this [`AVOption`](@ref) is located. Other fields in the [`AVOption`](@ref) struct should also be set when applicable, but are not required.

The following example illustrates an AVOptions-enabled struct: 

```c++
 typedef struct test_struct {
     const AVClass *class;
     int      int_opt;
     char    *str_opt;
     uint8_t *bin_opt;
     int      bin_len;
 } test_struct;
 static const AVOption test_options[] = {
   { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),
     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
   { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),
     AV_OPT_TYPE_STRING },
   { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),
     AV_OPT_TYPE_BINARY },
   { NULL },
 };
 static const AVClass test_class = {
     .class_name = "test class",
     .item_name  = av_default_item_name,
     .option     = test_options,
     .version    = LIBAVUTIL_VERSION_INT,
 };
```

Next, when allocating your struct, you must ensure that the [`AVClass`](@ref) pointer is set to the correct value. Then, [`av_opt_set_defaults`](@ref)() can be called to initialize defaults. After that the struct is ready to be used with the AVOptions API.

When cleaning up, you may use the [`av_opt_free`](@ref)() function to automatically free all the allocated string and binary options.

Continuing with the above example:

```c++
 test_struct *alloc_test_struct(void)
 {
     test_struct *ret = av_mallocz(sizeof(*ret));
     ret->class = &test_class;
     av_opt_set_defaults(ret);
     return ret;
 }
 void free_test_struct(test_struct **foo)
 {
     av_opt_free(*foo);
     av_freep(foo);
 }
```

` avoptions_implement_nesting Nesting`

It may happen that an AVOptions-enabled struct contains another AVOptions-enabled struct as a member (e.g. [`AVCodecContext`](@ref) in libavcodec exports generic options, while its priv\\_data field exports codec-specific options). In such a case, it is possible to set up the parent struct to export a child's options. To do that, simply implement [`AVClass`](@ref).child\\_next() and [`AVClass`](@ref).child\\_class\\_iterate() in the parent struct's [`AVClass`](@ref). Assuming that the test\\_struct from above now also contains a child\\_struct field:

```c++
      typedef struct child_struct {
          AVClass *class;
          int flags_opt;
      } child_struct;
      static const AVOption child_opts[] = {
          { "test_flags", "This is a test option of flags type.",
            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },
          { NULL },
      };
      static const AVClass child_class = {
          .class_name = "child class",
          .item_name  = av_default_item_name,
          .option     = child_opts,
          .version    = LIBAVUTIL_VERSION_INT,
      };
      void *child_next(void *obj, void *prev)
      {
          test_struct *t = obj;
          if (!prev && t->child_struct)
              return t->child_struct;
          return NULL
      }
      const AVClass child_class_iterate(void **iter)
      {
          const AVClass *c = *iter ? NULL : &child_class;
          *iter = (void*)(uintptr_t)c;
          return c;
      }
```

Putting child\\_next() and child\\_class\\_iterate() as defined above into test\\_class will now make child\\_struct's options accessible through test\\_struct (again, proper setup as described above needs to be done on child\\_struct right after it is created).

From the above example it might not be clear why both child\\_next() and child\\_class\\_iterate() are needed. The distinction is that child\\_next() iterates over actually existing objects, while child\\_class\\_iterate() iterates over all possible child classes. E.g. if an [`AVCodecContext`](@ref) was initialized to use a codec which has private options, then its child\\_next() will return [`AVCodecContext`](@ref).priv\\_data and finish iterating. OTOH child\\_class\\_iterate() on [`AVCodecContext`](@ref).av\\_class will iterate over all available codecs with private options.

` avoptions_implement_named_constants Named constants`

It is possible to create named constants for options. Simply set the unit field of the option the constants should apply to a string and create the constants themselves as options of type AV\\_OPT\\_TYPE\\_CONST with their unit field set to the same string. Their default\\_val field should contain the value of the named constant. For example, to add some named constants for the test\\_flags option above, put the following into the child\\_opts array: 

```c++
      { "test_flags", "This is a test option of flags type.",
        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },
      { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },
```

` avoptions_use Using AVOptions`

This section deals with accessing options in an AVOptions-enabled struct. Such structs in FFmpeg are e.g. [`AVCodecContext`](@ref) in libavcodec or [`AVFormatContext`](@ref) in libavformat.

` avoptions_use_examine Examining AVOptions`

The basic functions for examining options are [`av_opt_next`](@ref)(), which iterates over all options defined for one object, and [`av_opt_find`](@ref)(), which searches for an option with the given name.

The situation is more complicated with nesting. An AVOptions-enabled struct may have AVOptions-enabled children. Passing the [`AV_OPT_SEARCH_CHILDREN`](@ref) flag to [`av_opt_find`](@ref)() will make the function search children recursively.

For enumerating there are basically two cases. The first is when you want to get all options that may potentially exist on the struct and its children (e.g. when constructing documentation). In that case you should call [`av_opt_child_class_iterate`](@ref)() recursively on the parent struct's [`AVClass`](@ref). The second case is when you have an already initialized struct with all its children and you want to get all options that can be actually written or read from it. In that case you should call [`av_opt_child_next`](@ref)() recursively (and [`av_opt_next`](@ref)() on each result).

` avoptions_use_get_set Reading and writing AVOptions`

When setting options, you often have a string read directly from the user. In such a case, simply passing it to [`av_opt_set`](@ref)() is enough. For non-string type options, [`av_opt_set`](@ref)() will parse the string according to the option type.

Similarly [`av_opt_get`](@ref)() will read any option type and convert it to a string which will be returned. Do not forget that the string is allocated, so you have to free it with [`av_free`](@ref)().

In some cases it may be more convenient to put all options into an [`AVDictionary`](@ref) and call [`av_opt_set_dict`](@ref)() on it. A specific case of this are the format/codec open functions in lavf/lavc which take a dictionary filled with option as a parameter. This makes it possible to set some options that cannot be set otherwise, since e.g. the input file format is not known before the file is actually opened.
"""
const AVOptionType = UInt32
const AV_OPT_TYPE_FLAGS = 0 % UInt32
const AV_OPT_TYPE_INT = 1 % UInt32
const AV_OPT_TYPE_INT64 = 2 % UInt32
const AV_OPT_TYPE_DOUBLE = 3 % UInt32
const AV_OPT_TYPE_FLOAT = 4 % UInt32
const AV_OPT_TYPE_STRING = 5 % UInt32
const AV_OPT_TYPE_RATIONAL = 6 % UInt32
const AV_OPT_TYPE_BINARY = 7 % UInt32
const AV_OPT_TYPE_DICT = 8 % UInt32
const AV_OPT_TYPE_UINT64 = 9 % UInt32
const AV_OPT_TYPE_CONST = 10 % UInt32
const AV_OPT_TYPE_IMAGE_SIZE = 11 % UInt32
const AV_OPT_TYPE_PIXEL_FMT = 12 % UInt32
const AV_OPT_TYPE_SAMPLE_FMT = 13 % UInt32
const AV_OPT_TYPE_VIDEO_RATE = 14 % UInt32
const AV_OPT_TYPE_DURATION = 15 % UInt32
const AV_OPT_TYPE_COLOR = 16 % UInt32
const AV_OPT_TYPE_CHANNEL_LAYOUT = 17 % UInt32
const AV_OPT_TYPE_BOOL = 18 % UInt32

"""
    __JL_Ctag_1122

the default value for scalar options
"""
struct __JL_Ctag_1122
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_1122}, f::Symbol)
    f === :i64 && return Ptr{Int64}(x + 0)
    f === :dbl && return Ptr{Cdouble}(x + 0)
    f === :str && return Ptr{Cstring}(x + 0)
    f === :q && return Ptr{AVRational}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_1122, f::Symbol)
    r = Ref{__JL_Ctag_1122}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_1122}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_1122}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVOption

[`AVOption`](@ref)
"""
struct AVOption
    data::NTuple{64, UInt8}
end

function Base.getproperty(x::Ptr{AVOption}, f::Symbol)
    f === :name && return Ptr{Cstring}(x + 0)
    f === :help && return Ptr{Cstring}(x + 8)
    f === :offset && return Ptr{Cint}(x + 16)
    f === :type && return Ptr{AVOptionType}(x + 20)
    f === :default_val && return Ptr{__JL_Ctag_1122}(x + 24)
    f === :min && return Ptr{Cdouble}(x + 32)
    f === :max && return Ptr{Cdouble}(x + 40)
    f === :flags && return Ptr{Cint}(x + 48)
    f === :unit && return Ptr{Cstring}(x + 56)
    return getfield(x, f)
end

function Base.getproperty(x::AVOption, f::Symbol)
    r = Ref{AVOption}(x)
    ptr = Base.unsafe_convert(Ptr{AVOption}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVOption}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

const AVClassCategory = UInt32
const AV_CLASS_CATEGORY_NA = 0 % UInt32
const AV_CLASS_CATEGORY_INPUT = 1 % UInt32
const AV_CLASS_CATEGORY_OUTPUT = 2 % UInt32
const AV_CLASS_CATEGORY_MUXER = 3 % UInt32
const AV_CLASS_CATEGORY_DEMUXER = 4 % UInt32
const AV_CLASS_CATEGORY_ENCODER = 5 % UInt32
const AV_CLASS_CATEGORY_DECODER = 6 % UInt32
const AV_CLASS_CATEGORY_FILTER = 7 % UInt32
const AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8 % UInt32
const AV_CLASS_CATEGORY_SWSCALER = 9 % UInt32
const AV_CLASS_CATEGORY_SWRESAMPLER = 10 % UInt32
const AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40 % UInt32
const AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41 % UInt32
const AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42 % UInt32
const AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43 % UInt32
const AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44 % UInt32
const AV_CLASS_CATEGORY_DEVICE_INPUT = 45 % UInt32
const AV_CLASS_CATEGORY_NB = 46 % UInt32

"""
    AVClass

Describe the class of an [`AVClass`](@ref) context structure. That is an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (e.g. [`AVCodecContext`](@ref), [`AVFormatContext`](@ref) etc.).
"""
struct AVClass
    data::NTuple{88, UInt8}
end

function Base.getproperty(x::Ptr{AVClass}, f::Symbol)
    f === :class_name && return Ptr{Cstring}(x + 0)
    f === :item_name && return Ptr{Ptr{Cvoid}}(x + 8)
    f === :option && return Ptr{Ptr{AVOption}}(x + 16)
    f === :version && return Ptr{Cint}(x + 24)
    f === :log_level_offset_offset && return Ptr{Cint}(x + 28)
    f === :parent_log_context_offset && return Ptr{Cint}(x + 32)
    f === :child_next && return Ptr{Ptr{Cvoid}}(x + 40)
    f === :child_class_next && return Ptr{Ptr{Cvoid}}(x + 48)
    f === :category && return Ptr{AVClassCategory}(x + 56)
    f === :get_category && return Ptr{Ptr{Cvoid}}(x + 64)
    f === :query_ranges && return Ptr{Ptr{Cvoid}}(x + 72)
    f === :child_class_iterate && return Ptr{Ptr{Cvoid}}(x + 80)
    return getfield(x, f)
end

function Base.getproperty(x::AVClass, f::Symbol)
    r = Ref{AVClass}(x)
    ptr = Base.unsafe_convert(Ptr{AVClass}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVClass}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVMediaType

` lavu_media Media Type`

Media Type
"""
const AVMediaType = Int32
const AVMEDIA_TYPE_UNKNOWN = -1 % Int32
const AVMEDIA_TYPE_VIDEO = 0 % Int32
const AVMEDIA_TYPE_AUDIO = 1 % Int32
const AVMEDIA_TYPE_DATA = 2 % Int32
const AVMEDIA_TYPE_SUBTITLE = 3 % Int32
const AVMEDIA_TYPE_ATTACHMENT = 4 % Int32
const AVMEDIA_TYPE_NB = 5 % Int32

"""
    AVCodecID

Identify the syntax and semantics of the bitstream. The principle is roughly: Two decoders with the same ID can decode the same streams. Two encoders with the same ID can encode compatible streams. There may be slight deviations from the principle due to implementation details.

If you add a codec ID to this list, add it so that 1. no value of an existing codec ID changes (that would break ABI), 2. it is as close as possible to similar codecs

After adding new codec IDs, do not forget to add an entry to the codec descriptor list and bump libavcodec minor version.
"""
const AVCodecID = UInt32
const AV_CODEC_ID_NONE = 0 % UInt32
const AV_CODEC_ID_MPEG1VIDEO = 1 % UInt32
const AV_CODEC_ID_MPEG2VIDEO = 2 % UInt32
const AV_CODEC_ID_H261 = 3 % UInt32
const AV_CODEC_ID_H263 = 4 % UInt32
const AV_CODEC_ID_RV10 = 5 % UInt32
const AV_CODEC_ID_RV20 = 6 % UInt32
const AV_CODEC_ID_MJPEG = 7 % UInt32
const AV_CODEC_ID_MJPEGB = 8 % UInt32
const AV_CODEC_ID_LJPEG = 9 % UInt32
const AV_CODEC_ID_SP5X = 10 % UInt32
const AV_CODEC_ID_JPEGLS = 11 % UInt32
const AV_CODEC_ID_MPEG4 = 12 % UInt32
const AV_CODEC_ID_RAWVIDEO = 13 % UInt32
const AV_CODEC_ID_MSMPEG4V1 = 14 % UInt32
const AV_CODEC_ID_MSMPEG4V2 = 15 % UInt32
const AV_CODEC_ID_MSMPEG4V3 = 16 % UInt32
const AV_CODEC_ID_WMV1 = 17 % UInt32
const AV_CODEC_ID_WMV2 = 18 % UInt32
const AV_CODEC_ID_H263P = 19 % UInt32
const AV_CODEC_ID_H263I = 20 % UInt32
const AV_CODEC_ID_FLV1 = 21 % UInt32
const AV_CODEC_ID_SVQ1 = 22 % UInt32
const AV_CODEC_ID_SVQ3 = 23 % UInt32
const AV_CODEC_ID_DVVIDEO = 24 % UInt32
const AV_CODEC_ID_HUFFYUV = 25 % UInt32
const AV_CODEC_ID_CYUV = 26 % UInt32
const AV_CODEC_ID_H264 = 27 % UInt32
const AV_CODEC_ID_INDEO3 = 28 % UInt32
const AV_CODEC_ID_VP3 = 29 % UInt32
const AV_CODEC_ID_THEORA = 30 % UInt32
const AV_CODEC_ID_ASV1 = 31 % UInt32
const AV_CODEC_ID_ASV2 = 32 % UInt32
const AV_CODEC_ID_FFV1 = 33 % UInt32
const AV_CODEC_ID_4XM = 34 % UInt32
const AV_CODEC_ID_VCR1 = 35 % UInt32
const AV_CODEC_ID_CLJR = 36 % UInt32
const AV_CODEC_ID_MDEC = 37 % UInt32
const AV_CODEC_ID_ROQ = 38 % UInt32
const AV_CODEC_ID_INTERPLAY_VIDEO = 39 % UInt32
const AV_CODEC_ID_XAN_WC3 = 40 % UInt32
const AV_CODEC_ID_XAN_WC4 = 41 % UInt32
const AV_CODEC_ID_RPZA = 42 % UInt32
const AV_CODEC_ID_CINEPAK = 43 % UInt32
const AV_CODEC_ID_WS_VQA = 44 % UInt32
const AV_CODEC_ID_MSRLE = 45 % UInt32
const AV_CODEC_ID_MSVIDEO1 = 46 % UInt32
const AV_CODEC_ID_IDCIN = 47 % UInt32
const AV_CODEC_ID_8BPS = 48 % UInt32
const AV_CODEC_ID_SMC = 49 % UInt32
const AV_CODEC_ID_FLIC = 50 % UInt32
const AV_CODEC_ID_TRUEMOTION1 = 51 % UInt32
const AV_CODEC_ID_VMDVIDEO = 52 % UInt32
const AV_CODEC_ID_MSZH = 53 % UInt32
const AV_CODEC_ID_ZLIB = 54 % UInt32
const AV_CODEC_ID_QTRLE = 55 % UInt32
const AV_CODEC_ID_TSCC = 56 % UInt32
const AV_CODEC_ID_ULTI = 57 % UInt32
const AV_CODEC_ID_QDRAW = 58 % UInt32
const AV_CODEC_ID_VIXL = 59 % UInt32
const AV_CODEC_ID_QPEG = 60 % UInt32
const AV_CODEC_ID_PNG = 61 % UInt32
const AV_CODEC_ID_PPM = 62 % UInt32
const AV_CODEC_ID_PBM = 63 % UInt32
const AV_CODEC_ID_PGM = 64 % UInt32
const AV_CODEC_ID_PGMYUV = 65 % UInt32
const AV_CODEC_ID_PAM = 66 % UInt32
const AV_CODEC_ID_FFVHUFF = 67 % UInt32
const AV_CODEC_ID_RV30 = 68 % UInt32
const AV_CODEC_ID_RV40 = 69 % UInt32
const AV_CODEC_ID_VC1 = 70 % UInt32
const AV_CODEC_ID_WMV3 = 71 % UInt32
const AV_CODEC_ID_LOCO = 72 % UInt32
const AV_CODEC_ID_WNV1 = 73 % UInt32
const AV_CODEC_ID_AASC = 74 % UInt32
const AV_CODEC_ID_INDEO2 = 75 % UInt32
const AV_CODEC_ID_FRAPS = 76 % UInt32
const AV_CODEC_ID_TRUEMOTION2 = 77 % UInt32
const AV_CODEC_ID_BMP = 78 % UInt32
const AV_CODEC_ID_CSCD = 79 % UInt32
const AV_CODEC_ID_MMVIDEO = 80 % UInt32
const AV_CODEC_ID_ZMBV = 81 % UInt32
const AV_CODEC_ID_AVS = 82 % UInt32
const AV_CODEC_ID_SMACKVIDEO = 83 % UInt32
const AV_CODEC_ID_NUV = 84 % UInt32
const AV_CODEC_ID_KMVC = 85 % UInt32
const AV_CODEC_ID_FLASHSV = 86 % UInt32
const AV_CODEC_ID_CAVS = 87 % UInt32
const AV_CODEC_ID_JPEG2000 = 88 % UInt32
const AV_CODEC_ID_VMNC = 89 % UInt32
const AV_CODEC_ID_VP5 = 90 % UInt32
const AV_CODEC_ID_VP6 = 91 % UInt32
const AV_CODEC_ID_VP6F = 92 % UInt32
const AV_CODEC_ID_TARGA = 93 % UInt32
const AV_CODEC_ID_DSICINVIDEO = 94 % UInt32
const AV_CODEC_ID_TIERTEXSEQVIDEO = 95 % UInt32
const AV_CODEC_ID_TIFF = 96 % UInt32
const AV_CODEC_ID_GIF = 97 % UInt32
const AV_CODEC_ID_DXA = 98 % UInt32
const AV_CODEC_ID_DNXHD = 99 % UInt32
const AV_CODEC_ID_THP = 100 % UInt32
const AV_CODEC_ID_SGI = 101 % UInt32
const AV_CODEC_ID_C93 = 102 % UInt32
const AV_CODEC_ID_BETHSOFTVID = 103 % UInt32
const AV_CODEC_ID_PTX = 104 % UInt32
const AV_CODEC_ID_TXD = 105 % UInt32
const AV_CODEC_ID_VP6A = 106 % UInt32
const AV_CODEC_ID_AMV = 107 % UInt32
const AV_CODEC_ID_VB = 108 % UInt32
const AV_CODEC_ID_PCX = 109 % UInt32
const AV_CODEC_ID_SUNRAST = 110 % UInt32
const AV_CODEC_ID_INDEO4 = 111 % UInt32
const AV_CODEC_ID_INDEO5 = 112 % UInt32
const AV_CODEC_ID_MIMIC = 113 % UInt32
const AV_CODEC_ID_RL2 = 114 % UInt32
const AV_CODEC_ID_ESCAPE124 = 115 % UInt32
const AV_CODEC_ID_DIRAC = 116 % UInt32
const AV_CODEC_ID_BFI = 117 % UInt32
const AV_CODEC_ID_CMV = 118 % UInt32
const AV_CODEC_ID_MOTIONPIXELS = 119 % UInt32
const AV_CODEC_ID_TGV = 120 % UInt32
const AV_CODEC_ID_TGQ = 121 % UInt32
const AV_CODEC_ID_TQI = 122 % UInt32
const AV_CODEC_ID_AURA = 123 % UInt32
const AV_CODEC_ID_AURA2 = 124 % UInt32
const AV_CODEC_ID_V210X = 125 % UInt32
const AV_CODEC_ID_TMV = 126 % UInt32
const AV_CODEC_ID_V210 = 127 % UInt32
const AV_CODEC_ID_DPX = 128 % UInt32
const AV_CODEC_ID_MAD = 129 % UInt32
const AV_CODEC_ID_FRWU = 130 % UInt32
const AV_CODEC_ID_FLASHSV2 = 131 % UInt32
const AV_CODEC_ID_CDGRAPHICS = 132 % UInt32
const AV_CODEC_ID_R210 = 133 % UInt32
const AV_CODEC_ID_ANM = 134 % UInt32
const AV_CODEC_ID_BINKVIDEO = 135 % UInt32
const AV_CODEC_ID_IFF_ILBM = 136 % UInt32
const AV_CODEC_ID_KGV1 = 137 % UInt32
const AV_CODEC_ID_YOP = 138 % UInt32
const AV_CODEC_ID_VP8 = 139 % UInt32
const AV_CODEC_ID_PICTOR = 140 % UInt32
const AV_CODEC_ID_ANSI = 141 % UInt32
const AV_CODEC_ID_A64_MULTI = 142 % UInt32
const AV_CODEC_ID_A64_MULTI5 = 143 % UInt32
const AV_CODEC_ID_R10K = 144 % UInt32
const AV_CODEC_ID_MXPEG = 145 % UInt32
const AV_CODEC_ID_LAGARITH = 146 % UInt32
const AV_CODEC_ID_PRORES = 147 % UInt32
const AV_CODEC_ID_JV = 148 % UInt32
const AV_CODEC_ID_DFA = 149 % UInt32
const AV_CODEC_ID_WMV3IMAGE = 150 % UInt32
const AV_CODEC_ID_VC1IMAGE = 151 % UInt32
const AV_CODEC_ID_UTVIDEO = 152 % UInt32
const AV_CODEC_ID_BMV_VIDEO = 153 % UInt32
const AV_CODEC_ID_VBLE = 154 % UInt32
const AV_CODEC_ID_DXTORY = 155 % UInt32
const AV_CODEC_ID_V410 = 156 % UInt32
const AV_CODEC_ID_XWD = 157 % UInt32
const AV_CODEC_ID_CDXL = 158 % UInt32
const AV_CODEC_ID_XBM = 159 % UInt32
const AV_CODEC_ID_ZEROCODEC = 160 % UInt32
const AV_CODEC_ID_MSS1 = 161 % UInt32
const AV_CODEC_ID_MSA1 = 162 % UInt32
const AV_CODEC_ID_TSCC2 = 163 % UInt32
const AV_CODEC_ID_MTS2 = 164 % UInt32
const AV_CODEC_ID_CLLC = 165 % UInt32
const AV_CODEC_ID_MSS2 = 166 % UInt32
const AV_CODEC_ID_VP9 = 167 % UInt32
const AV_CODEC_ID_AIC = 168 % UInt32
const AV_CODEC_ID_ESCAPE130 = 169 % UInt32
const AV_CODEC_ID_G2M = 170 % UInt32
const AV_CODEC_ID_WEBP = 171 % UInt32
const AV_CODEC_ID_HNM4_VIDEO = 172 % UInt32
const AV_CODEC_ID_HEVC = 173 % UInt32
const AV_CODEC_ID_FIC = 174 % UInt32
const AV_CODEC_ID_ALIAS_PIX = 175 % UInt32
const AV_CODEC_ID_BRENDER_PIX = 176 % UInt32
const AV_CODEC_ID_PAF_VIDEO = 177 % UInt32
const AV_CODEC_ID_EXR = 178 % UInt32
const AV_CODEC_ID_VP7 = 179 % UInt32
const AV_CODEC_ID_SANM = 180 % UInt32
const AV_CODEC_ID_SGIRLE = 181 % UInt32
const AV_CODEC_ID_MVC1 = 182 % UInt32
const AV_CODEC_ID_MVC2 = 183 % UInt32
const AV_CODEC_ID_HQX = 184 % UInt32
const AV_CODEC_ID_TDSC = 185 % UInt32
const AV_CODEC_ID_HQ_HQA = 186 % UInt32
const AV_CODEC_ID_HAP = 187 % UInt32
const AV_CODEC_ID_DDS = 188 % UInt32
const AV_CODEC_ID_DXV = 189 % UInt32
const AV_CODEC_ID_SCREENPRESSO = 190 % UInt32
const AV_CODEC_ID_RSCC = 191 % UInt32
const AV_CODEC_ID_AVS2 = 192 % UInt32
const AV_CODEC_ID_PGX = 193 % UInt32
const AV_CODEC_ID_AVS3 = 194 % UInt32
const AV_CODEC_ID_MSP2 = 195 % UInt32
const AV_CODEC_ID_VVC = 196 % UInt32
const AV_CODEC_ID_Y41P = 32768 % UInt32
const AV_CODEC_ID_AVRP = 32769 % UInt32
const AV_CODEC_ID_012V = 32770 % UInt32
const AV_CODEC_ID_AVUI = 32771 % UInt32
const AV_CODEC_ID_AYUV = 32772 % UInt32
const AV_CODEC_ID_TARGA_Y216 = 32773 % UInt32
const AV_CODEC_ID_V308 = 32774 % UInt32
const AV_CODEC_ID_V408 = 32775 % UInt32
const AV_CODEC_ID_YUV4 = 32776 % UInt32
const AV_CODEC_ID_AVRN = 32777 % UInt32
const AV_CODEC_ID_CPIA = 32778 % UInt32
const AV_CODEC_ID_XFACE = 32779 % UInt32
const AV_CODEC_ID_SNOW = 32780 % UInt32
const AV_CODEC_ID_SMVJPEG = 32781 % UInt32
const AV_CODEC_ID_APNG = 32782 % UInt32
const AV_CODEC_ID_DAALA = 32783 % UInt32
const AV_CODEC_ID_CFHD = 32784 % UInt32
const AV_CODEC_ID_TRUEMOTION2RT = 32785 % UInt32
const AV_CODEC_ID_M101 = 32786 % UInt32
const AV_CODEC_ID_MAGICYUV = 32787 % UInt32
const AV_CODEC_ID_SHEERVIDEO = 32788 % UInt32
const AV_CODEC_ID_YLC = 32789 % UInt32
const AV_CODEC_ID_PSD = 32790 % UInt32
const AV_CODEC_ID_PIXLET = 32791 % UInt32
const AV_CODEC_ID_SPEEDHQ = 32792 % UInt32
const AV_CODEC_ID_FMVC = 32793 % UInt32
const AV_CODEC_ID_SCPR = 32794 % UInt32
const AV_CODEC_ID_CLEARVIDEO = 32795 % UInt32
const AV_CODEC_ID_XPM = 32796 % UInt32
const AV_CODEC_ID_AV1 = 32797 % UInt32
const AV_CODEC_ID_BITPACKED = 32798 % UInt32
const AV_CODEC_ID_MSCC = 32799 % UInt32
const AV_CODEC_ID_SRGC = 32800 % UInt32
const AV_CODEC_ID_SVG = 32801 % UInt32
const AV_CODEC_ID_GDV = 32802 % UInt32
const AV_CODEC_ID_FITS = 32803 % UInt32
const AV_CODEC_ID_IMM4 = 32804 % UInt32
const AV_CODEC_ID_PROSUMER = 32805 % UInt32
const AV_CODEC_ID_MWSC = 32806 % UInt32
const AV_CODEC_ID_WCMV = 32807 % UInt32
const AV_CODEC_ID_RASC = 32808 % UInt32
const AV_CODEC_ID_HYMT = 32809 % UInt32
const AV_CODEC_ID_ARBC = 32810 % UInt32
const AV_CODEC_ID_AGM = 32811 % UInt32
const AV_CODEC_ID_LSCR = 32812 % UInt32
const AV_CODEC_ID_VP4 = 32813 % UInt32
const AV_CODEC_ID_IMM5 = 32814 % UInt32
const AV_CODEC_ID_MVDV = 32815 % UInt32
const AV_CODEC_ID_MVHA = 32816 % UInt32
const AV_CODEC_ID_CDTOONS = 32817 % UInt32
const AV_CODEC_ID_MV30 = 32818 % UInt32
const AV_CODEC_ID_NOTCHLC = 32819 % UInt32
const AV_CODEC_ID_PFM = 32820 % UInt32
const AV_CODEC_ID_MOBICLIP = 32821 % UInt32
const AV_CODEC_ID_PHOTOCD = 32822 % UInt32
const AV_CODEC_ID_IPU = 32823 % UInt32
const AV_CODEC_ID_ARGO = 32824 % UInt32
const AV_CODEC_ID_CRI = 32825 % UInt32
const AV_CODEC_ID_SIMBIOSIS_IMX = 32826 % UInt32
const AV_CODEC_ID_SGA_VIDEO = 32827 % UInt32
const AV_CODEC_ID_FIRST_AUDIO = 65536 % UInt32
const AV_CODEC_ID_PCM_S16LE = 65536 % UInt32
const AV_CODEC_ID_PCM_S16BE = 65537 % UInt32
const AV_CODEC_ID_PCM_U16LE = 65538 % UInt32
const AV_CODEC_ID_PCM_U16BE = 65539 % UInt32
const AV_CODEC_ID_PCM_S8 = 65540 % UInt32
const AV_CODEC_ID_PCM_U8 = 65541 % UInt32
const AV_CODEC_ID_PCM_MULAW = 65542 % UInt32
const AV_CODEC_ID_PCM_ALAW = 65543 % UInt32
const AV_CODEC_ID_PCM_S32LE = 65544 % UInt32
const AV_CODEC_ID_PCM_S32BE = 65545 % UInt32
const AV_CODEC_ID_PCM_U32LE = 65546 % UInt32
const AV_CODEC_ID_PCM_U32BE = 65547 % UInt32
const AV_CODEC_ID_PCM_S24LE = 65548 % UInt32
const AV_CODEC_ID_PCM_S24BE = 65549 % UInt32
const AV_CODEC_ID_PCM_U24LE = 65550 % UInt32
const AV_CODEC_ID_PCM_U24BE = 65551 % UInt32
const AV_CODEC_ID_PCM_S24DAUD = 65552 % UInt32
const AV_CODEC_ID_PCM_ZORK = 65553 % UInt32
const AV_CODEC_ID_PCM_S16LE_PLANAR = 65554 % UInt32
const AV_CODEC_ID_PCM_DVD = 65555 % UInt32
const AV_CODEC_ID_PCM_F32BE = 65556 % UInt32
const AV_CODEC_ID_PCM_F32LE = 65557 % UInt32
const AV_CODEC_ID_PCM_F64BE = 65558 % UInt32
const AV_CODEC_ID_PCM_F64LE = 65559 % UInt32
const AV_CODEC_ID_PCM_BLURAY = 65560 % UInt32
const AV_CODEC_ID_PCM_LXF = 65561 % UInt32
const AV_CODEC_ID_S302M = 65562 % UInt32
const AV_CODEC_ID_PCM_S8_PLANAR = 65563 % UInt32
const AV_CODEC_ID_PCM_S24LE_PLANAR = 65564 % UInt32
const AV_CODEC_ID_PCM_S32LE_PLANAR = 65565 % UInt32
const AV_CODEC_ID_PCM_S16BE_PLANAR = 65566 % UInt32
const AV_CODEC_ID_PCM_S64LE = 67584 % UInt32
const AV_CODEC_ID_PCM_S64BE = 67585 % UInt32
const AV_CODEC_ID_PCM_F16LE = 67586 % UInt32
const AV_CODEC_ID_PCM_F24LE = 67587 % UInt32
const AV_CODEC_ID_PCM_VIDC = 67588 % UInt32
const AV_CODEC_ID_PCM_SGA = 67589 % UInt32
const AV_CODEC_ID_ADPCM_IMA_QT = 69632 % UInt32
const AV_CODEC_ID_ADPCM_IMA_WAV = 69633 % UInt32
const AV_CODEC_ID_ADPCM_IMA_DK3 = 69634 % UInt32
const AV_CODEC_ID_ADPCM_IMA_DK4 = 69635 % UInt32
const AV_CODEC_ID_ADPCM_IMA_WS = 69636 % UInt32
const AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637 % UInt32
const AV_CODEC_ID_ADPCM_MS = 69638 % UInt32
const AV_CODEC_ID_ADPCM_4XM = 69639 % UInt32
const AV_CODEC_ID_ADPCM_XA = 69640 % UInt32
const AV_CODEC_ID_ADPCM_ADX = 69641 % UInt32
const AV_CODEC_ID_ADPCM_EA = 69642 % UInt32
const AV_CODEC_ID_ADPCM_G726 = 69643 % UInt32
const AV_CODEC_ID_ADPCM_CT = 69644 % UInt32
const AV_CODEC_ID_ADPCM_SWF = 69645 % UInt32
const AV_CODEC_ID_ADPCM_YAMAHA = 69646 % UInt32
const AV_CODEC_ID_ADPCM_SBPRO_4 = 69647 % UInt32
const AV_CODEC_ID_ADPCM_SBPRO_3 = 69648 % UInt32
const AV_CODEC_ID_ADPCM_SBPRO_2 = 69649 % UInt32
const AV_CODEC_ID_ADPCM_THP = 69650 % UInt32
const AV_CODEC_ID_ADPCM_IMA_AMV = 69651 % UInt32
const AV_CODEC_ID_ADPCM_EA_R1 = 69652 % UInt32
const AV_CODEC_ID_ADPCM_EA_R3 = 69653 % UInt32
const AV_CODEC_ID_ADPCM_EA_R2 = 69654 % UInt32
const AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655 % UInt32
const AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656 % UInt32
const AV_CODEC_ID_ADPCM_EA_XAS = 69657 % UInt32
const AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658 % UInt32
const AV_CODEC_ID_ADPCM_IMA_ISS = 69659 % UInt32
const AV_CODEC_ID_ADPCM_G722 = 69660 % UInt32
const AV_CODEC_ID_ADPCM_IMA_APC = 69661 % UInt32
const AV_CODEC_ID_ADPCM_VIMA = 69662 % UInt32
const AV_CODEC_ID_ADPCM_AFC = 71680 % UInt32
const AV_CODEC_ID_ADPCM_IMA_OKI = 71681 % UInt32
const AV_CODEC_ID_ADPCM_DTK = 71682 % UInt32
const AV_CODEC_ID_ADPCM_IMA_RAD = 71683 % UInt32
const AV_CODEC_ID_ADPCM_G726LE = 71684 % UInt32
const AV_CODEC_ID_ADPCM_THP_LE = 71685 % UInt32
const AV_CODEC_ID_ADPCM_PSX = 71686 % UInt32
const AV_CODEC_ID_ADPCM_AICA = 71687 % UInt32
const AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688 % UInt32
const AV_CODEC_ID_ADPCM_MTAF = 71689 % UInt32
const AV_CODEC_ID_ADPCM_AGM = 71690 % UInt32
const AV_CODEC_ID_ADPCM_ARGO = 71691 % UInt32
const AV_CODEC_ID_ADPCM_IMA_SSI = 71692 % UInt32
const AV_CODEC_ID_ADPCM_ZORK = 71693 % UInt32
const AV_CODEC_ID_ADPCM_IMA_APM = 71694 % UInt32
const AV_CODEC_ID_ADPCM_IMA_ALP = 71695 % UInt32
const AV_CODEC_ID_ADPCM_IMA_MTF = 71696 % UInt32
const AV_CODEC_ID_ADPCM_IMA_CUNNING = 71697 % UInt32
const AV_CODEC_ID_ADPCM_IMA_MOFLEX = 71698 % UInt32
const AV_CODEC_ID_AMR_NB = 73728 % UInt32
const AV_CODEC_ID_AMR_WB = 73729 % UInt32
const AV_CODEC_ID_RA_144 = 77824 % UInt32
const AV_CODEC_ID_RA_288 = 77825 % UInt32
const AV_CODEC_ID_ROQ_DPCM = 81920 % UInt32
const AV_CODEC_ID_INTERPLAY_DPCM = 81921 % UInt32
const AV_CODEC_ID_XAN_DPCM = 81922 % UInt32
const AV_CODEC_ID_SOL_DPCM = 81923 % UInt32
const AV_CODEC_ID_SDX2_DPCM = 83968 % UInt32
const AV_CODEC_ID_GREMLIN_DPCM = 83969 % UInt32
const AV_CODEC_ID_DERF_DPCM = 83970 % UInt32
const AV_CODEC_ID_MP2 = 86016 % UInt32
const AV_CODEC_ID_MP3 = 86017 % UInt32
const AV_CODEC_ID_AAC = 86018 % UInt32
const AV_CODEC_ID_AC3 = 86019 % UInt32
const AV_CODEC_ID_DTS = 86020 % UInt32
const AV_CODEC_ID_VORBIS = 86021 % UInt32
const AV_CODEC_ID_DVAUDIO = 86022 % UInt32
const AV_CODEC_ID_WMAV1 = 86023 % UInt32
const AV_CODEC_ID_WMAV2 = 86024 % UInt32
const AV_CODEC_ID_MACE3 = 86025 % UInt32
const AV_CODEC_ID_MACE6 = 86026 % UInt32
const AV_CODEC_ID_VMDAUDIO = 86027 % UInt32
const AV_CODEC_ID_FLAC = 86028 % UInt32
const AV_CODEC_ID_MP3ADU = 86029 % UInt32
const AV_CODEC_ID_MP3ON4 = 86030 % UInt32
const AV_CODEC_ID_SHORTEN = 86031 % UInt32
const AV_CODEC_ID_ALAC = 86032 % UInt32
const AV_CODEC_ID_WESTWOOD_SND1 = 86033 % UInt32
const AV_CODEC_ID_GSM = 86034 % UInt32
const AV_CODEC_ID_QDM2 = 86035 % UInt32
const AV_CODEC_ID_COOK = 86036 % UInt32
const AV_CODEC_ID_TRUESPEECH = 86037 % UInt32
const AV_CODEC_ID_TTA = 86038 % UInt32
const AV_CODEC_ID_SMACKAUDIO = 86039 % UInt32
const AV_CODEC_ID_QCELP = 86040 % UInt32
const AV_CODEC_ID_WAVPACK = 86041 % UInt32
const AV_CODEC_ID_DSICINAUDIO = 86042 % UInt32
const AV_CODEC_ID_IMC = 86043 % UInt32
const AV_CODEC_ID_MUSEPACK7 = 86044 % UInt32
const AV_CODEC_ID_MLP = 86045 % UInt32
const AV_CODEC_ID_GSM_MS = 86046 % UInt32
const AV_CODEC_ID_ATRAC3 = 86047 % UInt32
const AV_CODEC_ID_APE = 86048 % UInt32
const AV_CODEC_ID_NELLYMOSER = 86049 % UInt32
const AV_CODEC_ID_MUSEPACK8 = 86050 % UInt32
const AV_CODEC_ID_SPEEX = 86051 % UInt32
const AV_CODEC_ID_WMAVOICE = 86052 % UInt32
const AV_CODEC_ID_WMAPRO = 86053 % UInt32
const AV_CODEC_ID_WMALOSSLESS = 86054 % UInt32
const AV_CODEC_ID_ATRAC3P = 86055 % UInt32
const AV_CODEC_ID_EAC3 = 86056 % UInt32
const AV_CODEC_ID_SIPR = 86057 % UInt32
const AV_CODEC_ID_MP1 = 86058 % UInt32
const AV_CODEC_ID_TWINVQ = 86059 % UInt32
const AV_CODEC_ID_TRUEHD = 86060 % UInt32
const AV_CODEC_ID_MP4ALS = 86061 % UInt32
const AV_CODEC_ID_ATRAC1 = 86062 % UInt32
const AV_CODEC_ID_BINKAUDIO_RDFT = 86063 % UInt32
const AV_CODEC_ID_BINKAUDIO_DCT = 86064 % UInt32
const AV_CODEC_ID_AAC_LATM = 86065 % UInt32
const AV_CODEC_ID_QDMC = 86066 % UInt32
const AV_CODEC_ID_CELT = 86067 % UInt32
const AV_CODEC_ID_G723_1 = 86068 % UInt32
const AV_CODEC_ID_G729 = 86069 % UInt32
const AV_CODEC_ID_8SVX_EXP = 86070 % UInt32
const AV_CODEC_ID_8SVX_FIB = 86071 % UInt32
const AV_CODEC_ID_BMV_AUDIO = 86072 % UInt32
const AV_CODEC_ID_RALF = 86073 % UInt32
const AV_CODEC_ID_IAC = 86074 % UInt32
const AV_CODEC_ID_ILBC = 86075 % UInt32
const AV_CODEC_ID_OPUS = 86076 % UInt32
const AV_CODEC_ID_COMFORT_NOISE = 86077 % UInt32
const AV_CODEC_ID_TAK = 86078 % UInt32
const AV_CODEC_ID_METASOUND = 86079 % UInt32
const AV_CODEC_ID_PAF_AUDIO = 86080 % UInt32
const AV_CODEC_ID_ON2AVC = 86081 % UInt32
const AV_CODEC_ID_DSS_SP = 86082 % UInt32
const AV_CODEC_ID_CODEC2 = 86083 % UInt32
const AV_CODEC_ID_FFWAVESYNTH = 88064 % UInt32
const AV_CODEC_ID_SONIC = 88065 % UInt32
const AV_CODEC_ID_SONIC_LS = 88066 % UInt32
const AV_CODEC_ID_EVRC = 88067 % UInt32
const AV_CODEC_ID_SMV = 88068 % UInt32
const AV_CODEC_ID_DSD_LSBF = 88069 % UInt32
const AV_CODEC_ID_DSD_MSBF = 88070 % UInt32
const AV_CODEC_ID_DSD_LSBF_PLANAR = 88071 % UInt32
const AV_CODEC_ID_DSD_MSBF_PLANAR = 88072 % UInt32
const AV_CODEC_ID_4GV = 88073 % UInt32
const AV_CODEC_ID_INTERPLAY_ACM = 88074 % UInt32
const AV_CODEC_ID_XMA1 = 88075 % UInt32
const AV_CODEC_ID_XMA2 = 88076 % UInt32
const AV_CODEC_ID_DST = 88077 % UInt32
const AV_CODEC_ID_ATRAC3AL = 88078 % UInt32
const AV_CODEC_ID_ATRAC3PAL = 88079 % UInt32
const AV_CODEC_ID_DOLBY_E = 88080 % UInt32
const AV_CODEC_ID_APTX = 88081 % UInt32
const AV_CODEC_ID_APTX_HD = 88082 % UInt32
const AV_CODEC_ID_SBC = 88083 % UInt32
const AV_CODEC_ID_ATRAC9 = 88084 % UInt32
const AV_CODEC_ID_HCOM = 88085 % UInt32
const AV_CODEC_ID_ACELP_KELVIN = 88086 % UInt32
const AV_CODEC_ID_MPEGH_3D_AUDIO = 88087 % UInt32
const AV_CODEC_ID_SIREN = 88088 % UInt32
const AV_CODEC_ID_HCA = 88089 % UInt32
const AV_CODEC_ID_FASTAUDIO = 88090 % UInt32
const AV_CODEC_ID_FIRST_SUBTITLE = 94208 % UInt32
const AV_CODEC_ID_DVD_SUBTITLE = 94208 % UInt32
const AV_CODEC_ID_DVB_SUBTITLE = 94209 % UInt32
const AV_CODEC_ID_TEXT = 94210 % UInt32
const AV_CODEC_ID_XSUB = 94211 % UInt32
const AV_CODEC_ID_SSA = 94212 % UInt32
const AV_CODEC_ID_MOV_TEXT = 94213 % UInt32
const AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214 % UInt32
const AV_CODEC_ID_DVB_TELETEXT = 94215 % UInt32
const AV_CODEC_ID_SRT = 94216 % UInt32
const AV_CODEC_ID_MICRODVD = 96256 % UInt32
const AV_CODEC_ID_EIA_608 = 96257 % UInt32
const AV_CODEC_ID_JACOSUB = 96258 % UInt32
const AV_CODEC_ID_SAMI = 96259 % UInt32
const AV_CODEC_ID_REALTEXT = 96260 % UInt32
const AV_CODEC_ID_STL = 96261 % UInt32
const AV_CODEC_ID_SUBVIEWER1 = 96262 % UInt32
const AV_CODEC_ID_SUBVIEWER = 96263 % UInt32
const AV_CODEC_ID_SUBRIP = 96264 % UInt32
const AV_CODEC_ID_WEBVTT = 96265 % UInt32
const AV_CODEC_ID_MPL2 = 96266 % UInt32
const AV_CODEC_ID_VPLAYER = 96267 % UInt32
const AV_CODEC_ID_PJS = 96268 % UInt32
const AV_CODEC_ID_ASS = 96269 % UInt32
const AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270 % UInt32
const AV_CODEC_ID_TTML = 96271 % UInt32
const AV_CODEC_ID_ARIB_CAPTION = 96272 % UInt32
const AV_CODEC_ID_FIRST_UNKNOWN = 98304 % UInt32
const AV_CODEC_ID_TTF = 98304 % UInt32
const AV_CODEC_ID_SCTE_35 = 98305 % UInt32
const AV_CODEC_ID_EPG = 98306 % UInt32
const AV_CODEC_ID_BINTEXT = 100352 % UInt32
const AV_CODEC_ID_XBIN = 100353 % UInt32
const AV_CODEC_ID_IDF = 100354 % UInt32
const AV_CODEC_ID_OTF = 100355 % UInt32
const AV_CODEC_ID_SMPTE_KLV = 100356 % UInt32
const AV_CODEC_ID_DVD_NAV = 100357 % UInt32
const AV_CODEC_ID_TIMED_ID3 = 100358 % UInt32
const AV_CODEC_ID_BIN_DATA = 100359 % UInt32
const AV_CODEC_ID_PROBE = 102400 % UInt32
const AV_CODEC_ID_MPEG2TS = 131072 % UInt32
const AV_CODEC_ID_MPEG4SYSTEMS = 131073 % UInt32
const AV_CODEC_ID_FFMETADATA = 135168 % UInt32
const AV_CODEC_ID_WRAPPED_AVFRAME = 135169 % UInt32

mutable struct AVCodecInternal end

"""
    AVRational

Rational number (pair of numerator and denominator).
"""
struct AVRational
    num::Cint
    den::Cint
end

"""
    AVPixelFormat

Pixel format.

!!! note

    [`AV_PIX_FMT_RGB32`](@ref) is handled in an endian-specific manner. An RGBA color is put together as: (A << 24) | (R << 16) | (G << 8) | B This is stored as BGRA on little-endian CPU architectures and ARGB on big-endian CPUs.

!!! note

    If the resolution is not a multiple of the chroma subsampling factor then the chroma plane resolution must be rounded up.

\\par When the pixel format is palettized RGB32 (AV\\_PIX\\_FMT\\_PAL8), the palettized image data is stored in [`AVFrame`](@ref).data[0]. The palette is transported in [`AVFrame`](@ref).data[1], is 1024 bytes long (256 4-byte entries) and is formatted the same as in [`AV_PIX_FMT_RGB32`](@ref) described above (i.e., it is also endian-specific). Note also that the individual RGB32 palette components stored in [`AVFrame`](@ref).data[1] should be in the range 0..255. This is important as many custom PAL8 video codecs that were designed to run on the IBM VGA graphics adapter use 6-bit palette components.

\\par For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like for pal8. This palette is filled in automatically by the function allocating the picture.
"""
const AVPixelFormat = Int32
const AV_PIX_FMT_NONE = -1 % Int32
const AV_PIX_FMT_YUV420P = 0 % Int32
const AV_PIX_FMT_YUYV422 = 1 % Int32
const AV_PIX_FMT_RGB24 = 2 % Int32
const AV_PIX_FMT_BGR24 = 3 % Int32
const AV_PIX_FMT_YUV422P = 4 % Int32
const AV_PIX_FMT_YUV444P = 5 % Int32
const AV_PIX_FMT_YUV410P = 6 % Int32
const AV_PIX_FMT_YUV411P = 7 % Int32
const AV_PIX_FMT_GRAY8 = 8 % Int32
const AV_PIX_FMT_MONOWHITE = 9 % Int32
const AV_PIX_FMT_MONOBLACK = 10 % Int32
const AV_PIX_FMT_PAL8 = 11 % Int32
const AV_PIX_FMT_YUVJ420P = 12 % Int32
const AV_PIX_FMT_YUVJ422P = 13 % Int32
const AV_PIX_FMT_YUVJ444P = 14 % Int32
const AV_PIX_FMT_UYVY422 = 15 % Int32
const AV_PIX_FMT_UYYVYY411 = 16 % Int32
const AV_PIX_FMT_BGR8 = 17 % Int32
const AV_PIX_FMT_BGR4 = 18 % Int32
const AV_PIX_FMT_BGR4_BYTE = 19 % Int32
const AV_PIX_FMT_RGB8 = 20 % Int32
const AV_PIX_FMT_RGB4 = 21 % Int32
const AV_PIX_FMT_RGB4_BYTE = 22 % Int32
const AV_PIX_FMT_NV12 = 23 % Int32
const AV_PIX_FMT_NV21 = 24 % Int32
const AV_PIX_FMT_ARGB = 25 % Int32
const AV_PIX_FMT_RGBA = 26 % Int32
const AV_PIX_FMT_ABGR = 27 % Int32
const AV_PIX_FMT_BGRA = 28 % Int32
const AV_PIX_FMT_GRAY16BE = 29 % Int32
const AV_PIX_FMT_GRAY16LE = 30 % Int32
const AV_PIX_FMT_YUV440P = 31 % Int32
const AV_PIX_FMT_YUVJ440P = 32 % Int32
const AV_PIX_FMT_YUVA420P = 33 % Int32
const AV_PIX_FMT_RGB48BE = 34 % Int32
const AV_PIX_FMT_RGB48LE = 35 % Int32
const AV_PIX_FMT_RGB565BE = 36 % Int32
const AV_PIX_FMT_RGB565LE = 37 % Int32
const AV_PIX_FMT_RGB555BE = 38 % Int32
const AV_PIX_FMT_RGB555LE = 39 % Int32
const AV_PIX_FMT_BGR565BE = 40 % Int32
const AV_PIX_FMT_BGR565LE = 41 % Int32
const AV_PIX_FMT_BGR555BE = 42 % Int32
const AV_PIX_FMT_BGR555LE = 43 % Int32
const AV_PIX_FMT_VAAPI_MOCO = 44 % Int32
const AV_PIX_FMT_VAAPI_IDCT = 45 % Int32
const AV_PIX_FMT_VAAPI_VLD = 46 % Int32
const AV_PIX_FMT_VAAPI = 46 % Int32
const AV_PIX_FMT_YUV420P16LE = 47 % Int32
const AV_PIX_FMT_YUV420P16BE = 48 % Int32
const AV_PIX_FMT_YUV422P16LE = 49 % Int32
const AV_PIX_FMT_YUV422P16BE = 50 % Int32
const AV_PIX_FMT_YUV444P16LE = 51 % Int32
const AV_PIX_FMT_YUV444P16BE = 52 % Int32
const AV_PIX_FMT_DXVA2_VLD = 53 % Int32
const AV_PIX_FMT_RGB444LE = 54 % Int32
const AV_PIX_FMT_RGB444BE = 55 % Int32
const AV_PIX_FMT_BGR444LE = 56 % Int32
const AV_PIX_FMT_BGR444BE = 57 % Int32
const AV_PIX_FMT_YA8 = 58 % Int32
const AV_PIX_FMT_Y400A = 58 % Int32
const AV_PIX_FMT_GRAY8A = 58 % Int32
const AV_PIX_FMT_BGR48BE = 59 % Int32
const AV_PIX_FMT_BGR48LE = 60 % Int32
const AV_PIX_FMT_YUV420P9BE = 61 % Int32
const AV_PIX_FMT_YUV420P9LE = 62 % Int32
const AV_PIX_FMT_YUV420P10BE = 63 % Int32
const AV_PIX_FMT_YUV420P10LE = 64 % Int32
const AV_PIX_FMT_YUV422P10BE = 65 % Int32
const AV_PIX_FMT_YUV422P10LE = 66 % Int32
const AV_PIX_FMT_YUV444P9BE = 67 % Int32
const AV_PIX_FMT_YUV444P9LE = 68 % Int32
const AV_PIX_FMT_YUV444P10BE = 69 % Int32
const AV_PIX_FMT_YUV444P10LE = 70 % Int32
const AV_PIX_FMT_YUV422P9BE = 71 % Int32
const AV_PIX_FMT_YUV422P9LE = 72 % Int32
const AV_PIX_FMT_GBRP = 73 % Int32
const AV_PIX_FMT_GBR24P = 73 % Int32
const AV_PIX_FMT_GBRP9BE = 74 % Int32
const AV_PIX_FMT_GBRP9LE = 75 % Int32
const AV_PIX_FMT_GBRP10BE = 76 % Int32
const AV_PIX_FMT_GBRP10LE = 77 % Int32
const AV_PIX_FMT_GBRP16BE = 78 % Int32
const AV_PIX_FMT_GBRP16LE = 79 % Int32
const AV_PIX_FMT_YUVA422P = 80 % Int32
const AV_PIX_FMT_YUVA444P = 81 % Int32
const AV_PIX_FMT_YUVA420P9BE = 82 % Int32
const AV_PIX_FMT_YUVA420P9LE = 83 % Int32
const AV_PIX_FMT_YUVA422P9BE = 84 % Int32
const AV_PIX_FMT_YUVA422P9LE = 85 % Int32
const AV_PIX_FMT_YUVA444P9BE = 86 % Int32
const AV_PIX_FMT_YUVA444P9LE = 87 % Int32
const AV_PIX_FMT_YUVA420P10BE = 88 % Int32
const AV_PIX_FMT_YUVA420P10LE = 89 % Int32
const AV_PIX_FMT_YUVA422P10BE = 90 % Int32
const AV_PIX_FMT_YUVA422P10LE = 91 % Int32
const AV_PIX_FMT_YUVA444P10BE = 92 % Int32
const AV_PIX_FMT_YUVA444P10LE = 93 % Int32
const AV_PIX_FMT_YUVA420P16BE = 94 % Int32
const AV_PIX_FMT_YUVA420P16LE = 95 % Int32
const AV_PIX_FMT_YUVA422P16BE = 96 % Int32
const AV_PIX_FMT_YUVA422P16LE = 97 % Int32
const AV_PIX_FMT_YUVA444P16BE = 98 % Int32
const AV_PIX_FMT_YUVA444P16LE = 99 % Int32
const AV_PIX_FMT_VDPAU = 100 % Int32
const AV_PIX_FMT_XYZ12LE = 101 % Int32
const AV_PIX_FMT_XYZ12BE = 102 % Int32
const AV_PIX_FMT_NV16 = 103 % Int32
const AV_PIX_FMT_NV20LE = 104 % Int32
const AV_PIX_FMT_NV20BE = 105 % Int32
const AV_PIX_FMT_RGBA64BE = 106 % Int32
const AV_PIX_FMT_RGBA64LE = 107 % Int32
const AV_PIX_FMT_BGRA64BE = 108 % Int32
const AV_PIX_FMT_BGRA64LE = 109 % Int32
const AV_PIX_FMT_YVYU422 = 110 % Int32
const AV_PIX_FMT_YA16BE = 111 % Int32
const AV_PIX_FMT_YA16LE = 112 % Int32
const AV_PIX_FMT_GBRAP = 113 % Int32
const AV_PIX_FMT_GBRAP16BE = 114 % Int32
const AV_PIX_FMT_GBRAP16LE = 115 % Int32
const AV_PIX_FMT_QSV = 116 % Int32
const AV_PIX_FMT_MMAL = 117 % Int32
const AV_PIX_FMT_D3D11VA_VLD = 118 % Int32
const AV_PIX_FMT_CUDA = 119 % Int32
const AV_PIX_FMT_0RGB = 120 % Int32
const AV_PIX_FMT_RGB0 = 121 % Int32
const AV_PIX_FMT_0BGR = 122 % Int32
const AV_PIX_FMT_BGR0 = 123 % Int32
const AV_PIX_FMT_YUV420P12BE = 124 % Int32
const AV_PIX_FMT_YUV420P12LE = 125 % Int32
const AV_PIX_FMT_YUV420P14BE = 126 % Int32
const AV_PIX_FMT_YUV420P14LE = 127 % Int32
const AV_PIX_FMT_YUV422P12BE = 128 % Int32
const AV_PIX_FMT_YUV422P12LE = 129 % Int32
const AV_PIX_FMT_YUV422P14BE = 130 % Int32
const AV_PIX_FMT_YUV422P14LE = 131 % Int32
const AV_PIX_FMT_YUV444P12BE = 132 % Int32
const AV_PIX_FMT_YUV444P12LE = 133 % Int32
const AV_PIX_FMT_YUV444P14BE = 134 % Int32
const AV_PIX_FMT_YUV444P14LE = 135 % Int32
const AV_PIX_FMT_GBRP12BE = 136 % Int32
const AV_PIX_FMT_GBRP12LE = 137 % Int32
const AV_PIX_FMT_GBRP14BE = 138 % Int32
const AV_PIX_FMT_GBRP14LE = 139 % Int32
const AV_PIX_FMT_YUVJ411P = 140 % Int32
const AV_PIX_FMT_BAYER_BGGR8 = 141 % Int32
const AV_PIX_FMT_BAYER_RGGB8 = 142 % Int32
const AV_PIX_FMT_BAYER_GBRG8 = 143 % Int32
const AV_PIX_FMT_BAYER_GRBG8 = 144 % Int32
const AV_PIX_FMT_BAYER_BGGR16LE = 145 % Int32
const AV_PIX_FMT_BAYER_BGGR16BE = 146 % Int32
const AV_PIX_FMT_BAYER_RGGB16LE = 147 % Int32
const AV_PIX_FMT_BAYER_RGGB16BE = 148 % Int32
const AV_PIX_FMT_BAYER_GBRG16LE = 149 % Int32
const AV_PIX_FMT_BAYER_GBRG16BE = 150 % Int32
const AV_PIX_FMT_BAYER_GRBG16LE = 151 % Int32
const AV_PIX_FMT_BAYER_GRBG16BE = 152 % Int32
const AV_PIX_FMT_XVMC = 153 % Int32
const AV_PIX_FMT_YUV440P10LE = 154 % Int32
const AV_PIX_FMT_YUV440P10BE = 155 % Int32
const AV_PIX_FMT_YUV440P12LE = 156 % Int32
const AV_PIX_FMT_YUV440P12BE = 157 % Int32
const AV_PIX_FMT_AYUV64LE = 158 % Int32
const AV_PIX_FMT_AYUV64BE = 159 % Int32
const AV_PIX_FMT_VIDEOTOOLBOX = 160 % Int32
const AV_PIX_FMT_P010LE = 161 % Int32
const AV_PIX_FMT_P010BE = 162 % Int32
const AV_PIX_FMT_GBRAP12BE = 163 % Int32
const AV_PIX_FMT_GBRAP12LE = 164 % Int32
const AV_PIX_FMT_GBRAP10BE = 165 % Int32
const AV_PIX_FMT_GBRAP10LE = 166 % Int32
const AV_PIX_FMT_MEDIACODEC = 167 % Int32
const AV_PIX_FMT_GRAY12BE = 168 % Int32
const AV_PIX_FMT_GRAY12LE = 169 % Int32
const AV_PIX_FMT_GRAY10BE = 170 % Int32
const AV_PIX_FMT_GRAY10LE = 171 % Int32
const AV_PIX_FMT_P016LE = 172 % Int32
const AV_PIX_FMT_P016BE = 173 % Int32
const AV_PIX_FMT_D3D11 = 174 % Int32
const AV_PIX_FMT_GRAY9BE = 175 % Int32
const AV_PIX_FMT_GRAY9LE = 176 % Int32
const AV_PIX_FMT_GBRPF32BE = 177 % Int32
const AV_PIX_FMT_GBRPF32LE = 178 % Int32
const AV_PIX_FMT_GBRAPF32BE = 179 % Int32
const AV_PIX_FMT_GBRAPF32LE = 180 % Int32
const AV_PIX_FMT_DRM_PRIME = 181 % Int32
const AV_PIX_FMT_OPENCL = 182 % Int32
const AV_PIX_FMT_GRAY14BE = 183 % Int32
const AV_PIX_FMT_GRAY14LE = 184 % Int32
const AV_PIX_FMT_GRAYF32BE = 185 % Int32
const AV_PIX_FMT_GRAYF32LE = 186 % Int32
const AV_PIX_FMT_YUVA422P12BE = 187 % Int32
const AV_PIX_FMT_YUVA422P12LE = 188 % Int32
const AV_PIX_FMT_YUVA444P12BE = 189 % Int32
const AV_PIX_FMT_YUVA444P12LE = 190 % Int32
const AV_PIX_FMT_NV24 = 191 % Int32
const AV_PIX_FMT_NV42 = 192 % Int32
const AV_PIX_FMT_VULKAN = 193 % Int32
const AV_PIX_FMT_Y210BE = 194 % Int32
const AV_PIX_FMT_Y210LE = 195 % Int32
const AV_PIX_FMT_X2RGB10LE = 196 % Int32
const AV_PIX_FMT_X2RGB10BE = 197 % Int32
const AV_PIX_FMT_NB = 198 % Int32

"""
    AVColorPrimaries

Chromaticity coordinates of the source primaries. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.1.
"""
const AVColorPrimaries = UInt32
const AVCOL_PRI_RESERVED0 = 0 % UInt32
const AVCOL_PRI_BT709 = 1 % UInt32
const AVCOL_PRI_UNSPECIFIED = 2 % UInt32
const AVCOL_PRI_RESERVED = 3 % UInt32
const AVCOL_PRI_BT470M = 4 % UInt32
const AVCOL_PRI_BT470BG = 5 % UInt32
const AVCOL_PRI_SMPTE170M = 6 % UInt32
const AVCOL_PRI_SMPTE240M = 7 % UInt32
const AVCOL_PRI_FILM = 8 % UInt32
const AVCOL_PRI_BT2020 = 9 % UInt32
const AVCOL_PRI_SMPTE428 = 10 % UInt32
const AVCOL_PRI_SMPTEST428_1 = 10 % UInt32
const AVCOL_PRI_SMPTE431 = 11 % UInt32
const AVCOL_PRI_SMPTE432 = 12 % UInt32
const AVCOL_PRI_EBU3213 = 22 % UInt32
const AVCOL_PRI_JEDEC_P22 = 22 % UInt32
const AVCOL_PRI_NB = 23 % UInt32

"""
    AVColorTransferCharacteristic

Color Transfer Characteristic. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.2.
"""
const AVColorTransferCharacteristic = UInt32
const AVCOL_TRC_RESERVED0 = 0 % UInt32
const AVCOL_TRC_BT709 = 1 % UInt32
const AVCOL_TRC_UNSPECIFIED = 2 % UInt32
const AVCOL_TRC_RESERVED = 3 % UInt32
const AVCOL_TRC_GAMMA22 = 4 % UInt32
const AVCOL_TRC_GAMMA28 = 5 % UInt32
const AVCOL_TRC_SMPTE170M = 6 % UInt32
const AVCOL_TRC_SMPTE240M = 7 % UInt32
const AVCOL_TRC_LINEAR = 8 % UInt32
const AVCOL_TRC_LOG = 9 % UInt32
const AVCOL_TRC_LOG_SQRT = 10 % UInt32
const AVCOL_TRC_IEC61966_2_4 = 11 % UInt32
const AVCOL_TRC_BT1361_ECG = 12 % UInt32
const AVCOL_TRC_IEC61966_2_1 = 13 % UInt32
const AVCOL_TRC_BT2020_10 = 14 % UInt32
const AVCOL_TRC_BT2020_12 = 15 % UInt32
const AVCOL_TRC_SMPTE2084 = 16 % UInt32
const AVCOL_TRC_SMPTEST2084 = 16 % UInt32
const AVCOL_TRC_SMPTE428 = 17 % UInt32
const AVCOL_TRC_SMPTEST428_1 = 17 % UInt32
const AVCOL_TRC_ARIB_STD_B67 = 18 % UInt32
const AVCOL_TRC_NB = 19 % UInt32

"""
    AVColorSpace

YUV colorspace type. These values match the ones defined by ISO/IEC 23001-8\\_2013 § 7.3.
"""
const AVColorSpace = UInt32
const AVCOL_SPC_RGB = 0 % UInt32
const AVCOL_SPC_BT709 = 1 % UInt32
const AVCOL_SPC_UNSPECIFIED = 2 % UInt32
const AVCOL_SPC_RESERVED = 3 % UInt32
const AVCOL_SPC_FCC = 4 % UInt32
const AVCOL_SPC_BT470BG = 5 % UInt32
const AVCOL_SPC_SMPTE170M = 6 % UInt32
const AVCOL_SPC_SMPTE240M = 7 % UInt32
const AVCOL_SPC_YCGCO = 8 % UInt32
const AVCOL_SPC_YCOCG = 8 % UInt32
const AVCOL_SPC_BT2020_NCL = 9 % UInt32
const AVCOL_SPC_BT2020_CL = 10 % UInt32
const AVCOL_SPC_SMPTE2085 = 11 % UInt32
const AVCOL_SPC_CHROMA_DERIVED_NCL = 12 % UInt32
const AVCOL_SPC_CHROMA_DERIVED_CL = 13 % UInt32
const AVCOL_SPC_ICTCP = 14 % UInt32
const AVCOL_SPC_NB = 15 % UInt32

"""
    AVColorRange

Visual content value range.

These values are based on definitions that can be found in multiple specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit integer representation). At the time of writing, the BT.2100 one is recommended, as it also defines the full range representation.

Common definitions: - For RGB and luminance planes such as Y in YCbCr and I in ICtCp, 'E' is the original value in range of 0.0 to 1.0. - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original value in range of -0.5 to 0.5. - 'n' is the output bit depth. - For additional definitions such as rounding and clipping to valid n bit unsigned integer range, please refer to BT.2100 (Table 9).
"""
const AVColorRange = UInt32
const AVCOL_RANGE_UNSPECIFIED = 0 % UInt32
const AVCOL_RANGE_MPEG = 1 % UInt32
const AVCOL_RANGE_JPEG = 2 % UInt32
const AVCOL_RANGE_NB = 3 % UInt32

"""
    AVChromaLocation

Location of chroma samples.

Illustration showing the location of the first (top left) chroma sample of the image, the left shows only luma, the right shows the location of the chroma sample, the 2 could be imagined to overlay each other but are drawn separately due to limitations of ASCII

1st 2nd 1st 2nd horizontal luma sample positions v v v v \\_\\_\\_\\_\\_\\_ \\_\\_\\_\\_\\_\\_1st luma line > |X X ... |3 4 X ... X are luma samples, | |1 2 1-6 are possible chroma positions2nd luma line > |X X ... |5 6 X ... 0 is undefined/unknown position
"""
const AVChromaLocation = UInt32
const AVCHROMA_LOC_UNSPECIFIED = 0 % UInt32
const AVCHROMA_LOC_LEFT = 1 % UInt32
const AVCHROMA_LOC_CENTER = 2 % UInt32
const AVCHROMA_LOC_TOPLEFT = 3 % UInt32
const AVCHROMA_LOC_TOP = 4 % UInt32
const AVCHROMA_LOC_BOTTOMLEFT = 5 % UInt32
const AVCHROMA_LOC_BOTTOM = 6 % UInt32
const AVCHROMA_LOC_NB = 7 % UInt32

"""
    AVFieldOrder

` lavc_core`
"""
const AVFieldOrder = UInt32
const AV_FIELD_UNKNOWN = 0 % UInt32
const AV_FIELD_PROGRESSIVE = 1 % UInt32
const AV_FIELD_TT = 2 % UInt32
const AV_FIELD_BB = 3 % UInt32
const AV_FIELD_TB = 4 % UInt32
const AV_FIELD_BT = 5 % UInt32

"""
    AVSampleFormat

Audio sample formats

- The data described by the sample format is always in native-endian order. Sample values can be expressed by native C types, hence the lack of a signed 24-bit sample format even though it is a common raw audio data format.

- The floating-point formats are based on full volume being in the range [-1.0, 1.0]. Any values outside this range are beyond full volume level.

- The data layout as used in [`av_samples_fill_arrays`](@ref)() and elsewhere in FFmpeg (such as [`AVFrame`](@ref) in libavcodec) is as follows:

\\par For planar sample formats, each audio channel is in a separate data plane, and linesize is the buffer size, in bytes, for a single plane. All data planes must be the same size. For packed sample formats, only the first data plane is used, and samples for each channel are interleaved. In this case, linesize is the buffer size, in bytes, for the 1 plane.
"""
const AVSampleFormat = Int32
const AV_SAMPLE_FMT_NONE = -1 % Int32
const AV_SAMPLE_FMT_U8 = 0 % Int32
const AV_SAMPLE_FMT_S16 = 1 % Int32
const AV_SAMPLE_FMT_S32 = 2 % Int32
const AV_SAMPLE_FMT_FLT = 3 % Int32
const AV_SAMPLE_FMT_DBL = 4 % Int32
const AV_SAMPLE_FMT_U8P = 5 % Int32
const AV_SAMPLE_FMT_S16P = 6 % Int32
const AV_SAMPLE_FMT_S32P = 7 % Int32
const AV_SAMPLE_FMT_FLTP = 8 % Int32
const AV_SAMPLE_FMT_DBLP = 9 % Int32
const AV_SAMPLE_FMT_S64 = 10 % Int32
const AV_SAMPLE_FMT_S64P = 11 % Int32
const AV_SAMPLE_FMT_NB = 12 % Int32

"""
    AVHWAccel

` lavc_hwaccel AVHWAccel`

!!! note

    Nothing in this structure should be accessed by the user. At some point in future it will not be externally visible at all.

@{
"""
struct AVHWAccel
    name::Cstring
    type::AVMediaType
    id::AVCodecID
    pix_fmt::AVPixelFormat
    capabilities::Cint
    alloc_frame::Ptr{Cvoid}
    start_frame::Ptr{Cvoid}
    decode_params::Ptr{Cvoid}
    decode_slice::Ptr{Cvoid}
    end_frame::Ptr{Cvoid}
    frame_priv_data_size::Cint
    decode_mb::Ptr{Cvoid}
    init::Ptr{Cvoid}
    uninit::Ptr{Cvoid}
    priv_data_size::Cint
    caps_internal::Cint
    frame_params::Ptr{Cvoid}
end

"""
    AVPictureType

@} @} 

` lavu_picture Image related`

[`AVPicture`](@ref) types, pixel formats and basic image planes manipulation.

@{
"""
const AVPictureType = UInt32
const AV_PICTURE_TYPE_NONE = 0 % UInt32
const AV_PICTURE_TYPE_I = 1 % UInt32
const AV_PICTURE_TYPE_P = 2 % UInt32
const AV_PICTURE_TYPE_B = 3 % UInt32
const AV_PICTURE_TYPE_S = 4 % UInt32
const AV_PICTURE_TYPE_SI = 5 % UInt32
const AV_PICTURE_TYPE_SP = 6 % UInt32
const AV_PICTURE_TYPE_BI = 7 % UInt32

mutable struct AVBuffer end

"""
    AVBufferRef

A reference to a data buffer.

The size of this struct is not a part of the public ABI and it is not meant to be allocated directly.
"""
struct AVBufferRef
    buffer::Ptr{AVBuffer}
    data::Ptr{UInt8}
    size::Cint
end

"""
    AVFrameSideDataType

` lavu_frame AVFrame`

` lavu_data`

@{ [`AVFrame`](@ref) is an abstraction for reference-counted raw multimedia data.
"""
const AVFrameSideDataType = UInt32
const AV_FRAME_DATA_PANSCAN = 0 % UInt32
const AV_FRAME_DATA_A53_CC = 1 % UInt32
const AV_FRAME_DATA_STEREO3D = 2 % UInt32
const AV_FRAME_DATA_MATRIXENCODING = 3 % UInt32
const AV_FRAME_DATA_DOWNMIX_INFO = 4 % UInt32
const AV_FRAME_DATA_REPLAYGAIN = 5 % UInt32
const AV_FRAME_DATA_DISPLAYMATRIX = 6 % UInt32
const AV_FRAME_DATA_AFD = 7 % UInt32
const AV_FRAME_DATA_MOTION_VECTORS = 8 % UInt32
const AV_FRAME_DATA_SKIP_SAMPLES = 9 % UInt32
const AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10 % UInt32
const AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11 % UInt32
const AV_FRAME_DATA_GOP_TIMECODE = 12 % UInt32
const AV_FRAME_DATA_SPHERICAL = 13 % UInt32
const AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14 % UInt32
const AV_FRAME_DATA_ICC_PROFILE = 15 % UInt32
const AV_FRAME_DATA_QP_TABLE_PROPERTIES = 16 % UInt32
const AV_FRAME_DATA_QP_TABLE_DATA = 17 % UInt32
const AV_FRAME_DATA_S12M_TIMECODE = 18 % UInt32
const AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 19 % UInt32
const AV_FRAME_DATA_REGIONS_OF_INTEREST = 20 % UInt32
const AV_FRAME_DATA_VIDEO_ENC_PARAMS = 21 % UInt32
const AV_FRAME_DATA_SEI_UNREGISTERED = 22 % UInt32
const AV_FRAME_DATA_FILM_GRAIN_PARAMS = 23 % UInt32

mutable struct AVDictionary end

"""
    AVFrameSideData

Structure to hold side data for an [`AVFrame`](@ref).

sizeof([`AVFrameSideData`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.
"""
struct AVFrameSideData
    type::AVFrameSideDataType
    data::Ptr{UInt8}
    size::Cint
    metadata::Ptr{AVDictionary}
    buf::Ptr{AVBufferRef}
end

"""
    AVFrame

This structure describes decoded (raw) audio or video data.

[`AVFrame`](@ref) must be allocated using [`av_frame_alloc`](@ref)(). Note that this only allocates the [`AVFrame`](@ref) itself, the buffers for the data must be managed through other means (see below). [`AVFrame`](@ref) must be freed with [`av_frame_free`](@ref)().

[`AVFrame`](@ref) is typically allocated once and then reused multiple times to hold different data (e.g. a single [`AVFrame`](@ref) to hold frames received from a decoder). In such a case, [`av_frame_unref`](@ref)() will free any references held by the frame and reset it to its original clean state before it is reused again.

The data described by an [`AVFrame`](@ref) is usually reference counted through the [`AVBuffer`](@ref) API. The underlying buffer references are stored in [`AVFrame`](@ref).buf / [`AVFrame`](@ref).extended\\_buf. An [`AVFrame`](@ref) is considered to be reference counted if at least one reference is set, i.e. if [`AVFrame`](@ref).buf[0] != NULL. In such a case, every single data plane must be contained in one of the buffers in [`AVFrame`](@ref).buf or [`AVFrame`](@ref).extended\\_buf. There may be a single buffer for all the data, or one separate buffer for each plane, or anything in between.

sizeof([`AVFrame`](@ref)) is not a part of the public ABI, so new fields may be added to the end with a minor bump.

Fields can be accessed through AVOptions, the name string used, matches the C structure field name for fields accessible through AVOptions. The [`AVClass`](@ref) for [`AVFrame`](@ref) can be obtained from [`avcodec_get_frame_class`](@ref)()
"""
struct AVFrame
    data::NTuple{536, UInt8}
end

function Base.getproperty(x::Ptr{AVFrame}, f::Symbol)
    f === :data && return Ptr{NTuple{8, Ptr{UInt8}}}(x + 0)
    f === :linesize && return Ptr{NTuple{8, Cint}}(x + 64)
    f === :extended_data && return Ptr{Ptr{Ptr{UInt8}}}(x + 96)
    f === :width && return Ptr{Cint}(x + 104)
    f === :height && return Ptr{Cint}(x + 108)
    f === :nb_samples && return Ptr{Cint}(x + 112)
    f === :format && return Ptr{Cint}(x + 116)
    f === :key_frame && return Ptr{Cint}(x + 120)
    f === :pict_type && return Ptr{AVPictureType}(x + 124)
    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 128)
    f === :pts && return Ptr{Int64}(x + 136)
    f === :pkt_pts && return Ptr{Int64}(x + 144)
    f === :pkt_dts && return Ptr{Int64}(x + 152)
    f === :coded_picture_number && return Ptr{Cint}(x + 160)
    f === :display_picture_number && return Ptr{Cint}(x + 164)
    f === :quality && return Ptr{Cint}(x + 168)
    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 176)
    f === :error && return Ptr{NTuple{8, UInt64}}(x + 184)
    f === :repeat_pict && return Ptr{Cint}(x + 248)
    f === :interlaced_frame && return Ptr{Cint}(x + 252)
    f === :top_field_first && return Ptr{Cint}(x + 256)
    f === :palette_has_changed && return Ptr{Cint}(x + 260)
    f === :reordered_opaque && return Ptr{Int64}(x + 264)
    f === :sample_rate && return Ptr{Cint}(x + 272)
    f === :channel_layout && return Ptr{UInt64}(x + 280)
    f === :buf && return Ptr{NTuple{8, Ptr{AVBufferRef}}}(x + 288)
    f === :extended_buf && return Ptr{Ptr{Ptr{AVBufferRef}}}(x + 352)
    f === :nb_extended_buf && return Ptr{Cint}(x + 360)
    f === :side_data && return Ptr{Ptr{Ptr{AVFrameSideData}}}(x + 368)
    f === :nb_side_data && return Ptr{Cint}(x + 376)
    f === :flags && return Ptr{Cint}(x + 380)
    f === :color_range && return Ptr{AVColorRange}(x + 384)
    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 388)
    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 392)
    f === :colorspace && return Ptr{AVColorSpace}(x + 396)
    f === :chroma_location && return Ptr{AVChromaLocation}(x + 400)
    f === :best_effort_timestamp && return Ptr{Int64}(x + 408)
    f === :pkt_pos && return Ptr{Int64}(x + 416)
    f === :pkt_duration && return Ptr{Int64}(x + 424)
    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 432)
    f === :decode_error_flags && return Ptr{Cint}(x + 440)
    f === :channels && return Ptr{Cint}(x + 444)
    f === :pkt_size && return Ptr{Cint}(x + 448)
    f === :qscale_table && return Ptr{Ptr{Int8}}(x + 456)
    f === :qstride && return Ptr{Cint}(x + 464)
    f === :qscale_type && return Ptr{Cint}(x + 468)
    f === :qp_table_buf && return Ptr{Ptr{AVBufferRef}}(x + 472)
    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 480)
    f === :opaque_ref && return Ptr{Ptr{AVBufferRef}}(x + 488)
    f === :crop_top && return Ptr{Csize_t}(x + 496)
    f === :crop_bottom && return Ptr{Csize_t}(x + 504)
    f === :crop_left && return Ptr{Csize_t}(x + 512)
    f === :crop_right && return Ptr{Csize_t}(x + 520)
    f === :private_ref && return Ptr{Ptr{AVBufferRef}}(x + 528)
    return getfield(x, f)
end

function Base.getproperty(x::AVFrame, f::Symbol)
    r = Ref{AVFrame}(x)
    ptr = Base.unsafe_convert(Ptr{AVFrame}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVFrame}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVProfile

[`AVProfile`](@ref).
"""
struct AVProfile
    profile::Cint
    name::Cstring
end

"""
    AVCodecDescriptor

This struct describes the properties of a single codec described by an [`AVCodecID`](@ref). 

### See also
[`avcodec_descriptor_get`](@ref)()
"""
struct AVCodecDescriptor
    id::AVCodecID
    type::AVMediaType
    name::Cstring
    long_name::Cstring
    props::Cint
    mime_types::Ptr{Cstring}
    profiles::Ptr{AVProfile}
end

"""
    AVPacketSideDataType

` lavc_packet AVPacket`

Types and functions for working with [`AVPacket`](@ref). @{
"""
const AVPacketSideDataType = UInt32
const AV_PKT_DATA_PALETTE = 0 % UInt32
const AV_PKT_DATA_NEW_EXTRADATA = 1 % UInt32
const AV_PKT_DATA_PARAM_CHANGE = 2 % UInt32
const AV_PKT_DATA_H263_MB_INFO = 3 % UInt32
const AV_PKT_DATA_REPLAYGAIN = 4 % UInt32
const AV_PKT_DATA_DISPLAYMATRIX = 5 % UInt32
const AV_PKT_DATA_STEREO3D = 6 % UInt32
const AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7 % UInt32
const AV_PKT_DATA_QUALITY_STATS = 8 % UInt32
const AV_PKT_DATA_FALLBACK_TRACK = 9 % UInt32
const AV_PKT_DATA_CPB_PROPERTIES = 10 % UInt32
const AV_PKT_DATA_SKIP_SAMPLES = 11 % UInt32
const AV_PKT_DATA_JP_DUALMONO = 12 % UInt32
const AV_PKT_DATA_STRINGS_METADATA = 13 % UInt32
const AV_PKT_DATA_SUBTITLE_POSITION = 14 % UInt32
const AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15 % UInt32
const AV_PKT_DATA_WEBVTT_IDENTIFIER = 16 % UInt32
const AV_PKT_DATA_WEBVTT_SETTINGS = 17 % UInt32
const AV_PKT_DATA_METADATA_UPDATE = 18 % UInt32
const AV_PKT_DATA_MPEGTS_STREAM_ID = 19 % UInt32
const AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20 % UInt32
const AV_PKT_DATA_SPHERICAL = 21 % UInt32
const AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22 % UInt32
const AV_PKT_DATA_A53_CC = 23 % UInt32
const AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24 % UInt32
const AV_PKT_DATA_ENCRYPTION_INFO = 25 % UInt32
const AV_PKT_DATA_AFD = 26 % UInt32
const AV_PKT_DATA_PRFT = 27 % UInt32
const AV_PKT_DATA_ICC_PROFILE = 28 % UInt32
const AV_PKT_DATA_DOVI_CONF = 29 % UInt32
const AV_PKT_DATA_S12M_TIMECODE = 30 % UInt32
const AV_PKT_DATA_NB = 31 % UInt32

struct AVPacketSideData
    data::Ptr{UInt8}
    size::Cint
    type::AVPacketSideDataType
end

"""
    AVCodecContext

main external API structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. You can use AVOptions (av\\_opt* / av\\_set/get*()) to access these fields from user applications. The name string for AVOptions options matches the associated command line parameter name and can be found in libavcodec/options\\_table.h The [`AVOption`](@ref)/command line parameter names differ in some cases from the C structure field names for historic reasons or brevity. sizeof([`AVCodecContext`](@ref)) must not be used outside libav*.
"""
struct AVCodecContext
    data::NTuple{1080, UInt8}
end

function Base.getproperty(x::Ptr{AVCodecContext}, f::Symbol)
    f === :av_class && return Ptr{Ptr{AVClass}}(x + 0)
    f === :log_level_offset && return Ptr{Cint}(x + 8)
    f === :codec_type && return Ptr{AVMediaType}(x + 12)
    f === :codec && return Ptr{Ptr{AVCodec}}(x + 16)
    f === :codec_id && return Ptr{AVCodecID}(x + 24)
    f === :codec_tag && return Ptr{Cuint}(x + 28)
    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 32)
    f === :internal && return Ptr{Ptr{AVCodecInternal}}(x + 40)
    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 48)
    f === :bit_rate && return Ptr{Int64}(x + 56)
    f === :bit_rate_tolerance && return Ptr{Cint}(x + 64)
    f === :global_quality && return Ptr{Cint}(x + 68)
    f === :compression_level && return Ptr{Cint}(x + 72)
    f === :flags && return Ptr{Cint}(x + 76)
    f === :flags2 && return Ptr{Cint}(x + 80)
    f === :extradata && return Ptr{Ptr{UInt8}}(x + 88)
    f === :extradata_size && return Ptr{Cint}(x + 96)
    f === :time_base && return Ptr{AVRational}(x + 100)
    f === :ticks_per_frame && return Ptr{Cint}(x + 108)
    f === :delay && return Ptr{Cint}(x + 112)
    f === :width && return Ptr{Cint}(x + 116)
    f === :height && return Ptr{Cint}(x + 120)
    f === :coded_width && return Ptr{Cint}(x + 124)
    f === :coded_height && return Ptr{Cint}(x + 128)
    f === :gop_size && return Ptr{Cint}(x + 132)
    f === :pix_fmt && return Ptr{AVPixelFormat}(x + 136)
    f === :draw_horiz_band && return Ptr{Ptr{Cvoid}}(x + 144)
    f === :get_format && return Ptr{Ptr{Cvoid}}(x + 152)
    f === :max_b_frames && return Ptr{Cint}(x + 160)
    f === :b_quant_factor && return Ptr{Cfloat}(x + 164)
    f === :b_frame_strategy && return Ptr{Cint}(x + 168)
    f === :b_quant_offset && return Ptr{Cfloat}(x + 172)
    f === :has_b_frames && return Ptr{Cint}(x + 176)
    f === :mpeg_quant && return Ptr{Cint}(x + 180)
    f === :i_quant_factor && return Ptr{Cfloat}(x + 184)
    f === :i_quant_offset && return Ptr{Cfloat}(x + 188)
    f === :lumi_masking && return Ptr{Cfloat}(x + 192)
    f === :temporal_cplx_masking && return Ptr{Cfloat}(x + 196)
    f === :spatial_cplx_masking && return Ptr{Cfloat}(x + 200)
    f === :p_masking && return Ptr{Cfloat}(x + 204)
    f === :dark_masking && return Ptr{Cfloat}(x + 208)
    f === :slice_count && return Ptr{Cint}(x + 212)
    f === :prediction_method && return Ptr{Cint}(x + 216)
    f === :slice_offset && return Ptr{Ptr{Cint}}(x + 224)
    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 232)
    f === :me_cmp && return Ptr{Cint}(x + 240)
    f === :me_sub_cmp && return Ptr{Cint}(x + 244)
    f === :mb_cmp && return Ptr{Cint}(x + 248)
    f === :ildct_cmp && return Ptr{Cint}(x + 252)
    f === :dia_size && return Ptr{Cint}(x + 256)
    f === :last_predictor_count && return Ptr{Cint}(x + 260)
    f === :pre_me && return Ptr{Cint}(x + 264)
    f === :me_pre_cmp && return Ptr{Cint}(x + 268)
    f === :pre_dia_size && return Ptr{Cint}(x + 272)
    f === :me_subpel_quality && return Ptr{Cint}(x + 276)
    f === :me_range && return Ptr{Cint}(x + 280)
    f === :slice_flags && return Ptr{Cint}(x + 284)
    f === :mb_decision && return Ptr{Cint}(x + 288)
    f === :intra_matrix && return Ptr{Ptr{UInt16}}(x + 296)
    f === :inter_matrix && return Ptr{Ptr{UInt16}}(x + 304)
    f === :scenechange_threshold && return Ptr{Cint}(x + 312)
    f === :noise_reduction && return Ptr{Cint}(x + 316)
    f === :intra_dc_precision && return Ptr{Cint}(x + 320)
    f === :skip_top && return Ptr{Cint}(x + 324)
    f === :skip_bottom && return Ptr{Cint}(x + 328)
    f === :mb_lmin && return Ptr{Cint}(x + 332)
    f === :mb_lmax && return Ptr{Cint}(x + 336)
    f === :me_penalty_compensation && return Ptr{Cint}(x + 340)
    f === :bidir_refine && return Ptr{Cint}(x + 344)
    f === :brd_scale && return Ptr{Cint}(x + 348)
    f === :keyint_min && return Ptr{Cint}(x + 352)
    f === :refs && return Ptr{Cint}(x + 356)
    f === :chromaoffset && return Ptr{Cint}(x + 360)
    f === :mv0_threshold && return Ptr{Cint}(x + 364)
    f === :b_sensitivity && return Ptr{Cint}(x + 368)
    f === :color_primaries && return Ptr{AVColorPrimaries}(x + 372)
    f === :color_trc && return Ptr{AVColorTransferCharacteristic}(x + 376)
    f === :colorspace && return Ptr{AVColorSpace}(x + 380)
    f === :color_range && return Ptr{AVColorRange}(x + 384)
    f === :chroma_sample_location && return Ptr{AVChromaLocation}(x + 388)
    f === :slices && return Ptr{Cint}(x + 392)
    f === :field_order && return Ptr{AVFieldOrder}(x + 396)
    f === :sample_rate && return Ptr{Cint}(x + 400)
    f === :channels && return Ptr{Cint}(x + 404)
    f === :sample_fmt && return Ptr{AVSampleFormat}(x + 408)
    f === :frame_size && return Ptr{Cint}(x + 412)
    f === :frame_number && return Ptr{Cint}(x + 416)
    f === :block_align && return Ptr{Cint}(x + 420)
    f === :cutoff && return Ptr{Cint}(x + 424)
    f === :channel_layout && return Ptr{UInt64}(x + 432)
    f === :request_channel_layout && return Ptr{UInt64}(x + 440)
    f === :audio_service_type && return Ptr{AVAudioServiceType}(x + 448)
    f === :request_sample_fmt && return Ptr{AVSampleFormat}(x + 452)
    f === :get_buffer2 && return Ptr{Ptr{Cvoid}}(x + 456)
    f === :refcounted_frames && return Ptr{Cint}(x + 464)
    f === :qcompress && return Ptr{Cfloat}(x + 468)
    f === :qblur && return Ptr{Cfloat}(x + 472)
    f === :qmin && return Ptr{Cint}(x + 476)
    f === :qmax && return Ptr{Cint}(x + 480)
    f === :max_qdiff && return Ptr{Cint}(x + 484)
    f === :rc_buffer_size && return Ptr{Cint}(x + 488)
    f === :rc_override_count && return Ptr{Cint}(x + 492)
    f === :rc_override && return Ptr{Ptr{RcOverride}}(x + 496)
    f === :rc_max_rate && return Ptr{Int64}(x + 504)
    f === :rc_min_rate && return Ptr{Int64}(x + 512)
    f === :rc_max_available_vbv_use && return Ptr{Cfloat}(x + 520)
    f === :rc_min_vbv_overflow_use && return Ptr{Cfloat}(x + 524)
    f === :rc_initial_buffer_occupancy && return Ptr{Cint}(x + 528)
    f === :coder_type && return Ptr{Cint}(x + 532)
    f === :context_model && return Ptr{Cint}(x + 536)
    f === :frame_skip_threshold && return Ptr{Cint}(x + 540)
    f === :frame_skip_factor && return Ptr{Cint}(x + 544)
    f === :frame_skip_exp && return Ptr{Cint}(x + 548)
    f === :frame_skip_cmp && return Ptr{Cint}(x + 552)
    f === :trellis && return Ptr{Cint}(x + 556)
    f === :min_prediction_order && return Ptr{Cint}(x + 560)
    f === :max_prediction_order && return Ptr{Cint}(x + 564)
    f === :timecode_frame_start && return Ptr{Int64}(x + 568)
    f === :rtp_callback && return Ptr{Ptr{Cvoid}}(x + 576)
    f === :rtp_payload_size && return Ptr{Cint}(x + 584)
    f === :mv_bits && return Ptr{Cint}(x + 588)
    f === :header_bits && return Ptr{Cint}(x + 592)
    f === :i_tex_bits && return Ptr{Cint}(x + 596)
    f === :p_tex_bits && return Ptr{Cint}(x + 600)
    f === :i_count && return Ptr{Cint}(x + 604)
    f === :p_count && return Ptr{Cint}(x + 608)
    f === :skip_count && return Ptr{Cint}(x + 612)
    f === :misc_bits && return Ptr{Cint}(x + 616)
    f === :frame_bits && return Ptr{Cint}(x + 620)
    f === :stats_out && return Ptr{Cstring}(x + 624)
    f === :stats_in && return Ptr{Cstring}(x + 632)
    f === :workaround_bugs && return Ptr{Cint}(x + 640)
    f === :strict_std_compliance && return Ptr{Cint}(x + 644)
    f === :error_concealment && return Ptr{Cint}(x + 648)
    f === :debug && return Ptr{Cint}(x + 652)
    f === :err_recognition && return Ptr{Cint}(x + 656)
    f === :reordered_opaque && return Ptr{Int64}(x + 664)
    f === :hwaccel && return Ptr{Ptr{AVHWAccel}}(x + 672)
    f === :hwaccel_context && return Ptr{Ptr{Cvoid}}(x + 680)
    f === :error && return Ptr{NTuple{8, UInt64}}(x + 688)
    f === :dct_algo && return Ptr{Cint}(x + 752)
    f === :idct_algo && return Ptr{Cint}(x + 756)
    f === :bits_per_coded_sample && return Ptr{Cint}(x + 760)
    f === :bits_per_raw_sample && return Ptr{Cint}(x + 764)
    f === :lowres && return Ptr{Cint}(x + 768)
    f === :coded_frame && return Ptr{Ptr{AVFrame}}(x + 776)
    f === :thread_count && return Ptr{Cint}(x + 784)
    f === :thread_type && return Ptr{Cint}(x + 788)
    f === :active_thread_type && return Ptr{Cint}(x + 792)
    f === :thread_safe_callbacks && return Ptr{Cint}(x + 796)
    f === :execute && return Ptr{Ptr{Cvoid}}(x + 800)
    f === :execute2 && return Ptr{Ptr{Cvoid}}(x + 808)
    f === :nsse_weight && return Ptr{Cint}(x + 816)
    f === :profile && return Ptr{Cint}(x + 820)
    f === :level && return Ptr{Cint}(x + 824)
    f === :skip_loop_filter && return Ptr{AVDiscard}(x + 828)
    f === :skip_idct && return Ptr{AVDiscard}(x + 832)
    f === :skip_frame && return Ptr{AVDiscard}(x + 836)
    f === :subtitle_header && return Ptr{Ptr{UInt8}}(x + 840)
    f === :subtitle_header_size && return Ptr{Cint}(x + 848)
    f === :vbv_delay && return Ptr{UInt64}(x + 856)
    f === :side_data_only_packets && return Ptr{Cint}(x + 864)
    f === :initial_padding && return Ptr{Cint}(x + 868)
    f === :framerate && return Ptr{AVRational}(x + 872)
    f === :sw_pix_fmt && return Ptr{AVPixelFormat}(x + 880)
    f === :pkt_timebase && return Ptr{AVRational}(x + 884)
    f === :codec_descriptor && return Ptr{Ptr{AVCodecDescriptor}}(x + 896)
    f === :pts_correction_num_faulty_pts && return Ptr{Int64}(x + 904)
    f === :pts_correction_num_faulty_dts && return Ptr{Int64}(x + 912)
    f === :pts_correction_last_pts && return Ptr{Int64}(x + 920)
    f === :pts_correction_last_dts && return Ptr{Int64}(x + 928)
    f === :sub_charenc && return Ptr{Cstring}(x + 936)
    f === :sub_charenc_mode && return Ptr{Cint}(x + 944)
    f === :skip_alpha && return Ptr{Cint}(x + 948)
    f === :seek_preroll && return Ptr{Cint}(x + 952)
    f === :debug_mv && return Ptr{Cint}(x + 956)
    f === :chroma_intra_matrix && return Ptr{Ptr{UInt16}}(x + 960)
    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 968)
    f === :codec_whitelist && return Ptr{Cstring}(x + 976)
    f === :properties && return Ptr{Cuint}(x + 984)
    f === :coded_side_data && return Ptr{Ptr{AVPacketSideData}}(x + 992)
    f === :nb_coded_side_data && return Ptr{Cint}(x + 1000)
    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 1008)
    f === :sub_text_format && return Ptr{Cint}(x + 1016)
    f === :trailing_padding && return Ptr{Cint}(x + 1020)
    f === :max_pixels && return Ptr{Int64}(x + 1024)
    f === :hw_device_ctx && return Ptr{Ptr{AVBufferRef}}(x + 1032)
    f === :hwaccel_flags && return Ptr{Cint}(x + 1040)
    f === :apply_cropping && return Ptr{Cint}(x + 1044)
    f === :extra_hw_frames && return Ptr{Cint}(x + 1048)
    f === :discard_damaged_percentage && return Ptr{Cint}(x + 1052)
    f === :max_samples && return Ptr{Int64}(x + 1056)
    f === :export_side_data && return Ptr{Cint}(x + 1064)
    f === :get_encode_buffer && return Ptr{Ptr{Cvoid}}(x + 1072)
    return getfield(x, f)
end

function Base.getproperty(x::AVCodecContext, f::Symbol)
    r = Ref{AVCodecContext}(x)
    ptr = Base.unsafe_convert(Ptr{AVCodecContext}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVCodecContext}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    av_codec_get_pkt_timebase(avctx)

Accessors for some [`AVCodecContext`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
"""
function av_codec_get_pkt_timebase(avctx)
    ccall((:av_codec_get_pkt_timebase, libavcodec), AVRational, (Ptr{AVCodecContext},), avctx)
end

function av_codec_set_pkt_timebase(avctx, val::AVRational)
    ccall((:av_codec_set_pkt_timebase, libavcodec), Cvoid, (Ptr{AVCodecContext}, AVRational), avctx, val)
end

function av_codec_get_codec_descriptor(avctx)
    ccall((:av_codec_get_codec_descriptor, libavcodec), Ptr{AVCodecDescriptor}, (Ptr{AVCodecContext},), avctx)
end

function av_codec_set_codec_descriptor(avctx, desc)
    ccall((:av_codec_set_codec_descriptor, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{AVCodecDescriptor}), avctx, desc)
end

function av_codec_get_codec_properties(avctx)
    ccall((:av_codec_get_codec_properties, libavcodec), Cuint, (Ptr{AVCodecContext},), avctx)
end

function av_codec_get_lowres(avctx)
    ccall((:av_codec_get_lowres, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
end

function av_codec_set_lowres(avctx, val::Integer)
    ccall((:av_codec_set_lowres, libavcodec), Cvoid, (Ptr{AVCodecContext}, Cint), avctx, val)
end

function av_codec_get_seek_preroll(avctx)
    ccall((:av_codec_get_seek_preroll, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
end

function av_codec_set_seek_preroll(avctx, val::Integer)
    ccall((:av_codec_set_seek_preroll, libavcodec), Cvoid, (Ptr{AVCodecContext}, Cint), avctx, val)
end

function av_codec_get_chroma_intra_matrix(avctx)
    ccall((:av_codec_get_chroma_intra_matrix, libavcodec), Ptr{UInt16}, (Ptr{AVCodecContext},), avctx)
end

function av_codec_set_chroma_intra_matrix(avctx, val)
    ccall((:av_codec_set_chroma_intra_matrix, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{UInt16}), avctx, val)
end

mutable struct AVCodecDefault end

mutable struct AVCodecHWConfigInternal end

"""
    AVCodec

[`AVCodec`](@ref).
"""
struct AVCodec
    name::Cstring
    long_name::Cstring
    type::AVMediaType
    id::AVCodecID
    capabilities::Cint
    supported_framerates::Ptr{AVRational}
    pix_fmts::Ptr{AVPixelFormat}
    supported_samplerates::Ptr{Cint}
    sample_fmts::Ptr{AVSampleFormat}
    channel_layouts::Ptr{Cvoid} # channel_layouts::Ptr{UInt64}
    max_lowres::UInt8
    priv_class::Ptr{AVClass}
    profiles::Ptr{AVProfile}
    wrapper_name::Cstring
    priv_data_size::Cint
    next::Ptr{AVCodec}
    update_thread_context::Ptr{Cvoid}
    defaults::Ptr{AVCodecDefault}
    init_static_data::Ptr{Cvoid}
    init::Ptr{Cvoid}
    encode_sub::Ptr{Cvoid}
    encode2::Ptr{Cvoid}
    decode::Ptr{Cvoid}
    close::Ptr{Cvoid}
    receive_packet::Ptr{Cvoid}
    receive_frame::Ptr{Cvoid}
    flush::Ptr{Cvoid}
    caps_internal::Cint
    bsfs::Cstring
    hw_configs::Ptr{Ptr{AVCodecHWConfigInternal}}
    codec_tags::Ptr{Cvoid} # codec_tags::Ptr{UInt32}
end

function Base.getproperty(x::AVCodec, f::Symbol)
    f === :channel_layouts && return Ptr{UInt64}(getfield(x, f))
    f === :codec_tags && return Ptr{UInt32}(getfield(x, f))
    return getfield(x, f)
end

function av_codec_get_max_lowres(codec)
    ccall((:av_codec_get_max_lowres, libavcodec), Cint, (Ptr{AVCodec},), codec)
end

mutable struct MpegEncContext end

"""
    AVPicture

[`Picture`](@ref) data structure.

Up to four components can be stored into it, the last component is alpha. 

\\deprecated use [`AVFrame`](@ref) or imgutils functions instead
"""
struct AVPicture
    data::NTuple{96, UInt8}
end

function Base.getproperty(x::Ptr{AVPicture}, f::Symbol)
    f === :data && return Ptr{NTuple{8, Ptr{UInt8}}}(x + 0)
    f === :linesize && return Ptr{NTuple{8, Cint}}(x + 64)
    return getfield(x, f)
end

function Base.getproperty(x::AVPicture, f::Symbol)
    r = Ref{AVPicture}(x)
    ptr = Base.unsafe_convert(Ptr{AVPicture}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVPicture}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

const AVSubtitleType = UInt32
const SUBTITLE_NONE = 0 % UInt32
const SUBTITLE_BITMAP = 1 % UInt32
const SUBTITLE_TEXT = 2 % UInt32
const SUBTITLE_ASS = 3 % UInt32

struct AVSubtitleRect
    data::NTuple{200, UInt8}
end

function Base.getproperty(x::Ptr{AVSubtitleRect}, f::Symbol)
    f === :x && return Ptr{Cint}(x + 0)
    f === :y && return Ptr{Cint}(x + 4)
    f === :w && return Ptr{Cint}(x + 8)
    f === :h && return Ptr{Cint}(x + 12)
    f === :nb_colors && return Ptr{Cint}(x + 16)
    f === :pict && return Ptr{AVPicture}(x + 24)
    f === :data && return Ptr{NTuple{4, Ptr{UInt8}}}(x + 120)
    f === :linesize && return Ptr{NTuple{4, Cint}}(x + 152)
    f === :type && return Ptr{AVSubtitleType}(x + 168)
    f === :text && return Ptr{Cstring}(x + 176)
    f === :ass && return Ptr{Cstring}(x + 184)
    f === :flags && return Ptr{Cint}(x + 192)
    return getfield(x, f)
end

function Base.getproperty(x::AVSubtitleRect, f::Symbol)
    r = Ref{AVSubtitleRect}(x)
    ptr = Base.unsafe_convert(Ptr{AVSubtitleRect}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVSubtitleRect}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct AVSubtitle
    format::UInt16
    start_display_time::UInt32
    end_display_time::UInt32
    num_rects::Cuint
    rects::Ptr{Ptr{AVSubtitleRect}}
    pts::Int64
end

"""
    av_codec_next(c)

If c is NULL, returns the first registered codec, if c is non-NULL, returns the next registered codec after c, or NULL if c is the last one.
"""
function av_codec_next(c)
    ccall((:av_codec_next, libavcodec), Ptr{AVCodec}, (Ptr{AVCodec},), c)
end

"""
    avcodec_version()

Return the [`LIBAVCODEC_VERSION_INT`](@ref) constant.
"""
function avcodec_version()
    ccall((:avcodec_version, libavcodec), Cuint, ())
end

"""
    avcodec_configuration()

Return the libavcodec build-time configuration.
"""
function avcodec_configuration()
    ccall((:avcodec_configuration, libavcodec), Cstring, ())
end

"""
    avcodec_license()

Return the libavcodec license.
"""
function avcodec_license()
    ccall((:avcodec_license, libavcodec), Cstring, ())
end

"""
    avcodec_register(codec)

\\deprecated Calling this function is unnecessary.
"""
function avcodec_register(codec)
    ccall((:avcodec_register, libavcodec), Cvoid, (Ptr{AVCodec},), codec)
end

"""
    avcodec_register_all()

\\deprecated Calling this function is unnecessary.
"""
function avcodec_register_all()
    ccall((:avcodec_register_all, libavcodec), Cvoid, ())
end

"""
    avcodec_alloc_context3(codec)

Allocate an [`AVCodecContext`](@ref) and set its fields to default values. The resulting struct should be freed with [`avcodec_free_context`](@ref)().

### Parameters
* `codec`: if non-NULL, allocate private data and initialize defaults for the given codec. It is illegal to then call [`avcodec_open2`](@ref)() with a different codec. If NULL, then the codec-specific defaults won't be initialized, which may result in suboptimal default settings (this is important mainly for encoders, e.g. libx264).

### Returns
An [`AVCodecContext`](@ref) filled with default values or NULL on failure.
"""
function avcodec_alloc_context3(codec)
    ccall((:avcodec_alloc_context3, libavcodec), Ptr{AVCodecContext}, (Ptr{AVCodec},), codec)
end

"""
    avcodec_free_context(avctx)

Free the codec context and everything associated with it and write NULL to the provided pointer.
"""
function avcodec_free_context(avctx)
    ccall((:avcodec_free_context, libavcodec), Cvoid, (Ptr{Ptr{AVCodecContext}},), avctx)
end

"""
    avcodec_get_context_defaults3(s, codec)

\\deprecated This function should not be used, as closing and opening a codec context multiple time is not supported. A new codec context should be allocated for each new use.
"""
function avcodec_get_context_defaults3(s, codec)
    ccall((:avcodec_get_context_defaults3, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodec}), s, codec)
end

"""
    avcodec_get_class()

Get the [`AVClass`](@ref) for [`AVCodecContext`](@ref). It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.

### See also
[`av_opt_find`](@ref)().
"""
function avcodec_get_class()
    ccall((:avcodec_get_class, libavcodec), Ptr{AVClass}, ())
end

"""
    avcodec_get_frame_class()

\\deprecated This function should not be used.
"""
function avcodec_get_frame_class()
    ccall((:avcodec_get_frame_class, libavcodec), Ptr{AVClass}, ())
end

"""
    avcodec_get_subtitle_rect_class()

Get the [`AVClass`](@ref) for [`AVSubtitleRect`](@ref). It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.

### See also
[`av_opt_find`](@ref)().
"""
function avcodec_get_subtitle_rect_class()
    ccall((:avcodec_get_subtitle_rect_class, libavcodec), Ptr{AVClass}, ())
end

"""
    avcodec_copy_context(dest, src)

Copy the settings of the source [`AVCodecContext`](@ref) into the destination [`AVCodecContext`](@ref). The resulting destination codec context will be unopened, i.e. you are required to call [`avcodec_open2`](@ref)() before you can use this [`AVCodecContext`](@ref) to decode/encode video/audio data.

\\deprecated The semantics of this function are ill-defined and it should not be used. If you need to transfer the stream parameters from one codec context to another, use an intermediate [`AVCodecParameters`](@ref) instance and the [`avcodec_parameters_from_context`](@ref)() / [`avcodec_parameters_to_context`](@ref)() functions.

### Parameters
* `dest`: target codec context, should be initialized with [`avcodec_alloc_context3`](@ref)(NULL), but otherwise uninitialized 

* `src`: source codec context 

### Returns
[`AVERROR`](@ref)() on error (e.g. memory allocation error), 0 on success
"""
function avcodec_copy_context(dest, src)
    ccall((:avcodec_copy_context, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodecContext}), dest, src)
end

"""
    AVCodecParameters

This struct describes the properties of an encoded stream.

sizeof([`AVCodecParameters`](@ref)) is not a part of the public ABI, this struct must be allocated with [`avcodec_parameters_alloc`](@ref)() and freed with [`avcodec_parameters_free`](@ref)().
"""
struct AVCodecParameters
    codec_type::AVMediaType
    codec_id::AVCodecID
    codec_tag::UInt32
    extradata::Ptr{UInt8}
    extradata_size::Cint
    format::Cint
    bit_rate::Int64
    bits_per_coded_sample::Cint
    bits_per_raw_sample::Cint
    profile::Cint
    level::Cint
    width::Cint
    height::Cint
    sample_aspect_ratio::AVRational
    field_order::AVFieldOrder
    color_range::AVColorRange
    color_primaries::AVColorPrimaries
    color_trc::AVColorTransferCharacteristic
    color_space::AVColorSpace
    chroma_location::AVChromaLocation
    video_delay::Cint
    channel_layout::UInt64
    channels::Cint
    sample_rate::Cint
    block_align::Cint
    frame_size::Cint
    initial_padding::Cint
    trailing_padding::Cint
    seek_preroll::Cint
end

"""
    avcodec_parameters_from_context(par, codec)

Fill the parameters struct based on the values from the supplied codec context. Any allocated fields in par are freed and replaced with duplicates of the corresponding fields in codec.

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function avcodec_parameters_from_context(par, codec)
    ccall((:avcodec_parameters_from_context, libavcodec), Cint, (Ptr{AVCodecParameters}, Ptr{AVCodecContext}), par, codec)
end

"""
    avcodec_parameters_to_context(codec, par)

Fill the codec context based on the values from the supplied codec parameters. Any allocated fields in codec that have a corresponding field in par are freed and replaced with duplicates of the corresponding field in par. Fields in codec that do not have a counterpart in par are not touched.

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function avcodec_parameters_to_context(codec, par)
    ccall((:avcodec_parameters_to_context, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodecParameters}), codec, par)
end

"""
    avcodec_open2(avctx, codec, options)

Initialize the [`AVCodecContext`](@ref) to use the given [`AVCodec`](@ref). Prior to using this function the context has to be allocated with [`avcodec_alloc_context3`](@ref)().

The functions [`avcodec_find_decoder_by_name`](@ref)(), [`avcodec_find_encoder_by_name`](@ref)(), [`avcodec_find_decoder`](@ref)() and [`avcodec_find_encoder`](@ref)() provide an easy way for retrieving a codec.

!!! warning

    This function is not thread safe!

!!! note

    Always call this function before using decoding routines (such as avcodec_receive_frame()).

```c++
 av_dict_set(&opts, "b", "2.5M", 0);
 codec = avcodec_find_decoder(AV_CODEC_ID_H264);
 if (!codec)
     exit(1);
 context = avcodec_alloc_context3(codec);
 if (avcodec_open2(context, codec, opts) < 0)
     exit(1);
```

### Parameters
* `avctx`: The context to initialize. 

* `codec`: The codec to open this context for. If a non-NULL codec has been previously passed to [`avcodec_alloc_context3`](@ref)() or for this context, then this parameter MUST be either NULL or equal to the previously passed codec. 

* `options`: A dictionary filled with [`AVCodecContext`](@ref) and codec-private options. On return this object will be filled with options that were not found.

### Returns
zero on success, a negative value on error 

### See also
[`avcodec_alloc_context3`](@ref)(), [`avcodec_find_decoder`](@ref)(), [`avcodec_find_encoder`](@ref)(), [`av_dict_set`](@ref)(), [`av_opt_find`](@ref)().
"""
function avcodec_open2(avctx, codec, options)
    ccall((:avcodec_open2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVCodec}, Ptr{Ptr{AVDictionary}}), avctx, codec, options)
end

"""
    avcodec_close(avctx)

Close a given [`AVCodecContext`](@ref) and free all the data associated with it (but not the [`AVCodecContext`](@ref) itself).

Calling this function on an [`AVCodecContext`](@ref) that hasn't been opened will free the codec-specific data allocated in [`avcodec_alloc_context3`](@ref)() with a non-NULL codec. Subsequent calls will do nothing.

!!! note

    Do not use this function. Use [`avcodec_free_context`](@ref)() to destroy a codec context (either open or closed). Opening and closing a codec context multiple times is not supported anymore -- use multiple codec contexts instead.
"""
function avcodec_close(avctx)
    ccall((:avcodec_close, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
end

"""
    avsubtitle_free(sub)

Free all allocated data in the given subtitle struct.

### Parameters
* `sub`: [`AVSubtitle`](@ref) to free.
"""
function avsubtitle_free(sub)
    ccall((:avsubtitle_free, libavcodec), Cvoid, (Ptr{AVSubtitle},), sub)
end

"""
    avcodec_default_get_buffer2(s, frame, flags::Integer)

The default callback for [`AVCodecContext`](@ref).get\\_buffer2(). It is made public so it can be called by custom get\\_buffer2() implementations for decoders without [`AV_CODEC_CAP_DR1`](@ref) set.
"""
function avcodec_default_get_buffer2(s, frame, flags::Integer)
    ccall((:avcodec_default_get_buffer2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}, Cint), s, frame, flags)
end

"""
    AVPacket

This structure stores compressed data. It is typically exported by demuxers and then passed as input to decoders, or received as output from encoders and then passed to muxers.

For video, it should typically contain one compressed frame. For audio it may contain several compressed frames. Encoders are allowed to output empty packets, with no compressed data, containing only side data (e.g. to update some stream parameters at the end of encoding).

The semantics of data ownership depends on the buf field. If it is set, the packet data is dynamically allocated and is valid indefinitely until a call to [`av_packet_unref`](@ref)() reduces the reference count to 0.

If the buf field is not set [`av_packet_ref`](@ref)() would make a copy instead of increasing the reference count.

The side data is always allocated with [`av_malloc`](@ref)(), copied by [`av_packet_ref`](@ref)() and freed by [`av_packet_unref`](@ref)().

sizeof([`AVPacket`](@ref)) being a part of the public ABI is deprecated. once [`av_init_packet`](@ref)() is removed, new packets will only be able to be allocated with [`av_packet_alloc`](@ref)(), and new fields may be added to the end of the struct with a minor bump.

### See also
[`av_packet_alloc`](@ref), [`av_packet_ref`](@ref), [`av_packet_unref`](@ref)
"""
struct AVPacket
    data::NTuple{88, UInt8}
end

function Base.getproperty(x::Ptr{AVPacket}, f::Symbol)
    f === :buf && return Ptr{Ptr{AVBufferRef}}(x + 0)
    f === :pts && return Ptr{Int64}(x + 8)
    f === :dts && return Ptr{Int64}(x + 16)
    f === :data && return Ptr{Ptr{UInt8}}(x + 24)
    f === :size && return Ptr{Cint}(x + 32)
    f === :stream_index && return Ptr{Cint}(x + 36)
    f === :flags && return Ptr{Cint}(x + 40)
    f === :side_data && return Ptr{Ptr{AVPacketSideData}}(x + 48)
    f === :side_data_elems && return Ptr{Cint}(x + 56)
    f === :duration && return Ptr{Int64}(x + 64)
    f === :pos && return Ptr{Int64}(x + 72)
    f === :convergence_duration && return Ptr{Int64}(x + 80)
    return getfield(x, f)
end

function Base.getproperty(x::AVPacket, f::Symbol)
    r = Ref{AVPacket}(x)
    ptr = Base.unsafe_convert(Ptr{AVPacket}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVPacket}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    avcodec_default_get_encode_buffer(s, pkt, flags::Integer)

The default callback for [`AVCodecContext`](@ref).get\\_encode\\_buffer(). It is made public so it can be called by custom get\\_encode\\_buffer() implementations for encoders without [`AV_CODEC_CAP_DR1`](@ref) set.
"""
function avcodec_default_get_encode_buffer(s, pkt, flags::Integer)
    ccall((:avcodec_default_get_encode_buffer, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Cint), s, pkt, flags)
end

"""
    avcodec_align_dimensions(s, width, height)

Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.

May only be used if a codec with [`AV_CODEC_CAP_DR1`](@ref) has been opened.
"""
function avcodec_align_dimensions(s, width, height)
    ccall((:avcodec_align_dimensions, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{Cint}, Ptr{Cint}), s, width, height)
end

"""
    avcodec_align_dimensions2(s, width, height, linesize_align)

Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize\\_align[i].

May only be used if a codec with [`AV_CODEC_CAP_DR1`](@ref) has been opened.
"""
function avcodec_align_dimensions2(s, width, height, linesize_align)
    ccall((:avcodec_align_dimensions2, libavcodec), Cvoid, (Ptr{AVCodecContext}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), s, width, height, linesize_align)
end

"""
    avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)

Converts [`AVChromaLocation`](@ref) to swscale x/y chroma position.

The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256

### Parameters
* `xpos`: horizontal chroma sample position 

* `ypos`: vertical chroma sample position
"""
function avcodec_enum_to_chroma_pos(xpos, ypos, pos::AVChromaLocation)
    ccall((:avcodec_enum_to_chroma_pos, libavcodec), Cint, (Ptr{Cint}, Ptr{Cint}, AVChromaLocation), xpos, ypos, pos)
end

"""
    avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)

Converts swscale x/y chroma position to [`AVChromaLocation`](@ref).

The positions represent the chroma (0,0) position in a coordinates system with luma (0,0) representing the origin and luma(1,1) representing 256,256

### Parameters
* `xpos`: horizontal chroma sample position 

* `ypos`: vertical chroma sample position
"""
function avcodec_chroma_pos_to_enum(xpos::Integer, ypos::Integer)
    ccall((:avcodec_chroma_pos_to_enum, libavcodec), AVChromaLocation, (Cint, Cint), xpos, ypos)
end

"""
    avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt)

Decode the audio frame of size avpkt->size from avpkt->data into frame.

Some decoders may support multiple frames in a single [`AVPacket`](@ref). Such decoders would then just decode the first frame and the return value would be less than the packet size. In this case, [`avcodec_decode_audio4`](@ref) has to be called again with an [`AVPacket`](@ref) containing the remaining data in order to decode the second frame, etc... Even if no frames are returned, the packet needs to be fed to the decoder with remaining data until it is completely consumed or an error occurs.

Some decoders (those marked with [`AV_CODEC_CAP_DELAY`](@ref)) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning samples. It is safe to flush even those decoders that are not marked with [`AV_CODEC_CAP_DELAY`](@ref), then no samples will be returned.

!!! warning

    The input buffer, avpkt->data must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.

!!! note

    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.

\\deprecated Use [`avcodec_send_packet`](@ref)() and [`avcodec_receive_frame`](@ref)().

### Parameters
* `avctx`: the codec context 

* `frame`:\\[out\\] The [`AVFrame`](@ref) in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the [`AVCodecContext`](@ref).get\\_buffer2() callback. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using [`av_frame_unref`](@ref)() when the frame is no longer needed. The caller may safely write to the frame if [`av_frame_is_writable`](@ref)() returns 1. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it. 

* `got_frame_ptr`:\\[out\\] Zero if no frame could be decoded, otherwise it is non-zero. Note that this field being set to zero does not mean that an error has occurred. For decoders with [`AV_CODEC_CAP_DELAY`](@ref) set, no given decode call is guaranteed to produce a frame. 

* `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer. At least avpkt->data and avpkt->size should be set. Some decoders might also require additional fields to be set. 

### Returns
A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input [`AVPacket`](@ref) is returned.
"""
function avcodec_decode_audio4(avctx, frame, got_frame_ptr, avpkt)
    ccall((:avcodec_decode_audio4, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}, Ptr{Cint}, Ptr{AVPacket}), avctx, frame, got_frame_ptr, avpkt)
end

"""
    avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt)

Decode the video frame of size avpkt->size from avpkt->data into picture. Some decoders may support multiple frames in a single [`AVPacket`](@ref), such decoders would then just decode the first frame.

!!! warning

    The input buffer must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.

!!! warning

    The end of the input buffer buf should be set to 0 to ensure that no overreading happens for damaged MPEG streams.

!!! note

    Codecs which have the [`AV_CODEC_CAP_DELAY`](@ref) capability set have a delay between input and output, these need to be fed with avpkt->data=NULL, avpkt->size=0 at the end to return the remaining frames.

!!! note

    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.

\\deprecated Use [`avcodec_send_packet`](@ref)() and [`avcodec_receive_frame`](@ref)().

### Parameters
* `avctx`: the codec context 

* `picture`:\\[out\\] The [`AVFrame`](@ref) in which the decoded video frame will be stored. Use [`av_frame_alloc`](@ref)() to get an [`AVFrame`](@ref). The codec will allocate memory for the actual bitmap by calling the [`AVCodecContext`](@ref).get\\_buffer2() callback. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using [`av_frame_unref`](@ref)() when the frame is no longer needed. The caller may safely write to the frame if [`av_frame_is_writable`](@ref)() returns 1. When [`AVCodecContext`](@ref).refcounted\\_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.

* `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer. You can create such packet with [`av_init_packet`](@ref)() and by then setting data and size, some decoders might in addition need other fields like flags&AV\\_PKT\\_FLAG\\_KEY. All decoders are designed to use the least fields possible. 

* `got_picture_ptr`:\\[in,out\\] Zero if no frame could be decompressed, otherwise, it is nonzero. 

### Returns
On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed.
"""
function avcodec_decode_video2(avctx, picture, got_picture_ptr, avpkt)
    ccall((:avcodec_decode_video2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}, Ptr{Cint}, Ptr{AVPacket}), avctx, picture, got_picture_ptr, avpkt)
end

"""
    avcodec_decode_subtitle2(avctx, sub, got_sub_ptr, avpkt)

Decode a subtitle message. Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got\\_sub\\_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that [`AV_CODEC_CAP_DR1`](@ref) is not available for subtitle codecs. This is for simplicity, because the performance difference is expected to be negligible and reusing a get\\_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.

Some decoders (those marked with [`AV_CODEC_CAP_DELAY`](@ref)) have a delay between input and output. This means that for some packets they will not immediately produce decoded output and need to be flushed at the end of decoding to get all the decoded data. Flushing is done by calling this function with packets with avpkt->data set to NULL and avpkt->size set to 0 until it stops returning subtitles. It is safe to flush even those decoders that are not marked with [`AV_CODEC_CAP_DELAY`](@ref), then no subtitles will be returned.

!!! note

    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.

### Parameters
* `avctx`: the codec context 

* `sub`:\\[out\\] The preallocated [`AVSubtitle`](@ref) in which the decoded subtitle will be stored, must be freed with [`avsubtitle_free`](@ref) if *got\\_sub\\_ptr is set. 

* `got_sub_ptr`:\\[in,out\\] Zero if no subtitle could be decompressed, otherwise, it is nonzero. 

* `avpkt`:\\[in\\] The input [`AVPacket`](@ref) containing the input buffer.
"""
function avcodec_decode_subtitle2(avctx, sub, got_sub_ptr, avpkt)
    ccall((:avcodec_decode_subtitle2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVSubtitle}, Ptr{Cint}, Ptr{AVPacket}), avctx, sub, got_sub_ptr, avpkt)
end

"""
    avcodec_send_packet(avctx, avpkt)

Supply raw packet data as input to a decoder.

Internally, this call will copy relevant [`AVCodecContext`](@ref) fields, which can influence decoding per-packet, and apply them when the packet is actually decoded. (For example [`AVCodecContext`](@ref).skip\\_frame, which might direct the decoder to drop the frame contained by the packet sent with this function.)

!!! warning

    The input buffer, avpkt->data must be [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) larger than the actual read bytes because some optimized bitstream readers read 32 or 64 bits at once and could read over the end.

!!! warning

    Do not mix this API with the legacy API (like [`avcodec_decode_video2`](@ref)()) on the same [`AVCodecContext`](@ref). It will return unexpected results now or in future libavcodec versions.

!!! note

    The [`AVCodecContext`](@ref) MUST have been opened with avcodec_open2() before packets may be fed to the decoder.

### Parameters
* `avctx`: codec context 

* `avpkt`:\\[in\\] The input [`AVPacket`](@ref). Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to call [`avcodec_receive_frame`](@ref)() multiple times afterwards before you can send a new packet. It can be NULL (or an [`AVPacket`](@ref) with data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return [`AVERROR_EOF`](@ref). If the decoder still has frames buffered, it will return them after sending a flush packet.

### Returns
0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): input is not accepted in the current state - user must read output with [`avcodec_receive_frame`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). [`AVERROR_EOF`](@ref): the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent) [`AVERROR`](@ref)(EINVAL): codec not opened, it is an encoder, or requires flush [`AVERROR`](@ref)(ENOMEM): failed to add packet to internal queue, or similar other errors: legitimate decoding errors
"""
function avcodec_send_packet(avctx, avpkt)
    ccall((:avcodec_send_packet, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}), avctx, avpkt)
end

"""
    avcodec_receive_frame(avctx, frame)

Return decoded output data from a decoder.

### Parameters
* `avctx`: codec context 

* `frame`: This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the decoder. Note that the function will always call [`av_frame_unref`](@ref)(frame) before doing anything else.

### Returns
0: success, a frame was returned [`AVERROR`](@ref)(EAGAIN): output is not available in this state - user must try to send new input [`AVERROR_EOF`](@ref): the decoder has been fully flushed, and there will be no more output frames [`AVERROR`](@ref)(EINVAL): codec not opened, or it is an encoder [`AVERROR_INPUT_CHANGED`](@ref): current decoded frame has changed parameters with respect to first decoded frame. Applicable when flag [`AV_CODEC_FLAG_DROPCHANGED`](@ref) is set. other negative values: legitimate decoding errors
"""
function avcodec_receive_frame(avctx, frame)
    ccall((:avcodec_receive_frame, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}), avctx, frame)
end

"""
    avcodec_send_frame(avctx, frame)

Supply a raw video or audio frame to the encoder. Use [`avcodec_receive_packet`](@ref)() to retrieve buffered output packets.

For audio: If [`AV_CODEC_CAP_VARIABLE_FRAME_SIZE`](@ref) is set, then each frame can have any number of samples. If it is not set, frame->nb\\_samples must be equal to avctx->frame\\_size for all frames except the last. The final frame may be smaller than avctx->frame\\_size. 

### Parameters
* `avctx`: codec context 

* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet. This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return [`AVERROR_EOF`](@ref).

### Returns
0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): input is not accepted in the current state - user must read output with [`avcodec_receive_packet`](@ref)() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). [`AVERROR_EOF`](@ref): the encoder has been flushed, and no new frames can be sent to it [`AVERROR`](@ref)(EINVAL): codec not opened, refcounted\\_frames not set, it is a decoder, or requires flush [`AVERROR`](@ref)(ENOMEM): failed to add packet to internal queue, or similar other errors: legitimate encoding errors
"""
function avcodec_send_frame(avctx, frame)
    ccall((:avcodec_send_frame, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVFrame}), avctx, frame)
end

"""
    avcodec_receive_packet(avctx, avpkt)

Read encoded data from the encoder.

### Parameters
* `avctx`: codec context 

* `avpkt`: This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call [`av_packet_unref`](@ref)(avpkt) before doing anything else. 

### Returns
0 on success, otherwise negative error code: [`AVERROR`](@ref)(EAGAIN): output is not available in the current state - user must try to send input [`AVERROR_EOF`](@ref): the encoder has been fully flushed, and there will be no more output packets [`AVERROR`](@ref)(EINVAL): codec not opened, or it is a decoder other errors: legitimate encoding errors
"""
function avcodec_receive_packet(avctx, avpkt)
    ccall((:avcodec_receive_packet, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}), avctx, avpkt)
end

"""
    avcodec_get_hw_frames_parameters(avctx, device_ref, hw_pix_fmt::AVPixelFormat, out_frames_ref)

Create and return a [`AVHWFramesContext`](@ref) with values adequate for hardware decoding. This is meant to get called from the get\\_format callback, and is a helper for preparing a [`AVHWFramesContext`](@ref) for [`AVCodecContext`](@ref).hw\\_frames\\_ctx. This API is for decoding with certain hardware acceleration modes/APIs only.

The returned [`AVHWFramesContext`](@ref) is not initialized. The caller must do this with [`av_hwframe_ctx_init`](@ref)().

Calling this function is not a requirement, but makes it simpler to avoid codec or hardware API specific details when manually allocating frames.

Alternatively to this, an API user can set [`AVCodecContext`](@ref).hw\\_device\\_ctx, which sets up [`AVCodecContext`](@ref).hw\\_frames\\_ctx fully automatically, and makes it unnecessary to call this function or having to care about [`AVHWFramesContext`](@ref) initialization at all.

There are a number of requirements for calling this function:

- It must be called from get\\_format with the same avctx parameter that was passed to get\\_format. Calling it outside of get\\_format is not allowed, and can trigger undefined behavior. - The function is not always supported (see description of return values). Even if this function returns successfully, hwaccel initialization could fail later. (The degree to which implementations check whether the stream is actually supported varies. Some do this check only after the user's get\\_format callback returns.) - The hw\\_pix\\_fmt must be one of the choices suggested by get\\_format. If the user decides to use a [`AVHWFramesContext`](@ref) prepared with this API function, the user must return the same hw\\_pix\\_fmt from get\\_format. - The device\\_ref passed to this function must support the given hw\\_pix\\_fmt. - After calling this API function, it is the user's responsibility to initialize the [`AVHWFramesContext`](@ref) (returned by the out\\_frames\\_ref parameter), and to set [`AVCodecContext`](@ref).hw\\_frames\\_ctx to it. If done, this must be done before returning from get\\_format (this is implied by the normal [`AVCodecContext`](@ref).hw\\_frames\\_ctx API rules). - The [`AVHWFramesContext`](@ref) parameters may change every time time get\\_format is called. Also, [`AVCodecContext`](@ref).hw\\_frames\\_ctx is reset before get\\_format. So you are inherently required to go through this process again on every get\\_format call. - It is perfectly possible to call this function without actually using the resulting [`AVHWFramesContext`](@ref). One use-case might be trying to reuse a previously initialized [`AVHWFramesContext`](@ref), and calling this API function only to test whether the required frame parameters have changed. - Fields that use dynamically allocated values of any kind must not be set by the user unless setting them is explicitly allowed by the documentation. If the user sets [`AVHWFramesContext`](@ref).free and [`AVHWFramesContext`](@ref).user\\_opaque, the new free callback must call the potentially set previous free callback. This API call may set any dynamically allocated fields, including the free callback.

The function will set at least the following fields on [`AVHWFramesContext`](@ref) (potentially more, depending on hwaccel API):

- All fields set by [`av_hwframe_ctx_alloc`](@ref)(). - Set the format field to hw\\_pix\\_fmt. - Set the sw\\_format field to the most suited and most versatile format. (An implication is that this will prefer generic formats over opaque formats with arbitrary restrictions, if possible.) - Set the width/height fields to the coded frame size, rounded up to the API-specific minimum alignment. - Only \\_if\\_ the hwaccel requires a pre-allocated pool: set the initial\\_pool\\_size field to the number of maximum reference surfaces possible with the codec, plus 1 surface for the user to work (meaning the user can safely reference at most 1 decoded surface at a time), plus additional buffering introduced by frame threading. If the hwaccel does not require pre-allocation, the field is left to 0, and the decoder will allocate new surfaces on demand during decoding. - Possibly [`AVHWFramesContext`](@ref).hwctx fields, depending on the underlying hardware API.

Essentially, out\\_frames\\_ref returns the same as [`av_hwframe_ctx_alloc`](@ref)(), but with basic frame parameters set.

The function is stateless, and does not change the [`AVCodecContext`](@ref) or the device\\_ref [`AVHWDeviceContext`](@ref).

### Parameters
* `avctx`: The context which is currently calling get\\_format, and which implicitly contains all state needed for filling the returned [`AVHWFramesContext`](@ref) properly. 

* `device_ref`: A reference to the [`AVHWDeviceContext`](@ref) describing the device which will be used by the hardware decoder. 

* `hw_pix_fmt`: The hwaccel format you are going to return from get\\_format. 

* `out_frames_ref`: On success, set to a reference to an \\_uninitialized\\_ [`AVHWFramesContext`](@ref), created from the given device\\_ref. Fields will be set to values required for decoding. Not changed if an error is returned. 

### Returns
zero on success, a negative value on error. The following error codes have special semantics: [`AVERROR`](@ref)(ENOENT): the decoder does not support this functionality. Setup is always manual, or it is a decoder which does not support setting [`AVCodecContext`](@ref).hw\\_frames\\_ctx at all, or it is a software format. [`AVERROR`](@ref)(EINVAL): it is known that hardware decoding is not supported for this configuration, or the device\\_ref is not supported for the hwaccel referenced by hw\\_pix\\_fmt.
"""
function avcodec_get_hw_frames_parameters(avctx, device_ref, hw_pix_fmt::AVPixelFormat, out_frames_ref)
    ccall((:avcodec_get_hw_frames_parameters, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVBufferRef}, AVPixelFormat, Ptr{Ptr{AVBufferRef}}), avctx, device_ref, hw_pix_fmt, out_frames_ref)
end

"""
    AVPictureStructure

` lavc_parsing Frame parsing`

@{
"""
const AVPictureStructure = UInt32
const AV_PICTURE_STRUCTURE_UNKNOWN = 0 % UInt32
const AV_PICTURE_STRUCTURE_TOP_FIELD = 1 % UInt32
const AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2 % UInt32
const AV_PICTURE_STRUCTURE_FRAME = 3 % UInt32

struct AVCodecParserContext
    data::NTuple{352, UInt8}
end

function Base.getproperty(x::Ptr{AVCodecParserContext}, f::Symbol)
    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 0)
    f === :parser && return Ptr{Ptr{AVCodecParser}}(x + 8)
    f === :frame_offset && return Ptr{Int64}(x + 16)
    f === :cur_offset && return Ptr{Int64}(x + 24)
    f === :next_frame_offset && return Ptr{Int64}(x + 32)
    f === :pict_type && return Ptr{Cint}(x + 40)
    f === :repeat_pict && return Ptr{Cint}(x + 44)
    f === :pts && return Ptr{Int64}(x + 48)
    f === :dts && return Ptr{Int64}(x + 56)
    f === :last_pts && return Ptr{Int64}(x + 64)
    f === :last_dts && return Ptr{Int64}(x + 72)
    f === :fetch_timestamp && return Ptr{Cint}(x + 80)
    f === :cur_frame_start_index && return Ptr{Cint}(x + 84)
    f === :cur_frame_offset && return Ptr{NTuple{4, Int64}}(x + 88)
    f === :cur_frame_pts && return Ptr{NTuple{4, Int64}}(x + 120)
    f === :cur_frame_dts && return Ptr{NTuple{4, Int64}}(x + 152)
    f === :flags && return Ptr{Cint}(x + 184)
    f === :offset && return Ptr{Int64}(x + 192)
    f === :cur_frame_end && return Ptr{NTuple{4, Int64}}(x + 200)
    f === :key_frame && return Ptr{Cint}(x + 232)
    f === :convergence_duration && return Ptr{Int64}(x + 240)
    f === :dts_sync_point && return Ptr{Cint}(x + 248)
    f === :dts_ref_dts_delta && return Ptr{Cint}(x + 252)
    f === :pts_dts_delta && return Ptr{Cint}(x + 256)
    f === :cur_frame_pos && return Ptr{NTuple{4, Int64}}(x + 264)
    f === :pos && return Ptr{Int64}(x + 296)
    f === :last_pos && return Ptr{Int64}(x + 304)
    f === :duration && return Ptr{Cint}(x + 312)
    f === :field_order && return Ptr{AVFieldOrder}(x + 316)
    f === :picture_structure && return Ptr{AVPictureStructure}(x + 320)
    f === :output_picture_number && return Ptr{Cint}(x + 324)
    f === :width && return Ptr{Cint}(x + 328)
    f === :height && return Ptr{Cint}(x + 332)
    f === :coded_width && return Ptr{Cint}(x + 336)
    f === :coded_height && return Ptr{Cint}(x + 340)
    f === :format && return Ptr{Cint}(x + 344)
    return getfield(x, f)
end

function Base.getproperty(x::AVCodecParserContext, f::Symbol)
    r = Ref{AVCodecParserContext}(x)
    ptr = Base.unsafe_convert(Ptr{AVCodecParserContext}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVCodecParserContext}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct AVCodecParser
    data::NTuple{64, UInt8}
end

function Base.getproperty(x::Ptr{AVCodecParser}, f::Symbol)
    f === :codec_ids && return Ptr{NTuple{5, Cint}}(x + 0)
    f === :priv_data_size && return Ptr{Cint}(x + 20)
    f === :parser_init && return Ptr{Ptr{Cvoid}}(x + 24)
    f === :parser_parse && return Ptr{Ptr{Cvoid}}(x + 32)
    f === :parser_close && return Ptr{Ptr{Cvoid}}(x + 40)
    f === :split && return Ptr{Ptr{Cvoid}}(x + 48)
    f === :next && return Ptr{Ptr{AVCodecParser}}(x + 56)
    return getfield(x, f)
end

function Base.getproperty(x::AVCodecParser, f::Symbol)
    r = Ref{AVCodecParser}(x)
    ptr = Base.unsafe_convert(Ptr{AVCodecParser}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVCodecParser}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    av_parser_iterate(opaque)

Iterate over all registered codec parsers.

### Parameters
* `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered codec parser or NULL when the iteration is finished
"""
function av_parser_iterate(opaque)
    ccall((:av_parser_iterate, libavcodec), Ptr{AVCodecParser}, (Ptr{Ptr{Cvoid}},), opaque)
end

function av_parser_next(c)
    ccall((:av_parser_next, libavcodec), Ptr{AVCodecParser}, (Ptr{AVCodecParser},), c)
end

function av_register_codec_parser(parser)
    ccall((:av_register_codec_parser, libavcodec), Cvoid, (Ptr{AVCodecParser},), parser)
end

function av_parser_init(codec_id::Integer)
    ccall((:av_parser_init, libavcodec), Ptr{AVCodecParserContext}, (Cint,), codec_id)
end

"""
    av_parser_parse2(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, pts::Int64, dts::Int64, pos::Int64)

Parse a packet.

Example: 

```c++
   while(in_len){
       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
                                        in_data, in_len,
                                        pts, dts, pos);
       in_data += len;
       in_len  -= len;
       if(size)
          decode_frame(data, size);
   }
```

### Parameters
* `s`: parser context. 

* `avctx`: codec context. 

* `poutbuf`: set to pointer to parsed buffer or NULL if not yet finished. 

* `poutbuf_size`: set to size of parsed buffer or zero if not yet finished. 

* `buf`: input buffer. 

* `buf_size`: buffer size in bytes without the padding. I.e. the full buffer size is assumed to be buf\\_size + [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref). To signal EOF, this should be 0 (so that the last frame can be output). 

* `pts`: input presentation timestamp. 

* `dts`: input decoding timestamp. 

* `pos`: input byte position in stream. 

### Returns
the number of bytes of the input bitstream used.
"""
function av_parser_parse2(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, pts::Int64, dts::Int64, pos::Int64)
    ccall((:av_parser_parse2, libavcodec), Cint, (Ptr{AVCodecParserContext}, Ptr{AVCodecContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Int64, Int64, Int64), s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos)
end

"""
    av_parser_change(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)

\\deprecated Use dump\\_extradata, remove\\_extra or extract\\_extradata bitstream filters instead.

### Returns
0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed 
"""
function av_parser_change(s, avctx, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
    ccall((:av_parser_change, libavcodec), Cint, (Ptr{AVCodecParserContext}, Ptr{AVCodecContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Cint), s, avctx, poutbuf, poutbuf_size, buf, buf_size, keyframe)
end

function av_parser_close(s)
    ccall((:av_parser_close, libavcodec), Cvoid, (Ptr{AVCodecParserContext},), s)
end

"""
    avcodec_encode_audio2(avctx, avpkt, frame, got_packet_ptr)

Encode a frame of audio.

Takes input samples from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay, split, and combine input frames internally as needed.

If this function fails or produces no output, avpkt will be freed using [`av_packet_unref`](@ref)(). 

\\deprecated use [`avcodec_send_frame`](@ref)()/[`avcodec_receive_packet`](@ref)() instead. If allowed and required, set [`AVCodecContext`](@ref).get\\_encode\\_buffer to a custom function to pass user supplied output buffers.

### Parameters
* `avctx`: codec context 

* `avpkt`: output [`AVPacket`](@ref). The user can supply an output buffer by setting avpkt->data and avpkt->size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. If avpkt->data and avpkt->size are set, avpkt->destruct must also be set. All other [`AVPacket`](@ref) fields will be reset by the encoder using [`av_init_packet`](@ref)(). If avpkt->data is NULL, the encoder will allocate it. The encoder will set avpkt->size to the size of the output packet.

* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw audio data to be encoded. May be NULL when flushing an encoder that has the [`AV_CODEC_CAP_DELAY`](@ref) capability set. If [`AV_CODEC_CAP_VARIABLE_FRAME_SIZE`](@ref) is set, then each frame can have any number of samples. If it is not set, frame->nb\\_samples must be equal to avctx->frame\\_size for all frames except the last. The final frame may be smaller than avctx->frame\\_size. 

* `got_packet_ptr`:\\[out\\] This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got\\_packet\\_ptr is undefined and should not be used. 

### Returns
0 on success, negative error code on failure
"""
function avcodec_encode_audio2(avctx, avpkt, frame, got_packet_ptr)
    ccall((:avcodec_encode_audio2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVFrame}, Ptr{Cint}), avctx, avpkt, frame, got_packet_ptr)
end

"""
    avcodec_encode_video2(avctx, avpkt, frame, got_packet_ptr)

Encode a frame of video.

Takes input raw video data from frame and writes the next output packet, if available, to avpkt. The output packet does not necessarily contain data for the most recent frame, as encoders can delay and reorder input frames internally as needed.

If this function fails or produces no output, avpkt will be freed using [`av_packet_unref`](@ref)(). 

\\deprecated use [`avcodec_send_frame`](@ref)()/[`avcodec_receive_packet`](@ref)() instead. If allowed and required, set [`AVCodecContext`](@ref).get\\_encode\\_buffer to a custom function to pass user supplied output buffers.

### Parameters
* `avctx`: codec context 

* `avpkt`: output [`AVPacket`](@ref). The user can supply an output buffer by setting avpkt->data and avpkt->size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. All other [`AVPacket`](@ref) fields will be reset by the encoder using [`av_init_packet`](@ref)(). If avpkt->data is NULL, the encoder will allocate it. The encoder will set avpkt->size to the size of the output packet. The returned data (if any) belongs to the caller, he is responsible for freeing it.

* `frame`:\\[in\\] [`AVFrame`](@ref) containing the raw video data to be encoded. May be NULL when flushing an encoder that has the [`AV_CODEC_CAP_DELAY`](@ref) capability set. 

* `got_packet_ptr`:\\[out\\] This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got\\_packet\\_ptr is undefined and should not be used. 

### Returns
0 on success, negative error code on failure
"""
function avcodec_encode_video2(avctx, avpkt, frame, got_packet_ptr)
    ccall((:avcodec_encode_video2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVFrame}, Ptr{Cint}), avctx, avpkt, frame, got_packet_ptr)
end

function avcodec_encode_subtitle(avctx, buf, buf_size::Integer, sub)
    ccall((:avcodec_encode_subtitle, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{UInt8}, Cint, Ptr{AVSubtitle}), avctx, buf, buf_size, sub)
end

"""
    avpicture_alloc(picture, pix_fmt::AVPixelFormat, width::Integer, height::Integer)

\\deprecated unused
"""
function avpicture_alloc(picture, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:avpicture_alloc, libavcodec), Cint, (Ptr{AVPicture}, AVPixelFormat, Cint, Cint), picture, pix_fmt, width, height)
end

"""
    avpicture_free(picture)

\\deprecated unused
"""
function avpicture_free(picture)
    ccall((:avpicture_free, libavcodec), Cvoid, (Ptr{AVPicture},), picture)
end

"""
    avpicture_fill(picture, ptr, pix_fmt::AVPixelFormat, width::Integer, height::Integer)

\\deprecated use [`av_image_fill_arrays`](@ref)() instead.
"""
function avpicture_fill(picture, ptr, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:avpicture_fill, libavcodec), Cint, (Ptr{AVPicture}, Ptr{UInt8}, AVPixelFormat, Cint, Cint), picture, ptr, pix_fmt, width, height)
end

"""
    avpicture_layout(src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, dest, dest_size::Integer)

\\deprecated use [`av_image_copy_to_buffer`](@ref)() instead.
"""
function avpicture_layout(src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, dest, dest_size::Integer)
    ccall((:avpicture_layout, libavcodec), Cint, (Ptr{AVPicture}, AVPixelFormat, Cint, Cint, Ptr{Cuchar}, Cint), src, pix_fmt, width, height, dest, dest_size)
end

"""
    avpicture_get_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer)

\\deprecated use [`av_image_get_buffer_size`](@ref)() instead.
"""
function avpicture_get_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:avpicture_get_size, libavcodec), Cint, (AVPixelFormat, Cint, Cint), pix_fmt, width, height)
end

"""
    av_picture_copy(dst, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer)

\\deprecated [`av_image_copy`](@ref)() instead.
"""
function av_picture_copy(dst, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:av_picture_copy, libavcodec), Cvoid, (Ptr{AVPicture}, Ptr{AVPicture}, AVPixelFormat, Cint, Cint), dst, src, pix_fmt, width, height)
end

"""
    av_picture_crop(dst, src, pix_fmt::AVPixelFormat, top_band::Integer, left_band::Integer)

\\deprecated unused
"""
function av_picture_crop(dst, src, pix_fmt::AVPixelFormat, top_band::Integer, left_band::Integer)
    ccall((:av_picture_crop, libavcodec), Cint, (Ptr{AVPicture}, Ptr{AVPicture}, AVPixelFormat, Cint, Cint), dst, src, pix_fmt, top_band, left_band)
end

"""
    av_picture_pad(dst, src, height::Integer, width::Integer, pix_fmt::AVPixelFormat, padtop::Integer, padbottom::Integer, padleft::Integer, padright::Integer, color)

\\deprecated unused
"""
function av_picture_pad(dst, src, height::Integer, width::Integer, pix_fmt::AVPixelFormat, padtop::Integer, padbottom::Integer, padleft::Integer, padright::Integer, color)
    ccall((:av_picture_pad, libavcodec), Cint, (Ptr{AVPicture}, Ptr{AVPicture}, Cint, Cint, AVPixelFormat, Cint, Cint, Cint, Cint, Ptr{Cint}), dst, src, height, width, pix_fmt, padtop, padbottom, padleft, padright, color)
end

"""
    avcodec_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)

\\deprecated Use [`av_pix_fmt_get_chroma_sub_sample`](@ref)
"""
function avcodec_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)
    ccall((:avcodec_get_chroma_sub_sample, libavcodec), Cvoid, (AVPixelFormat, Ptr{Cint}, Ptr{Cint}), pix_fmt, h_shift, v_shift)
end

"""
    avcodec_pix_fmt_to_codec_tag(pix_fmt::AVPixelFormat)

Return a value representing the fourCC code associated to the pixel format pix\\_fmt, or 0 if no associated fourCC code can be found.
"""
function avcodec_pix_fmt_to_codec_tag(pix_fmt::AVPixelFormat)
    ccall((:avcodec_pix_fmt_to_codec_tag, libavcodec), Cuint, (AVPixelFormat,), pix_fmt)
end

"""
    avcodec_find_best_pix_fmt_of_list(pix_fmt_list, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)

Find the best pixel format to convert to given a certain source pixel format. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. [`avcodec_find_best_pix_fmt_of_2`](@ref)() searches which of the given pixel formats should be used to suffer the least amount of loss. The pixel formats from which it chooses one, are determined by the pix\\_fmt\\_list parameter.

### Parameters
* `pix_fmt_list`:\\[in\\] AV\\_PIX\\_FMT\\_NONE terminated array of pixel formats to choose from 

* `src_pix_fmt`:\\[in\\] source pixel format 

* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 

* `loss_ptr`:\\[out\\] Combination of flags informing you what kind of losses will occur. 

### Returns
The best pixel format to convert to or -1 if none was found.
"""
function avcodec_find_best_pix_fmt_of_list(pix_fmt_list, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
    ccall((:avcodec_find_best_pix_fmt_of_list, libavcodec), AVPixelFormat, (Ptr{AVPixelFormat}, AVPixelFormat, Cint, Ptr{Cint}), pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr)
end

"""
    avcodec_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)

\\deprecated see [`av_get_pix_fmt_loss`](@ref)()
"""
function avcodec_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)
    ccall((:avcodec_get_pix_fmt_loss, libavcodec), Cint, (AVPixelFormat, AVPixelFormat, Cint), dst_pix_fmt, src_pix_fmt, has_alpha)
end

"""
    avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)

\\deprecated see [`av_find_best_pix_fmt_of_2`](@ref)()
"""
function avcodec_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
    ccall((:avcodec_find_best_pix_fmt_of_2, libavcodec), AVPixelFormat, (AVPixelFormat, AVPixelFormat, AVPixelFormat, Cint, Ptr{Cint}), dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr)
end

function avcodec_find_best_pix_fmt2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
    ccall((:avcodec_find_best_pix_fmt2, libavcodec), AVPixelFormat, (AVPixelFormat, AVPixelFormat, AVPixelFormat, Cint, Ptr{Cint}), dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr)
end

function avcodec_default_get_format(s, fmt)
    ccall((:avcodec_default_get_format, libavcodec), AVPixelFormat, (Ptr{AVCodecContext}, Ptr{AVPixelFormat}), s, fmt)
end

"""
    av_get_codec_tag_string(buf, buf_size::Csize_t, codec_tag::Integer)

Put a string representing the codec tag codec\\_tag in buf.

\\deprecated see [`av_fourcc_make_string`](@ref)() and [`av_fourcc2str`](@ref)().

### Parameters
* `buf`: buffer to place codec tag in 

* `buf_size`: size in bytes of buf 

* `codec_tag`: codec tag to assign 

### Returns
the length of the string that would have been generated if enough space had been available, excluding the trailing null
"""
function av_get_codec_tag_string(buf, buf_size::Csize_t, codec_tag::Integer)
    ccall((:av_get_codec_tag_string, libavcodec), Csize_t, (Cstring, Csize_t, Cuint), buf, buf_size, codec_tag)
end

function avcodec_string(buf, buf_size::Integer, enc, encode::Integer)
    ccall((:avcodec_string, libavcodec), Cvoid, (Cstring, Cint, Ptr{AVCodecContext}, Cint), buf, buf_size, enc, encode)
end

"""
    av_get_profile_name(codec, profile::Integer)

Return a name for the specified profile, if available.

### Parameters
* `codec`: the codec that is searched for the given profile 

* `profile`: the profile value for which a name is requested 

### Returns
A name for the profile if found, NULL otherwise.
"""
function av_get_profile_name(codec, profile::Integer)
    ccall((:av_get_profile_name, libavcodec), Cstring, (Ptr{AVCodec}, Cint), codec, profile)
end

"""
    avcodec_profile_name(codec_id::AVCodecID, profile::Integer)

Return a name for the specified profile, if available.

!!! note

    unlike [`av_get_profile_name`](@ref)(), which searches a list of profiles supported by a specific decoder or encoder implementation, this function searches the list of profiles from the [`AVCodecDescriptor`](@ref)

### Parameters
* `codec_id`: the ID of the codec to which the requested profile belongs 

* `profile`: the profile value for which a name is requested 

### Returns
A name for the profile if found, NULL otherwise.
"""
function avcodec_profile_name(codec_id::AVCodecID, profile::Integer)
    ccall((:avcodec_profile_name, libavcodec), Cstring, (AVCodecID, Cint), codec_id, profile)
end

function avcodec_default_execute(c, func, arg, ret, count::Integer, size::Integer)
    ccall((:avcodec_default_execute, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}, Cint, Cint), c, func, arg, ret, count, size)
end

function avcodec_default_execute2(c, func, arg, ret, count::Integer)
    ccall((:avcodec_default_execute2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cint}, Cint), c, func, arg, ret, count)
end

"""
    avcodec_fill_audio_frame(frame, nb_channels::Integer, sample_fmt::AVSampleFormat, buf, buf_size::Integer, align::Integer)

Fill [`AVFrame`](@ref) audio data and linesize pointers.

The buffer buf must be a preallocated buffer with a size big enough to contain the specified samples amount. The filled [`AVFrame`](@ref) data pointers will point to this buffer.

[`AVFrame`](@ref) extended\\_data channel pointers are allocated if necessary for planar audio.

\\todo return the size in bytes required to store the samples in case of success, at the next libavutil bump

### Parameters
* `frame`: the [`AVFrame`](@ref) frame->nb\\_samples must be set prior to calling the function. This function fills in frame->data, frame->extended\\_data, frame->linesize[0]. 

* `nb_channels`: channel count 

* `sample_fmt`: sample format 

* `buf`: buffer to use for frame data 

* `buf_size`: size of buffer 

* `align`: plane size sample alignment (0 = default) 

### Returns
>=0 on success, negative error code on failure 
"""
function avcodec_fill_audio_frame(frame, nb_channels::Integer, sample_fmt::AVSampleFormat, buf, buf_size::Integer, align::Integer)
    ccall((:avcodec_fill_audio_frame, libavcodec), Cint, (Ptr{AVFrame}, Cint, AVSampleFormat, Ptr{UInt8}, Cint, Cint), frame, nb_channels, sample_fmt, buf, buf_size, align)
end

"""
    avcodec_flush_buffers(avctx)

Reset the internal codec state / flush internal buffers. Should be called e.g. when seeking or when switching to a different stream.

!!! note

    for decoders, when refcounted frames are not used (i.e. avctx->refcounted\\_frames is 0), this invalidates the frames previously returned from the decoder. When refcounted frames are used, the decoder just releases any references it might keep internally, but the caller's reference remains valid.

!!! note

    for encoders, this function will only do something if the encoder declares support for [`AV_CODEC_CAP_ENCODER_FLUSH`](@ref). When called, the encoder will drain any remaining packets, and can then be re-used for a different stream (as opposed to sending a null frame which will leave the encoder in a permanent EOF state after draining). This can be desirable if the cost of tearing down and replacing the encoder instance is high.
"""
function avcodec_flush_buffers(avctx)
    ccall((:avcodec_flush_buffers, libavcodec), Cvoid, (Ptr{AVCodecContext},), avctx)
end

"""
    av_get_bits_per_sample(codec_id::AVCodecID)

Return codec bits per sample.

### Parameters
* `codec_id`:\\[in\\] the codec 

### Returns
Number of bits per sample or zero if unknown for the given codec.
"""
function av_get_bits_per_sample(codec_id::AVCodecID)
    ccall((:av_get_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
end

"""
    av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)

Return the PCM codec associated with a sample format. 

### Parameters
* `be`: endianness, 0 for little, 1 for big, -1 (or anything else) for native 

### Returns
AV\\_CODEC\\_ID\\_PCM\\_* or AV\\_CODEC\\_ID\\_NONE
"""
function av_get_pcm_codec(fmt::AVSampleFormat, be::Integer)
    ccall((:av_get_pcm_codec, libavcodec), AVCodecID, (AVSampleFormat, Cint), fmt, be)
end

"""
    av_get_exact_bits_per_sample(codec_id::AVCodecID)

Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.

### Parameters
* `codec_id`:\\[in\\] the codec 

### Returns
Number of bits per sample or zero if unknown for the given codec.
"""
function av_get_exact_bits_per_sample(codec_id::AVCodecID)
    ccall((:av_get_exact_bits_per_sample, libavcodec), Cint, (AVCodecID,), codec_id)
end

"""
    av_get_audio_frame_duration(avctx, frame_bytes::Integer)

Return audio frame duration.

### Parameters
* `avctx`: codec context 

* `frame_bytes`: size of the frame, or 0 if unknown 

### Returns
frame duration, in samples, if known. 0 if not able to determine.
"""
function av_get_audio_frame_duration(avctx, frame_bytes::Integer)
    ccall((:av_get_audio_frame_duration, libavcodec), Cint, (Ptr{AVCodecContext}, Cint), avctx, frame_bytes)
end

"""
    av_get_audio_frame_duration2(par, frame_bytes::Integer)

This function is the same as [`av_get_audio_frame_duration`](@ref)(), except it works with [`AVCodecParameters`](@ref) instead of an [`AVCodecContext`](@ref).
"""
function av_get_audio_frame_duration2(par, frame_bytes::Integer)
    ccall((:av_get_audio_frame_duration2, libavcodec), Cint, (Ptr{AVCodecParameters}, Cint), par, frame_bytes)
end

struct AVBitStreamFilter
    name::Cstring
    codec_ids::Ptr{AVCodecID}
    priv_class::Ptr{AVClass}
    priv_data_size::Cint
    init::Ptr{Cvoid}
    filter::Ptr{Cvoid}
    close::Ptr{Cvoid}
    flush::Ptr{Cvoid}
end

struct AVBitStreamFilterContext
    priv_data::Ptr{Cvoid}
    filter::Ptr{AVBitStreamFilter}
    parser::Ptr{AVCodecParserContext}
    next::Ptr{AVBitStreamFilterContext}
    args::Cstring
end

"""
    av_register_bitstream_filter(bsf)

\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use the new bitstream filtering API (using [`AVBSFContext`](@ref)).
"""
function av_register_bitstream_filter(bsf)
    ccall((:av_register_bitstream_filter, libavcodec), Cvoid, (Ptr{AVBitStreamFilter},), bsf)
end

"""
    av_bitstream_filter_init(name)

\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_get_by_name`](@ref)(), [`av_bsf_alloc`](@ref)(), and [`av_bsf_init`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
"""
function av_bitstream_filter_init(name)
    ccall((:av_bitstream_filter_init, libavcodec), Ptr{AVBitStreamFilterContext}, (Cstring,), name)
end

"""
    av_bitstream_filter_filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)

\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_send_packet`](@ref)() and [`av_bsf_receive_packet`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
"""
function av_bitstream_filter_filter(bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size::Integer, keyframe::Integer)
    ccall((:av_bitstream_filter_filter, libavcodec), Cint, (Ptr{AVBitStreamFilterContext}, Ptr{AVCodecContext}, Cstring, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Cint), bsfc, avctx, args, poutbuf, poutbuf_size, buf, buf_size, keyframe)
end

"""
    av_bitstream_filter_close(bsf)

\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_free`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
"""
function av_bitstream_filter_close(bsf)
    ccall((:av_bitstream_filter_close, libavcodec), Cvoid, (Ptr{AVBitStreamFilterContext},), bsf)
end

"""
    av_bitstream_filter_next(f)

\\deprecated the old bitstream filtering API (using [`AVBitStreamFilterContext`](@ref)) is deprecated. Use [`av_bsf_iterate`](@ref)() from the new bitstream filtering API (using [`AVBSFContext`](@ref)).
"""
function av_bitstream_filter_next(f)
    ccall((:av_bitstream_filter_next, libavcodec), Ptr{AVBitStreamFilter}, (Ptr{AVBitStreamFilter},), f)
end

function av_bsf_next(opaque)
    ccall((:av_bsf_next, libavcodec), Ptr{AVBitStreamFilter}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    av_fast_padded_malloc(ptr, size, min_size::Csize_t)

Same behaviour [`av_fast_malloc`](@ref) but the buffer has additional [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) at the end which will always be 0.

In addition the whole buffer will initially and after resizes be 0-initialized so that no uninitialized data will ever appear.
"""
function av_fast_padded_malloc(ptr, size, min_size::Csize_t)
    ccall((:av_fast_padded_malloc, libavcodec), Cvoid, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
end

"""
    av_fast_padded_mallocz(ptr, size, min_size::Csize_t)

Same behaviour [`av_fast_padded_malloc`](@ref) except that buffer will always be 0-initialized after call.
"""
function av_fast_padded_mallocz(ptr, size, min_size::Csize_t)
    ccall((:av_fast_padded_mallocz, libavcodec), Cvoid, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
end

"""
    av_xiphlacing(s, v::Integer)

Encode extradata length to a buffer. Used by xiph codecs.

### Parameters
* `s`: buffer to write to; must be at least (v/255+1) bytes long 

* `v`: size of extradata in bytes 

### Returns
number of bytes written to the buffer.
"""
function av_xiphlacing(s, v::Integer)
    ccall((:av_xiphlacing, libavcodec), Cuint, (Ptr{Cuchar}, Cuint), s, v)
end

"""
    av_register_hwaccel(hwaccel)

Register the hardware accelerator hwaccel.

\\deprecated This function doesn't do anything.
"""
function av_register_hwaccel(hwaccel)
    ccall((:av_register_hwaccel, libavcodec), Cvoid, (Ptr{AVHWAccel},), hwaccel)
end

"""
    av_hwaccel_next(hwaccel)

If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one.

\\deprecated AVHWaccel structures contain no user-serviceable parts, so this function should not be used.
"""
function av_hwaccel_next(hwaccel)
    ccall((:av_hwaccel_next, libavcodec), Ptr{AVHWAccel}, (Ptr{AVHWAccel},), hwaccel)
end

"""
    AVLockOp

Lock operation used by lockmgr

\\deprecated Deprecated together with [`av_lockmgr_register`](@ref)().
"""
const AVLockOp = UInt32
const AV_LOCK_CREATE = 0 % UInt32
const AV_LOCK_OBTAIN = 1 % UInt32
const AV_LOCK_RELEASE = 2 % UInt32
const AV_LOCK_DESTROY = 3 % UInt32

"""
    av_lockmgr_register(cb)

Register a user provided lock manager supporting the operations specified by [`AVLockOp`](@ref). The "mutex" argument to the function points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex. It is NULL upon AV\\_LOCK\\_CREATE and equal to the value left by the last call for all other ops. If the lock manager is unable to perform the op then it should leave the mutex in the same state as when it was called and return a non-zero value. However, when called with AV\\_LOCK\\_DESTROY the mutex will always be assumed to have been successfully destroyed. If [`av_lockmgr_register`](@ref) succeeds it will return a non-negative value, if it fails it will return a negative value and destroy all mutex and unregister all callbacks. [`av_lockmgr_register`](@ref) is not thread-safe, it must be called from a single thread before any calls which make use of locking are used.

\\deprecated This function does nothing, and always returns 0. Be sure to build with thread support to get basic thread safety.

### Parameters
* `cb`: User defined callback. [`av_lockmgr_register`](@ref) invokes calls to this callback and the previously registered callback. The callback will be used to create more than one mutex each of which must be backed by its own underlying locking mechanism (i.e. do not use a single static object to implement your lock manager). If cb is set to NULL the lockmgr will be unregistered.
"""
function av_lockmgr_register(cb)
    ccall((:av_lockmgr_register, libavcodec), Cint, (Ptr{Cvoid},), cb)
end

"""
    avcodec_is_open(s)

### Returns
a positive value if s is open (i.e. [`avcodec_open2`](@ref)() was called on it with no corresponding [`avcodec_close`](@ref)()), 0 otherwise.
"""
function avcodec_is_open(s)
    ccall((:avcodec_is_open, libavcodec), Cint, (Ptr{AVCodecContext},), s)
end

"""
    av_cpb_properties_alloc(size)

Allocate a CPB properties structure and initialize its fields to default values.

### Parameters
* `size`: if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data.

### Returns
the newly allocated struct or NULL on failure
"""
function av_cpb_properties_alloc(size)
    ccall((:av_cpb_properties_alloc, libavcodec), Ptr{AVCPBProperties}, (Ptr{Csize_t},), size)
end

"""
    AVDCT

[`AVDCT`](@ref) context. 

!!! note

    function pointers can be NULL if the specific features have been disabled at build time.
"""
struct AVDCT
    av_class::Ptr{AVClass}
    idct::Ptr{Cvoid}
    idct_permutation::NTuple{64, UInt8}
    fdct::Ptr{Cvoid}
    dct_algo::Cint
    idct_algo::Cint
    get_pixels::Ptr{Cvoid}
    bits_per_sample::Cint
    get_pixels_unaligned::Ptr{Cvoid}
end

"""
    avcodec_dct_alloc()

Allocates a [`AVDCT`](@ref) context. This needs to be initialized with [`avcodec_dct_init`](@ref)() after optionally configuring it with AVOptions.

To free it use [`av_free`](@ref)()
"""
function avcodec_dct_alloc()
    ccall((:avcodec_dct_alloc, libavcodec), Ptr{AVDCT}, ())
end

function avcodec_dct_init(arg1)
    ccall((:avcodec_dct_init, libavcodec), Cint, (Ptr{AVDCT},), arg1)
end

function avcodec_dct_get_class()
    ccall((:avcodec_dct_get_class, libavcodec), Ptr{AVClass}, ())
end

"""
` lavc_fft FFT functions`

` lavc_misc`

@{
"""
const FFTSample = Cfloat

struct FFTComplex
    re::FFTSample
    im::FFTSample
end

mutable struct FFTContext end

"""
    av_fft_init(nbits::Integer, inverse::Integer)

Set up a complex FFT. 

### Parameters
* `nbits`: log2 of the length of the input array 

* `inverse`: if 0 perform the forward transform, if 1 perform the inverse
"""
function av_fft_init(nbits::Integer, inverse::Integer)
    ccall((:av_fft_init, libavcodec), Ptr{FFTContext}, (Cint, Cint), nbits, inverse)
end

"""
    av_fft_permute(s, z)

Do the permutation needed BEFORE calling ff\\_fft\\_calc().
"""
function av_fft_permute(s, z)
    ccall((:av_fft_permute, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTComplex}), s, z)
end

"""
    av_fft_calc(s, z)

Do a complex FFT with the parameters defined in [`av_fft_init`](@ref)(). The input data must be permuted before. No 1.0/sqrt(n) normalization is done.
"""
function av_fft_calc(s, z)
    ccall((:av_fft_calc, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTComplex}), s, z)
end

function av_fft_end(s)
    ccall((:av_fft_end, libavcodec), Cvoid, (Ptr{FFTContext},), s)
end

function av_mdct_init(nbits::Integer, inverse::Integer, scale::Cdouble)
    ccall((:av_mdct_init, libavcodec), Ptr{FFTContext}, (Cint, Cint, Cdouble), nbits, inverse, scale)
end

function av_imdct_calc(s, output, input)
    ccall((:av_imdct_calc, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTSample}, Ptr{FFTSample}), s, output, input)
end

function av_imdct_half(s, output, input)
    ccall((:av_imdct_half, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTSample}, Ptr{FFTSample}), s, output, input)
end

function av_mdct_calc(s, output, input)
    ccall((:av_mdct_calc, libavcodec), Cvoid, (Ptr{FFTContext}, Ptr{FFTSample}, Ptr{FFTSample}), s, output, input)
end

function av_mdct_end(s)
    ccall((:av_mdct_end, libavcodec), Cvoid, (Ptr{FFTContext},), s)
end

const RDFTransformType = UInt32
const DFT_R2C = 0 % UInt32
const IDFT_C2R = 1 % UInt32
const IDFT_R2C = 2 % UInt32
const DFT_C2R = 3 % UInt32

mutable struct RDFTContext end

"""
    av_rdft_init(nbits::Integer, trans::RDFTransformType)

Set up a real FFT. 

### Parameters
* `nbits`: log2 of the length of the input array 

* `trans`: the type of transform
"""
function av_rdft_init(nbits::Integer, trans::RDFTransformType)
    ccall((:av_rdft_init, libavcodec), Ptr{RDFTContext}, (Cint, RDFTransformType), nbits, trans)
end

function av_rdft_calc(s, data)
    ccall((:av_rdft_calc, libavcodec), Cvoid, (Ptr{RDFTContext}, Ptr{FFTSample}), s, data)
end

function av_rdft_end(s)
    ccall((:av_rdft_end, libavcodec), Cvoid, (Ptr{RDFTContext},), s)
end

mutable struct DCTContext end

const DCTTransformType = UInt32
const DCT_II = 0 % UInt32
const DCT_III = 1 % UInt32
const DCT_I = 2 % UInt32
const DST_I = 3 % UInt32

"""
    av_dct_init(nbits::Integer, type::DCTTransformType)

Set up DCT.

!!! note

    the first element of the input of DST-I is ignored

### Parameters
* `nbits`: size of the input array: (1 << nbits) for DCT-II, DCT-III and DST-I (1 << nbits) + 1 for DCT-I 

* `type`: the type of transform
"""
function av_dct_init(nbits::Integer, type::DCTTransformType)
    ccall((:av_dct_init, libavcodec), Ptr{DCTContext}, (Cint, DCTTransformType), nbits, type)
end

function av_dct_calc(s, data)
    ccall((:av_dct_calc, libavcodec), Cvoid, (Ptr{DCTContext}, Ptr{FFTSample}), s, data)
end

function av_dct_end(s)
    ccall((:av_dct_end, libavcodec), Cvoid, (Ptr{DCTContext},), s)
end

mutable struct AVBSFInternal end

"""
    AVBSFContext

The bitstream filter state.

This struct must be allocated with [`av_bsf_alloc`](@ref)() and freed with [`av_bsf_free`](@ref)().

The fields in the struct will only be changed (by the caller or by the filter) as described in their documentation, and are to be considered immutable otherwise.
"""
struct AVBSFContext
    av_class::Ptr{AVClass}
    filter::Ptr{AVBitStreamFilter}
    internal::Ptr{AVBSFInternal}
    priv_data::Ptr{Cvoid}
    par_in::Ptr{AVCodecParameters}
    par_out::Ptr{AVCodecParameters}
    time_base_in::AVRational
    time_base_out::AVRational
end

"""
    av_bsf_get_by_name(name)

### Returns
a bitstream filter with the specified name or NULL if no such bitstream filter exists.
"""
function av_bsf_get_by_name(name)
    ccall((:av_bsf_get_by_name, libavcodec), Ptr{AVBitStreamFilter}, (Cstring,), name)
end

"""
    av_bsf_iterate(opaque)

Iterate over all registered bitstream filters.

### Parameters
* `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered bitstream filter or NULL when the iteration is finished
"""
function av_bsf_iterate(opaque)
    ccall((:av_bsf_iterate, libavcodec), Ptr{AVBitStreamFilter}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    av_bsf_alloc(filter, ctx)

Allocate a context for a given bitstream filter. The caller must fill in the context parameters as described in the documentation and then call [`av_bsf_init`](@ref)() before sending any data to the filter.

### Parameters
* `filter`: the filter for which to allocate an instance. 

* `ctx`: a pointer into which the pointer to the newly-allocated context will be written. It must be freed with [`av_bsf_free`](@ref)() after the filtering is done.

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_bsf_alloc(filter, ctx)
    ccall((:av_bsf_alloc, libavcodec), Cint, (Ptr{AVBitStreamFilter}, Ptr{Ptr{AVBSFContext}}), filter, ctx)
end

"""
    av_bsf_init(ctx)

Prepare the filter for use, after all the parameters and options have been set.
"""
function av_bsf_init(ctx)
    ccall((:av_bsf_init, libavcodec), Cint, (Ptr{AVBSFContext},), ctx)
end

"""
    av_bsf_send_packet(ctx, pkt)

Submit a packet for filtering.

After sending each packet, the filter must be completely drained by calling [`av_bsf_receive_packet`](@ref)() repeatedly until it returns [`AVERROR`](@ref)(EAGAIN) or [`AVERROR_EOF`](@ref).

### Parameters
* `pkt`: the packet to filter. The bitstream filter will take ownership of the packet and reset the contents of pkt. pkt is not touched if an error occurs. If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side\\_data\\_elems zero), it signals the end of the stream (i.e. no more non-empty packets will be sent; sending more empty packets does nothing) and will cause the filter to output any packets it may have buffered internally.

### Returns
0 on success. [`AVERROR`](@ref)(EAGAIN) if packets need to be retrieved from the filter (using [`av_bsf_receive_packet`](@ref)()) before new input can be consumed. Another negative [`AVERROR`](@ref) value if an error occurs.
"""
function av_bsf_send_packet(ctx, pkt)
    ccall((:av_bsf_send_packet, libavcodec), Cint, (Ptr{AVBSFContext}, Ptr{AVPacket}), ctx, pkt)
end

"""
    av_bsf_receive_packet(ctx, pkt)

Retrieve a filtered packet.

!!! note

    one input packet may result in several output packets, so after sending a packet with [`av_bsf_send_packet`](@ref)(), this function needs to be called repeatedly until it stops returning 0. It is also possible for a filter to output fewer packets than were sent to it, so this function may return [`AVERROR`](@ref)(EAGAIN) immediately after a successful [`av_bsf_send_packet`](@ref)() call.

### Parameters
* `pkt`:\\[out\\] this struct will be filled with the contents of the filtered packet. It is owned by the caller and must be freed using [`av_packet_unref`](@ref)() when it is no longer needed. This parameter should be "clean" (i.e. freshly allocated with [`av_packet_alloc`](@ref)() or unreffed with [`av_packet_unref`](@ref)()) when this function is called. If this function returns successfully, the contents of pkt will be completely overwritten by the returned data. On failure, pkt is not touched.

### Returns
0 on success. [`AVERROR`](@ref)(EAGAIN) if more packets need to be sent to the filter (using [`av_bsf_send_packet`](@ref)()) to get more output. [`AVERROR_EOF`](@ref) if there will be no further output from the filter. Another negative [`AVERROR`](@ref) value if an error occurs.
"""
function av_bsf_receive_packet(ctx, pkt)
    ccall((:av_bsf_receive_packet, libavcodec), Cint, (Ptr{AVBSFContext}, Ptr{AVPacket}), ctx, pkt)
end

"""
    av_bsf_flush(ctx)

Reset the internal bitstream filter state. Should be called e.g. when seeking.
"""
function av_bsf_flush(ctx)
    ccall((:av_bsf_flush, libavcodec), Cvoid, (Ptr{AVBSFContext},), ctx)
end

"""
    av_bsf_free(ctx)

Free a bitstream filter context and everything associated with it; write NULL into the supplied pointer.
"""
function av_bsf_free(ctx)
    ccall((:av_bsf_free, libavcodec), Cvoid, (Ptr{Ptr{AVBSFContext}},), ctx)
end

"""
    av_bsf_get_class()

Get the [`AVClass`](@ref) for [`AVBSFContext`](@ref). It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.

### See also
[`av_opt_find`](@ref)().
"""
function av_bsf_get_class()
    ccall((:av_bsf_get_class, libavcodec), Ptr{AVClass}, ())
end

mutable struct AVBSFList end

"""
    av_bsf_list_alloc()

Allocate empty list of bitstream filters. The list must be later freed by [`av_bsf_list_free`](@ref)() or finalized by [`av_bsf_list_finalize`](@ref)().

### Returns
Pointer to AVBSFList on success, NULL in case of failure
"""
function av_bsf_list_alloc()
    ccall((:av_bsf_list_alloc, libavcodec), Ptr{AVBSFList}, ())
end

"""
    av_bsf_list_free(lst)

Free list of bitstream filters.

### Parameters
* `lst`: Pointer to pointer returned by [`av_bsf_list_alloc`](@ref)()
"""
function av_bsf_list_free(lst)
    ccall((:av_bsf_list_free, libavcodec), Cvoid, (Ptr{Ptr{AVBSFList}},), lst)
end

"""
    av_bsf_list_append(lst, bsf)

Append bitstream filter to the list of bitstream filters.

### Parameters
* `lst`: List to append to 

* `bsf`: Filter context to be appended

### Returns
>=0 on success, negative [`AVERROR`](@ref) in case of failure
"""
function av_bsf_list_append(lst, bsf)
    ccall((:av_bsf_list_append, libavcodec), Cint, (Ptr{AVBSFList}, Ptr{AVBSFContext}), lst, bsf)
end

"""
    av_bsf_list_append2(lst, bsf_name, options)

Construct new bitstream filter context given it's name and options and append it to the list of bitstream filters.

### Parameters
* `lst`: List to append to 

* `bsf_name`: Name of the bitstream filter 

* `options`: Options for the bitstream filter, can be set to NULL

### Returns
>=0 on success, negative [`AVERROR`](@ref) in case of failure
"""
function av_bsf_list_append2(lst, bsf_name, options)
    ccall((:av_bsf_list_append2, libavcodec), Cint, (Ptr{AVBSFList}, Cstring, Ptr{Ptr{AVDictionary}}), lst, bsf_name, options)
end

"""
    av_bsf_list_finalize(lst, bsf)

Finalize list of bitstream filters.

This function will transform AVBSFList to single AVBSFContext, so the whole chain of bitstream filters can be treated as single filter freshly allocated by [`av_bsf_alloc`](@ref)(). If the call is successful, AVBSFList structure is freed and lst will be set to NULL. In case of failure, caller is responsible for freeing the structure by [`av_bsf_list_free`](@ref)()

### Parameters
* `lst`: Filter list structure to be transformed 

* `bsf`:\\[out\\] Pointer to be set to newly created AVBSFContext structure representing the chain of bitstream filters

### Returns
>=0 on success, negative [`AVERROR`](@ref) in case of failure
"""
function av_bsf_list_finalize(lst, bsf)
    ccall((:av_bsf_list_finalize, libavcodec), Cint, (Ptr{Ptr{AVBSFList}}, Ptr{Ptr{AVBSFContext}}), lst, bsf)
end

"""
    av_bsf_list_parse_str(str, bsf)

Parse string describing list of bitstream filters and create single AVBSFContext describing the whole chain of bitstream filters. Resulting AVBSFContext can be treated as any other AVBSFContext freshly allocated by [`av_bsf_alloc`](@ref)().

### Parameters
* `str`: String describing chain of bitstream filters in format `bsf1[=opt1=val1:opt2=val2][,bsf2]` 

* `bsf`:\\[out\\] Pointer to be set to newly created AVBSFContext structure representing the chain of bitstream filters

### Returns
>=0 on success, negative [`AVERROR`](@ref) in case of failure
"""
function av_bsf_list_parse_str(str, bsf)
    ccall((:av_bsf_list_parse_str, libavcodec), Cint, (Cstring, Ptr{Ptr{AVBSFContext}}), str, bsf)
end

"""
    av_bsf_get_null_filter(bsf)

Get null/pass-through bitstream filter.

### Parameters
* `bsf`:\\[out\\] Pointer to be set to new instance of pass-through bitstream filter

### Returns

"""
function av_bsf_get_null_filter(bsf)
    ccall((:av_bsf_get_null_filter, libavcodec), Cint, (Ptr{Ptr{AVBSFContext}},), bsf)
end

"""
    av_codec_iterate(opaque)

Iterate over all registered codecs.

### Parameters
* `opaque`: a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered codec or NULL when the iteration is finished
"""
function av_codec_iterate(opaque)
    ccall((:av_codec_iterate, libavcodec), Ptr{AVCodec}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    avcodec_find_decoder(id::AVCodecID)

Find a registered decoder with a matching codec ID.

### Parameters
* `id`: [`AVCodecID`](@ref) of the requested decoder 

### Returns
A decoder if one was found, NULL otherwise.
"""
function avcodec_find_decoder(id::AVCodecID)
    ccall((:avcodec_find_decoder, libavcodec), Ptr{AVCodec}, (AVCodecID,), id)
end

"""
    avcodec_find_decoder_by_name(name)

Find a registered decoder with the specified name.

### Parameters
* `name`: name of the requested decoder 

### Returns
A decoder if one was found, NULL otherwise.
"""
function avcodec_find_decoder_by_name(name)
    ccall((:avcodec_find_decoder_by_name, libavcodec), Ptr{AVCodec}, (Cstring,), name)
end

"""
    avcodec_find_encoder(id::AVCodecID)

Find a registered encoder with a matching codec ID.

### Parameters
* `id`: [`AVCodecID`](@ref) of the requested encoder 

### Returns
An encoder if one was found, NULL otherwise.
"""
function avcodec_find_encoder(id::AVCodecID)
    ccall((:avcodec_find_encoder, libavcodec), Ptr{AVCodec}, (AVCodecID,), id)
end

"""
    avcodec_find_encoder_by_name(name)

Find a registered encoder with the specified name.

### Parameters
* `name`: name of the requested encoder 

### Returns
An encoder if one was found, NULL otherwise.
"""
function avcodec_find_encoder_by_name(name)
    ccall((:avcodec_find_encoder_by_name, libavcodec), Ptr{AVCodec}, (Cstring,), name)
end

"""
    av_codec_is_encoder(codec)

### Returns
a non-zero number if codec is an encoder, zero otherwise
"""
function av_codec_is_encoder(codec)
    ccall((:av_codec_is_encoder, libavcodec), Cint, (Ptr{AVCodec},), codec)
end

"""
    av_codec_is_decoder(codec)

### Returns
a non-zero number if codec is a decoder, zero otherwise
"""
function av_codec_is_decoder(codec)
    ccall((:av_codec_is_decoder, libavcodec), Cint, (Ptr{AVCodec},), codec)
end

const __JL_Ctag_95 = UInt32
const AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1 % UInt32
const AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2 % UInt32
const AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4 % UInt32
const AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8 % UInt32

const AVHWDeviceType = UInt32
const AV_HWDEVICE_TYPE_NONE = 0 % UInt32
const AV_HWDEVICE_TYPE_VDPAU = 1 % UInt32
const AV_HWDEVICE_TYPE_CUDA = 2 % UInt32
const AV_HWDEVICE_TYPE_VAAPI = 3 % UInt32
const AV_HWDEVICE_TYPE_DXVA2 = 4 % UInt32
const AV_HWDEVICE_TYPE_QSV = 5 % UInt32
const AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6 % UInt32
const AV_HWDEVICE_TYPE_D3D11VA = 7 % UInt32
const AV_HWDEVICE_TYPE_DRM = 8 % UInt32
const AV_HWDEVICE_TYPE_OPENCL = 9 % UInt32
const AV_HWDEVICE_TYPE_MEDIACODEC = 10 % UInt32
const AV_HWDEVICE_TYPE_VULKAN = 11 % UInt32

struct AVCodecHWConfig
    pix_fmt::AVPixelFormat
    methods::Cint
    device_type::AVHWDeviceType
end

"""
    avcodec_get_hw_config(codec, index::Integer)

Retrieve supported hardware configurations for a codec.

Values of index from zero to some maximum return the indexed configuration descriptor; all other values return NULL. If the codec does not support any hardware configurations then it will always return NULL.
"""
function avcodec_get_hw_config(codec, index::Integer)
    ccall((:avcodec_get_hw_config, libavcodec), Ptr{AVCodecHWConfig}, (Ptr{AVCodec}, Cint), codec, index)
end

"""
    avcodec_descriptor_get(id::AVCodecID)

### Returns
descriptor for given codec ID or NULL if no descriptor exists.
"""
function avcodec_descriptor_get(id::AVCodecID)
    ccall((:avcodec_descriptor_get, libavcodec), Ptr{AVCodecDescriptor}, (AVCodecID,), id)
end

"""
    avcodec_descriptor_next(prev)

Iterate over all codec descriptors known to libavcodec.

### Parameters
* `prev`: previous descriptor. NULL to get the first descriptor.

### Returns
next descriptor or NULL after the last descriptor
"""
function avcodec_descriptor_next(prev)
    ccall((:avcodec_descriptor_next, libavcodec), Ptr{AVCodecDescriptor}, (Ptr{AVCodecDescriptor},), prev)
end

"""
    avcodec_descriptor_get_by_name(name)

### Returns
codec descriptor with the given name or NULL if no such descriptor exists.
"""
function avcodec_descriptor_get_by_name(name)
    ccall((:avcodec_descriptor_get_by_name, libavcodec), Ptr{AVCodecDescriptor}, (Cstring,), name)
end

"""
    avcodec_get_type(codec_id::AVCodecID)

Get the type of the given codec.
"""
function avcodec_get_type(codec_id::AVCodecID)
    ccall((:avcodec_get_type, libavcodec), AVMediaType, (AVCodecID,), codec_id)
end

"""
    avcodec_get_name(id::AVCodecID)

Get the name of a codec. 

### Returns
a static string identifying the codec; never NULL
"""
function avcodec_get_name(id::AVCodecID)
    ccall((:avcodec_get_name, libavcodec), Cstring, (AVCodecID,), id)
end

"""
    avcodec_parameters_alloc()

Allocate a new [`AVCodecParameters`](@ref) and set its fields to default values (unknown/invalid/0). The returned struct must be freed with [`avcodec_parameters_free`](@ref)().
"""
function avcodec_parameters_alloc()
    ccall((:avcodec_parameters_alloc, libavcodec), Ptr{AVCodecParameters}, ())
end

"""
    avcodec_parameters_free(par)

Free an [`AVCodecParameters`](@ref) instance and everything associated with it and write NULL to the supplied pointer.
"""
function avcodec_parameters_free(par)
    ccall((:avcodec_parameters_free, libavcodec), Cvoid, (Ptr{Ptr{AVCodecParameters}},), par)
end

"""
    avcodec_parameters_copy(dst, src)

Copy the contents of src to dst. Any allocated fields in dst are freed and replaced with newly allocated duplicates of the corresponding fields in src.

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function avcodec_parameters_copy(dst, src)
    ccall((:avcodec_parameters_copy, libavcodec), Cint, (Ptr{AVCodecParameters}, Ptr{AVCodecParameters}), dst, src)
end

struct AVD3D11VAContext
    decoder::Ptr{Cint}
    video_context::Ptr{Cint}
    cfg::Ptr{Cint}
    surface_count::Cuint
    surface::Ptr{Ptr{Cint}}
    workaround::UInt64
    report_id::Cuint
    context_mutex::Cint
end

"""
    av_d3d11va_alloc_context()

Allocate an [`AVD3D11VAContext`](@ref).

### Returns
Newly-allocated [`AVD3D11VAContext`](@ref) or NULL on failure.
"""
function av_d3d11va_alloc_context()
    ccall((:av_d3d11va_alloc_context, libavcodec), Ptr{AVD3D11VAContext}, ())
end

"""
    DiracParseCodes

Parse code values:

Dirac Specification -> 9.6.1 Table 9.1

VC-2 Specification -> 10.4.1 Table 10.1
"""
const DiracParseCodes = UInt32
const DIRAC_PCODE_SEQ_HEADER = 0 % UInt32
const DIRAC_PCODE_END_SEQ = 16 % UInt32
const DIRAC_PCODE_AUX = 32 % UInt32
const DIRAC_PCODE_PAD = 48 % UInt32
const DIRAC_PCODE_PICTURE_CODED = 8 % UInt32
const DIRAC_PCODE_PICTURE_RAW = 72 % UInt32
const DIRAC_PCODE_PICTURE_LOW_DEL = 200 % UInt32
const DIRAC_PCODE_PICTURE_HQ = 232 % UInt32
const DIRAC_PCODE_INTER_NOREF_CO1 = 10 % UInt32
const DIRAC_PCODE_INTER_NOREF_CO2 = 9 % UInt32
const DIRAC_PCODE_INTER_REF_CO1 = 13 % UInt32
const DIRAC_PCODE_INTER_REF_CO2 = 14 % UInt32
const DIRAC_PCODE_INTRA_REF_CO = 12 % UInt32
const DIRAC_PCODE_INTRA_REF_RAW = 76 % UInt32
const DIRAC_PCODE_INTRA_REF_PICT = 204 % UInt32
const DIRAC_PCODE_MAGIC = 1111638852 % UInt32

struct DiracVersionInfo
    major::Cint
    minor::Cint
end

struct AVDiracSeqHeader
    width::Cuint
    height::Cuint
    chroma_format::UInt8
    interlaced::UInt8
    top_field_first::UInt8
    frame_rate_index::UInt8
    aspect_ratio_index::UInt8
    clean_width::UInt16
    clean_height::UInt16
    clean_left_offset::UInt16
    clean_right_offset::UInt16
    pixel_range_index::UInt8
    color_spec_index::UInt8
    profile::Cint
    level::Cint
    framerate::AVRational
    sample_aspect_ratio::AVRational
    pix_fmt::AVPixelFormat
    color_range::AVColorRange
    color_primaries::AVColorPrimaries
    color_trc::AVColorTransferCharacteristic
    colorspace::AVColorSpace
    version::DiracVersionInfo
    bit_depth::Cint
end

"""
    av_dirac_parse_sequence_header(dsh, buf, buf_size::Csize_t, log_ctx)

Parse a Dirac sequence header.

### Parameters
* `dsh`: this function will allocate and fill an [`AVDiracSeqHeader`](@ref) struct and write it into this pointer. The caller must free it with [`av_free`](@ref)(). 

* `buf`: the data buffer 

* `buf_size`: the size of the data buffer in bytes 

* `log_ctx`: if non-NULL, this function will log errors here 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_dirac_parse_sequence_header(dsh, buf, buf_size::Csize_t, log_ctx)
    ccall((:av_dirac_parse_sequence_header, libavcodec), Cint, (Ptr{Ptr{AVDiracSeqHeader}}, Ptr{UInt8}, Csize_t, Ptr{Cvoid}), dsh, buf, buf_size, log_ctx)
end

struct AVDVProfile
    dsf::Cint
    video_stype::Cint
    frame_size::Cint
    difseg_size::Cint
    n_difchan::Cint
    time_base::AVRational
    ltc_divisor::Cint
    height::Cint
    width::Cint
    sar::NTuple{2, AVRational}
    pix_fmt::AVPixelFormat
    bpm::Cint
    block_sizes::Ptr{UInt8}
    audio_stride::Cint
    audio_min_samples::NTuple{3, Cint}
    audio_samples_dist::NTuple{5, Cint}
    audio_shuffle::Ptr{NTuple{9, UInt8}}
end

"""
    av_dv_frame_profile(sys, frame, buf_size::Integer)

Get a DV profile for the provided compressed frame.

### Parameters
* `sys`: the profile used for the previous frame, may be NULL 

* `frame`: the compressed data buffer 

* `buf_size`: size of the buffer in bytes 

### Returns
the DV profile for the supplied data or NULL on failure
"""
function av_dv_frame_profile(sys, frame, buf_size::Integer)
    ccall((:av_dv_frame_profile, libavcodec), Ptr{AVDVProfile}, (Ptr{AVDVProfile}, Ptr{UInt8}, Cuint), sys, frame, buf_size)
end

"""
    av_dv_codec_profile(width::Integer, height::Integer, pix_fmt::AVPixelFormat)

Get a DV profile for the provided stream parameters.
"""
function av_dv_codec_profile(width::Integer, height::Integer, pix_fmt::AVPixelFormat)
    ccall((:av_dv_codec_profile, libavcodec), Ptr{AVDVProfile}, (Cint, Cint, AVPixelFormat), width, height, pix_fmt)
end

"""
    av_dv_codec_profile2(width::Integer, height::Integer, pix_fmt::AVPixelFormat, frame_rate::AVRational)

Get a DV profile for the provided stream parameters. The frame rate is used as a best-effort parameter.
"""
function av_dv_codec_profile2(width::Integer, height::Integer, pix_fmt::AVPixelFormat, frame_rate::AVRational)
    ccall((:av_dv_codec_profile2, libavcodec), Ptr{AVDVProfile}, (Cint, Cint, AVPixelFormat, AVRational), width, height, pix_fmt, frame_rate)
end

struct dxva_context
    decoder::Ptr{Cint}
    cfg::Ptr{Cint}
    surface_count::Cuint
    surface::Ptr{Cint}
    workaround::UInt64
    report_id::Cuint
end

function av_jni_set_java_vm(vm, log_ctx)
    ccall((:av_jni_set_java_vm, libavcodec), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), vm, log_ctx)
end

function av_jni_get_java_vm(log_ctx)
    ccall((:av_jni_get_java_vm, libavcodec), Ptr{Cvoid}, (Ptr{Cvoid},), log_ctx)
end

"""
    AVMediaCodecContext

This structure holds a reference to a android/view/Surface object that will be used as output by the decoder.
"""
struct AVMediaCodecContext
    surface::Ptr{Cvoid}
end

"""
    av_mediacodec_alloc_context()

Allocate and initialize a MediaCodec context.

When decoding with MediaCodec is finished, the caller must free the MediaCodec context with [`av_mediacodec_default_free`](@ref).

### Returns
a pointer to a newly allocated [`AVMediaCodecContext`](@ref) on success, NULL otherwise
"""
function av_mediacodec_alloc_context()
    ccall((:av_mediacodec_alloc_context, libavcodec), Ptr{AVMediaCodecContext}, ())
end

"""
    av_mediacodec_default_init(avctx, ctx, surface)

Convenience function that sets up the MediaCodec context.

### Parameters
* `avctx`: codec context 

* `ctx`: MediaCodec context to initialize 

* `surface`: reference to an android/view/Surface 

### Returns
0 on success, < 0 otherwise
"""
function av_mediacodec_default_init(avctx, ctx, surface)
    ccall((:av_mediacodec_default_init, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVMediaCodecContext}, Ptr{Cvoid}), avctx, ctx, surface)
end

"""
    av_mediacodec_default_free(avctx)

This function must be called to free the MediaCodec context initialized with [`av_mediacodec_default_init`](@ref)().

### Parameters
* `avctx`: codec context
"""
function av_mediacodec_default_free(avctx)
    ccall((:av_mediacodec_default_free, libavcodec), Cvoid, (Ptr{AVCodecContext},), avctx)
end

mutable struct MediaCodecBuffer end

"""
Opaque structure representing a MediaCodec buffer to render.
"""
const AVMediaCodecBuffer = MediaCodecBuffer

"""
    av_mediacodec_release_buffer(buffer, render::Integer)

Release a MediaCodec buffer and render it to the surface that is associated with the decoder. This function should only be called once on a given buffer, once released the underlying buffer returns to the codec, thus subsequent calls to this function will have no effect.

### Parameters
* `buffer`: the buffer to render 

* `render`: 1 to release and render the buffer to the surface or 0 to discard the buffer 

### Returns
0 on success, < 0 otherwise
"""
function av_mediacodec_release_buffer(buffer, render::Integer)
    ccall((:av_mediacodec_release_buffer, libavcodec), Cint, (Ptr{AVMediaCodecBuffer}, Cint), buffer, render)
end

"""
    av_mediacodec_render_buffer_at_time(buffer, time::Int64)

Release a MediaCodec buffer and render it at the given time to the surface that is associated with the decoder. The timestamp must be within one second of the current java/lang/System#nanoTime() (which is implemented using CLOCK\\_MONOTONIC on Android). See the Android MediaCodec documentation of android/media/MediaCodec#releaseOutputBuffer(int,long) for more details.

### Parameters
* `buffer`: the buffer to render 

* `time`: timestamp in nanoseconds of when to render the buffer 

### Returns
0 on success, < 0 otherwise
"""
function av_mediacodec_render_buffer_at_time(buffer, time::Int64)
    ccall((:av_mediacodec_render_buffer_at_time, libavcodec), Cint, (Ptr{AVMediaCodecBuffer}, Int64), buffer, time)
end

struct AVPacketList
    pkt::AVPacket
    next::Ptr{AVPacketList}
end

const AVSideDataParamChangeFlags = UInt32
const AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1 % UInt32
const AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2 % UInt32
const AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4 % UInt32
const AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8 % UInt32

"""
    av_packet_alloc()

Allocate an [`AVPacket`](@ref) and set its fields to default values. The resulting struct must be freed using [`av_packet_free`](@ref)().

!!! note

    this only allocates the [`AVPacket`](@ref) itself, not the data buffers. Those must be allocated through other means such as [`av_new_packet`](@ref).

### Returns
An [`AVPacket`](@ref) filled with default values or NULL on failure.

### See also
[`av_new_packet`](@ref)
"""
function av_packet_alloc()
    ccall((:av_packet_alloc, libavcodec), Ptr{AVPacket}, ())
end

"""
    av_packet_clone(src)

Create a new packet that references the same data as src.

This is a shortcut for [`av_packet_alloc`](@ref)()+[`av_packet_ref`](@ref)().

### Returns
newly created [`AVPacket`](@ref) on success, NULL on error.

### See also
[`av_packet_alloc`](@ref), [`av_packet_ref`](@ref)
"""
function av_packet_clone(src)
    ccall((:av_packet_clone, libavcodec), Ptr{AVPacket}, (Ptr{AVPacket},), src)
end

"""
    av_packet_free(pkt)

Free the packet, if the packet is reference counted, it will be unreferenced first.

!!! note

    passing NULL is a no-op.

### Parameters
* `pkt`: packet to be freed. The pointer will be set to NULL. 
"""
function av_packet_free(pkt)
    ccall((:av_packet_free, libavcodec), Cvoid, (Ptr{Ptr{AVPacket}},), pkt)
end

"""
    av_init_packet(pkt)

Initialize optional fields of a packet with default values.

Note, this does not touch the data and size members, which have to be initialized separately.

\\deprecated This function is deprecated. Once it's removed, sizeof([`AVPacket`](@ref)) will not be a part of the ABI anymore.

### Parameters
* `pkt`: packet

### See also
[`av_packet_alloc`](@ref), [`av_packet_unref`](@ref)
"""
function av_init_packet(pkt)
    ccall((:av_init_packet, libavcodec), Cvoid, (Ptr{AVPacket},), pkt)
end

"""
    av_new_packet(pkt, size::Integer)

Allocate the payload of a packet and initialize its fields with default values.

### Parameters
* `pkt`: packet 

* `size`: wanted payload size 

### Returns
0 if OK, AVERROR\\_xxx otherwise
"""
function av_new_packet(pkt, size::Integer)
    ccall((:av_new_packet, libavcodec), Cint, (Ptr{AVPacket}, Cint), pkt, size)
end

"""
    av_shrink_packet(pkt, size::Integer)

Reduce packet size, correctly zeroing padding

### Parameters
* `pkt`: packet 

* `size`: new size
"""
function av_shrink_packet(pkt, size::Integer)
    ccall((:av_shrink_packet, libavcodec), Cvoid, (Ptr{AVPacket}, Cint), pkt, size)
end

"""
    av_grow_packet(pkt, grow_by::Integer)

Increase packet size, correctly zeroing padding

### Parameters
* `pkt`: packet 

* `grow_by`: number of bytes by which to increase the size of the packet
"""
function av_grow_packet(pkt, grow_by::Integer)
    ccall((:av_grow_packet, libavcodec), Cint, (Ptr{AVPacket}, Cint), pkt, grow_by)
end

"""
    av_packet_from_data(pkt, data, size::Integer)

Initialize a reference-counted packet from [`av_malloc`](@ref)()ed data.

### Parameters
* `pkt`: packet to be initialized. This function will set the data, size, and buf fields, all others are left untouched. 

* `data`: Data allocated by [`av_malloc`](@ref)() to be used as packet data. If this function returns successfully, the data is owned by the underlying [`AVBuffer`](@ref). The caller may not access the data through other means. 

* `size`: size of data in bytes, without the padding. I.e. the full buffer size is assumed to be size + [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref).

### Returns
0 on success, a negative [`AVERROR`](@ref) on error
"""
function av_packet_from_data(pkt, data, size::Integer)
    ccall((:av_packet_from_data, libavcodec), Cint, (Ptr{AVPacket}, Ptr{UInt8}, Cint), pkt, data, size)
end

"""
    av_dup_packet(pkt)

!!! warning

    This is a hack - the packet memory allocation stuff is broken. The packet is allocated if it was not really allocated.

\\deprecated Use [`av_packet_ref`](@ref) or [`av_packet_make_refcounted`](@ref)
"""
function av_dup_packet(pkt)
    ccall((:av_dup_packet, libavcodec), Cint, (Ptr{AVPacket},), pkt)
end

"""
    av_copy_packet(dst, src)

Copy packet, including contents

\\deprecated Use [`av_packet_ref`](@ref)

### Returns
0 on success, negative [`AVERROR`](@ref) on fail
"""
function av_copy_packet(dst, src)
    ccall((:av_copy_packet, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
end

"""
    av_copy_packet_side_data(dst, src)

Copy packet side data

\\deprecated Use [`av_packet_copy_props`](@ref)

### Returns
0 on success, negative [`AVERROR`](@ref) on fail
"""
function av_copy_packet_side_data(dst, src)
    ccall((:av_copy_packet_side_data, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
end

"""
    av_free_packet(pkt)

Free a packet.

\\deprecated Use [`av_packet_unref`](@ref)

### Parameters
* `pkt`: packet to free
"""
function av_free_packet(pkt)
    ccall((:av_free_packet, libavcodec), Cvoid, (Ptr{AVPacket},), pkt)
end

"""
    av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Integer)

Allocate new information of a packet.

### Parameters
* `pkt`: packet 

* `type`: side information type 

* `size`: side information size 

### Returns
pointer to fresh allocated data or NULL otherwise
"""
function av_packet_new_side_data(pkt, type::AVPacketSideDataType, size::Integer)
    ccall((:av_packet_new_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Cint), pkt, type, size)
end

"""
    av_packet_add_side_data(pkt, type::AVPacketSideDataType, data, size::Csize_t)

Wrap an existing array as a packet side data.

### Parameters
* `pkt`: packet 

* `type`: side information type 

* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to pkt. 

* `size`: side information size 

### Returns
a non-negative number on success, a negative [`AVERROR`](@ref) code on failure. On failure, the packet is unchanged and the data remains owned by the caller.
"""
function av_packet_add_side_data(pkt, type::AVPacketSideDataType, data, size::Csize_t)
    ccall((:av_packet_add_side_data, libavcodec), Cint, (Ptr{AVPacket}, AVPacketSideDataType, Ptr{UInt8}, Csize_t), pkt, type, data, size)
end

"""
    av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Integer)

Shrink the already allocated side data buffer

### Parameters
* `pkt`: packet 

* `type`: side information type 

* `size`: new side information size 

### Returns
0 on success, < 0 on failure
"""
function av_packet_shrink_side_data(pkt, type::AVPacketSideDataType, size::Integer)
    ccall((:av_packet_shrink_side_data, libavcodec), Cint, (Ptr{AVPacket}, AVPacketSideDataType, Cint), pkt, type, size)
end

"""
    av_packet_get_side_data(pkt, type::AVPacketSideDataType, size)

Get side information from packet.

### Parameters
* `pkt`: packet 

* `type`: desired side information type 

* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present. 

### Returns
pointer to data if present or NULL otherwise
"""
function av_packet_get_side_data(pkt, type::AVPacketSideDataType, size)
    ccall((:av_packet_get_side_data, libavcodec), Ptr{UInt8}, (Ptr{AVPacket}, AVPacketSideDataType, Ptr{Cint}), pkt, type, size)
end

function av_packet_merge_side_data(pkt)
    ccall((:av_packet_merge_side_data, libavcodec), Cint, (Ptr{AVPacket},), pkt)
end

function av_packet_split_side_data(pkt)
    ccall((:av_packet_split_side_data, libavcodec), Cint, (Ptr{AVPacket},), pkt)
end

function av_packet_side_data_name(type::AVPacketSideDataType)
    ccall((:av_packet_side_data_name, libavcodec), Cstring, (AVPacketSideDataType,), type)
end

function av_packet_pack_dictionary(dict, size)
    ccall((:av_packet_pack_dictionary, libavcodec), Ptr{UInt8}, (Ptr{AVDictionary}, Ptr{Cint}), dict, size)
end

function av_packet_unpack_dictionary(data, size::Integer, dict)
    ccall((:av_packet_unpack_dictionary, libavcodec), Cint, (Ptr{UInt8}, Cint, Ptr{Ptr{AVDictionary}}), data, size, dict)
end

"""
    av_packet_free_side_data(pkt)

Convenience function to free all the side data stored. All the other fields stay untouched.

### Parameters
* `pkt`: packet
"""
function av_packet_free_side_data(pkt)
    ccall((:av_packet_free_side_data, libavcodec), Cvoid, (Ptr{AVPacket},), pkt)
end

"""
    av_packet_ref(dst, src)

Setup a new reference to the data described by a given packet

If src is reference-counted, setup dst as a new reference to the buffer in src. Otherwise allocate a new buffer in dst and copy the data from src into it.

All the other fields are copied from src.

### Parameters
* `dst`: Destination packet. Will be completely overwritten. 

* `src`: Source packet

### Returns
0 on success, a negative [`AVERROR`](@ref) on error. On error, dst will be blank (as if returned by [`av_packet_alloc`](@ref)()).

### See also
[`av_packet_unref`](@ref)
"""
function av_packet_ref(dst, src)
    ccall((:av_packet_ref, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
end

"""
    av_packet_unref(pkt)

Wipe the packet.

Unreference the buffer referenced by the packet and reset the remaining packet fields to their default values.

### Parameters
* `pkt`: The packet to be unreferenced.
"""
function av_packet_unref(pkt)
    ccall((:av_packet_unref, libavcodec), Cvoid, (Ptr{AVPacket},), pkt)
end

"""
    av_packet_move_ref(dst, src)

Move every field in src to dst and reset src.

### Parameters
* `src`: Source packet, will be reset 

* `dst`: Destination packet

### See also
[`av_packet_unref`](@ref)
"""
function av_packet_move_ref(dst, src)
    ccall((:av_packet_move_ref, libavcodec), Cvoid, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
end

"""
    av_packet_copy_props(dst, src)

Copy only "properties" fields from src to dst.

Properties for the purpose of this function are all the fields beside those related to the packet data (buf, data, size)

### Parameters
* `dst`: Destination packet 

* `src`: Source packet

### Returns
0 on success [`AVERROR`](@ref) on failure.
"""
function av_packet_copy_props(dst, src)
    ccall((:av_packet_copy_props, libavcodec), Cint, (Ptr{AVPacket}, Ptr{AVPacket}), dst, src)
end

"""
    av_packet_make_refcounted(pkt)

Ensure the data described by a given packet is reference counted.

!!! note

    This function does not ensure that the reference will be writable. Use [`av_packet_make_writable`](@ref) instead for that purpose.

### Parameters
* `pkt`: packet whose data should be made reference counted.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error. On failure, the packet is unchanged.

### See also
[`av_packet_ref`](@ref), [`av_packet_make_writable`](@ref)
"""
function av_packet_make_refcounted(pkt)
    ccall((:av_packet_make_refcounted, libavcodec), Cint, (Ptr{AVPacket},), pkt)
end

"""
    av_packet_make_writable(pkt)

Create a writable reference for the data described by a given packet, avoiding data copy if possible.

### Parameters
* `pkt`: Packet whose data should be made writable.

### Returns
0 on success, a negative [`AVERROR`](@ref) on failure. On failure, the packet is unchanged.
"""
function av_packet_make_writable(pkt)
    ccall((:av_packet_make_writable, libavcodec), Cint, (Ptr{AVPacket},), pkt)
end

"""
    av_packet_rescale_ts(pkt, tb_src::AVRational, tb_dst::AVRational)

Convert valid timing fields (timestamps / durations) in a packet from one timebase to another. Timestamps with unknown values ([`AV_NOPTS_VALUE`](@ref)) will be ignored.

### Parameters
* `pkt`: packet on which the conversion will be performed 

* `tb_src`: source timebase, in which the timing fields in pkt are expressed 

* `tb_dst`: destination timebase, to which the timing fields will be converted
"""
function av_packet_rescale_ts(pkt, tb_src::AVRational, tb_dst::AVRational)
    ccall((:av_packet_rescale_ts, libavcodec), Cvoid, (Ptr{AVPacket}, AVRational, AVRational), pkt, tb_src, tb_dst)
end

struct AVQSVContext
    session::Cint
    iopattern::Cint
    ext_buffers::Ptr{Ptr{Cint}}
    nb_ext_buffers::Cint
    opaque_alloc::Cint
    nb_opaque_surfaces::Cint
    opaque_surfaces::Ptr{AVBufferRef}
    opaque_alloc_type::Cint
end

"""
    av_qsv_alloc_context()

Allocate a new context.

It must be freed by the caller with [`av_free`](@ref)().
"""
function av_qsv_alloc_context()
    ccall((:av_qsv_alloc_context, libavcodec), Ptr{AVQSVContext}, ())
end

"""
    vaapi_context

This structure is used to share data between the FFmpeg library and the client video application. This shall be zero-allocated and available as [`AVCodecContext`](@ref).hwaccel\\_context. All user members can be set once during initialization or through each [`AVCodecContext`](@ref).get\\_buffer() function call. In any case, they must be valid prior to calling decoding functions.

Deprecated: use [`AVCodecContext`](@ref).hw\\_frames\\_ctx instead.
"""
struct vaapi_context
    data::NTuple{16, UInt8}
end

function Base.getproperty(x::Ptr{vaapi_context}, f::Symbol)
    f === :display && return Ptr{Ptr{Cvoid}}(x + 0)
    f === :config_id && return Ptr{UInt32}(x + 8)
    f === :context_id && return Ptr{UInt32}(x + 12)
    return getfield(x, f)
end

function Base.getproperty(x::vaapi_context, f::Symbol)
    r = Ref{vaapi_context}(x)
    ptr = Base.unsafe_convert(Ptr{vaapi_context}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{vaapi_context}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

# typedef int ( * AVVDPAU_Render2 ) ( struct AVCodecContext * , struct AVFrame * , const VdpPictureInfo * , uint32_t , const VdpBitstreamBuffer * )
const AVVDPAU_Render2 = Ptr{Cvoid}

"""
    AVVDPAUContext

This structure is used to share data between the libavcodec library and the client video application. The user shall allocate the structure via the av\\_alloc\\_vdpau\\_hwaccel function and make it available as [`AVCodecContext`](@ref).hwaccel\\_context. Members can be set by the user once during initialization or through each [`AVCodecContext`](@ref).get\\_buffer() function call. In any case, they must be valid prior to calling decoding functions.

The size of this structure is not a part of the public ABI and must not be used outside of libavcodec. Use [`av_vdpau_alloc_context`](@ref)() to allocate an [`AVVDPAUContext`](@ref).
"""
struct AVVDPAUContext
    decoder::VdpDecoder
    render::Ptr{Cvoid}
    render2::AVVDPAU_Render2
end

"""
    av_alloc_vdpaucontext()

allocation function for [`AVVDPAUContext`](@ref)

Allows extending the struct without breaking API/ABI
"""
function av_alloc_vdpaucontext()
    ccall((:av_alloc_vdpaucontext, libavcodec), Ptr{AVVDPAUContext}, ())
end

function av_vdpau_hwaccel_get_render2(arg1)
    ccall((:av_vdpau_hwaccel_get_render2, libavcodec), AVVDPAU_Render2, (Ptr{AVVDPAUContext},), arg1)
end

function av_vdpau_hwaccel_set_render2(arg1, arg2::AVVDPAU_Render2)
    ccall((:av_vdpau_hwaccel_set_render2, libavcodec), Cvoid, (Ptr{AVVDPAUContext}, AVVDPAU_Render2), arg1, arg2)
end

"""
    av_vdpau_bind_context(avctx, device::VdpDevice, get_proc_address, flags::Integer)

Associate a VDPAU device with a codec context for hardware acceleration. This function is meant to be called from the get\\_format() codec callback, or earlier. It can also be called after [`avcodec_flush_buffers`](@ref)() to change the underlying VDPAU device mid-stream (e.g. to recover from non-transparent display preemption).

!!! note

    get\\_format() must return AV\\_PIX\\_FMT\\_VDPAU if this function completes successfully.

### Parameters
* `avctx`: decoding context whose get\\_format() callback is invoked 

* `device`: VDPAU device handle to use for hardware acceleration 

* `get_proc_address`: VDPAU device driver 

* `flags`: zero of more OR'd AV\\_HWACCEL\\_FLAG\\_* flags

### Returns
0 on success, an [`AVERROR`](@ref) code on failure.
"""
function av_vdpau_bind_context(avctx, device::VdpDevice, get_proc_address, flags::Integer)
    ccall((:av_vdpau_bind_context, libavcodec), Cint, (Ptr{AVCodecContext}, VdpDevice, Ptr{Cvoid}, Cuint), avctx, device, get_proc_address, flags)
end

"""
    av_vdpau_get_surface_parameters(avctx, type, width, height)

Gets the parameters to create an adequate VDPAU video surface for the codec context using VDPAU hardware decoding acceleration.

!!! note

    Behavior is undefined if the context was not successfully bound to a VDPAU device using [`av_vdpau_bind_context`](@ref)().

### Parameters
* `avctx`: the codec context being used for decoding the stream 

* `type`: storage space for the VDPAU video surface chroma type (or NULL to ignore) 

* `width`: storage space for the VDPAU video surface pixel width (or NULL to ignore) 

* `height`: storage space for the VDPAU video surface pixel height (or NULL to ignore)

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_vdpau_get_surface_parameters(avctx, type, width, height)
    ccall((:av_vdpau_get_surface_parameters, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{VdpChromaType}, Ptr{UInt32}, Ptr{UInt32}), avctx, type, width, height)
end

"""
    av_vdpau_alloc_context()

Allocate an [`AVVDPAUContext`](@ref).

### Returns
Newly-allocated [`AVVDPAUContext`](@ref) or NULL on failure.
"""
function av_vdpau_alloc_context()
    ccall((:av_vdpau_alloc_context, libavcodec), Ptr{AVVDPAUContext}, ())
end

"""
    av_vdpau_get_profile(avctx, profile)

Get a decoder profile that should be used for initializing a VDPAU decoder. Should be called from the [`AVCodecContext`](@ref).get\\_format() callback.

\\deprecated Use [`av_vdpau_bind_context`](@ref)() instead.

### Parameters
* `avctx`: the codec context being used for decoding the stream 

* `profile`: a pointer into which the result will be written on success. The contents of profile are undefined if this function returns an error.

### Returns
0 on success (non-negative), a negative [`AVERROR`](@ref) on failure.
"""
function av_vdpau_get_profile(avctx, profile)
    ccall((:av_vdpau_get_profile, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{VdpDecoderProfile}), avctx, profile)
end

struct AVVideotoolboxContext
    session::Cint
    output_callback::Cint
    cv_pix_fmt_type::Cint
    cm_fmt_desc::Cint
    cm_codec_type::Cint
end

"""
    av_videotoolbox_alloc_context()

Allocate and initialize a Videotoolbox context.

This function should be called from the get\\_format() callback when the caller selects the AV\\_PIX\\_FMT\\_VIDETOOLBOX format. The caller must then create the decoder object (using the output callback provided by libavcodec) that will be used for Videotoolbox-accelerated decoding.

When decoding with Videotoolbox is finished, the caller must destroy the decoder object and free the Videotoolbox context using [`av_free`](@ref)().

### Returns
the newly allocated context or NULL on failure
"""
function av_videotoolbox_alloc_context()
    ccall((:av_videotoolbox_alloc_context, libavcodec), Ptr{AVVideotoolboxContext}, ())
end

"""
    av_videotoolbox_default_init(avctx)

This is a convenience function that creates and sets up the Videotoolbox context using an internal implementation.

### Parameters
* `avctx`: the corresponding codec context

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_videotoolbox_default_init(avctx)
    ccall((:av_videotoolbox_default_init, libavcodec), Cint, (Ptr{AVCodecContext},), avctx)
end

"""
    av_videotoolbox_default_init2(avctx, vtctx)

This is a convenience function that creates and sets up the Videotoolbox context using an internal implementation.

### Parameters
* `avctx`: the corresponding codec context 

* `vtctx`: the Videotoolbox context to use

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_videotoolbox_default_init2(avctx, vtctx)
    ccall((:av_videotoolbox_default_init2, libavcodec), Cint, (Ptr{AVCodecContext}, Ptr{AVVideotoolboxContext}), avctx, vtctx)
end

"""
    av_videotoolbox_default_free(avctx)

This function must be called to free the Videotoolbox context initialized with [`av_videotoolbox_default_init`](@ref)().

### Parameters
* `avctx`: the corresponding codec context
"""
function av_videotoolbox_default_free(avctx)
    ccall((:av_videotoolbox_default_free, libavcodec), Cvoid, (Ptr{AVCodecContext},), avctx)
end

mutable struct AVVorbisParseContext end

"""
    av_vorbis_parse_init(extradata, extradata_size::Integer)

Allocate and initialize the Vorbis parser using headers in the extradata.
"""
function av_vorbis_parse_init(extradata, extradata_size::Integer)
    ccall((:av_vorbis_parse_init, libavcodec), Ptr{AVVorbisParseContext}, (Ptr{UInt8}, Cint), extradata, extradata_size)
end

"""
    av_vorbis_parse_free(s)

Free the parser and everything associated with it.
"""
function av_vorbis_parse_free(s)
    ccall((:av_vorbis_parse_free, libavcodec), Cvoid, (Ptr{Ptr{AVVorbisParseContext}},), s)
end

"""
    av_vorbis_parse_frame_flags(s, buf, buf_size::Integer, flags)

Get the duration for a Vorbis packet.

If `flags` is `NULL`, special frames are considered invalid.

### Parameters
* `s`: Vorbis parser context 

* `buf`: buffer containing a Vorbis frame 

* `buf_size`: size of the buffer 

* `flags`: flags for special frames
"""
function av_vorbis_parse_frame_flags(s, buf, buf_size::Integer, flags)
    ccall((:av_vorbis_parse_frame_flags, libavcodec), Cint, (Ptr{AVVorbisParseContext}, Ptr{UInt8}, Cint, Ptr{Cint}), s, buf, buf_size, flags)
end

"""
    av_vorbis_parse_frame(s, buf, buf_size::Integer)

Get the duration for a Vorbis packet.

### Parameters
* `s`: Vorbis parser context 

* `buf`: buffer containing a Vorbis frame 

* `buf_size`: size of the buffer
"""
function av_vorbis_parse_frame(s, buf, buf_size::Integer)
    ccall((:av_vorbis_parse_frame, libavcodec), Cint, (Ptr{AVVorbisParseContext}, Ptr{UInt8}, Cint), s, buf, buf_size)
end

function av_vorbis_parse_reset(s)
    ccall((:av_vorbis_parse_reset, libavcodec), Cvoid, (Ptr{AVVorbisParseContext},), s)
end

struct xvmc_pix_fmt
    data::NTuple{1, UInt8}
end

function Base.getproperty(x::Ptr{xvmc_pix_fmt}, f::Symbol)
    f === :xvmc_id && return Ptr{Cint}(x + 0)
    f === :data_blocks && return Ptr{Ptr{Cshort}}(x + 0)
    f === :mv_blocks && return Ptr{Ptr{Cint}}(x + 0)
    f === :allocated_mv_blocks && return Ptr{Cint}(x + 0)
    f === :allocated_data_blocks && return Ptr{Cint}(x + 0)
    f === :idct && return Ptr{Cint}(x + 0)
    f === :unsigned_intra && return Ptr{Cint}(x + 0)
    f === :p_surface && return Ptr{Ptr{Cint}}(x + 0)
    f === :p_past_surface && return Ptr{Ptr{Cint}}(x + 0)
    f === :p_future_surface && return Ptr{Ptr{Cint}}(x + 0)
    f === :picture_structure && return Ptr{Cuint}(x + 0)
    f === :flags && return Ptr{Cuint}(x + 0)
    f === :start_mv_blocks_num && return Ptr{Cint}(x + 0)
    f === :filled_mv_blocks_num && return Ptr{Cint}(x + 0)
    f === :next_free_data_block_num && return Ptr{Cint}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::xvmc_pix_fmt, f::Symbol)
    r = Ref{xvmc_pix_fmt}(x)
    ptr = Base.unsafe_convert(Ptr{xvmc_pix_fmt}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{xvmc_pix_fmt}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    avdevice_version()

Return the [`LIBAVDEVICE_VERSION_INT`](@ref) constant.
"""
function avdevice_version()
    ccall((:avdevice_version, libavdevice), Cuint, ())
end

"""
    avdevice_configuration()

Return the libavdevice build-time configuration.
"""
function avdevice_configuration()
    ccall((:avdevice_configuration, libavdevice), Cstring, ())
end

"""
    avdevice_license()

Return the libavdevice license.
"""
function avdevice_license()
    ccall((:avdevice_license, libavdevice), Cstring, ())
end

"""
    avdevice_register_all()

Initialize libavdevice and register all the input and output devices.
"""
function avdevice_register_all()
    ccall((:avdevice_register_all, libavdevice), Cvoid, ())
end

"""
**********************************************
"""
mutable struct AVCodecTag end

"""
    AVInputFormat

` lavf_decoding`

@{
"""
struct AVInputFormat
    name::Cstring
    long_name::Cstring
    flags::Cint
    extensions::Cstring
    codec_tag::Ptr{Ptr{AVCodecTag}}
    priv_class::Ptr{AVClass}
    mime_type::Cstring
    next::Ptr{AVInputFormat}
    raw_codec_id::Cint
    priv_data_size::Cint
    read_probe::Ptr{Cvoid}
    read_header::Ptr{Cvoid}
    read_packet::Ptr{Cvoid}
    read_close::Ptr{Cvoid}
    read_seek::Ptr{Cvoid}
    read_timestamp::Ptr{Cvoid}
    read_play::Ptr{Cvoid}
    read_pause::Ptr{Cvoid}
    read_seek2::Ptr{Cvoid}
    get_device_list::Ptr{Cvoid}
    create_device_capabilities::Ptr{Cvoid}
    free_device_capabilities::Ptr{Cvoid}
end

"""
    av_input_audio_device_next(d)

Audio input devices iterator.

If d is NULL, returns the first registered input audio/video device, if d is non-NULL, returns the next registered input audio/video device after d or NULL if d is the last one.
"""
function av_input_audio_device_next(d)
    ccall((:av_input_audio_device_next, libavdevice), Ptr{AVInputFormat}, (Ptr{AVInputFormat},), d)
end

"""
    av_input_video_device_next(d)

Video input devices iterator.

If d is NULL, returns the first registered input audio/video device, if d is non-NULL, returns the next registered input audio/video device after d or NULL if d is the last one.
"""
function av_input_video_device_next(d)
    ccall((:av_input_video_device_next, libavdevice), Ptr{AVInputFormat}, (Ptr{AVInputFormat},), d)
end

"""
    AVOutputFormat

` lavf_encoding`

@{
"""
struct AVOutputFormat
    name::Cstring
    long_name::Cstring
    mime_type::Cstring
    extensions::Cstring
    audio_codec::AVCodecID
    video_codec::AVCodecID
    subtitle_codec::AVCodecID
    flags::Cint
    codec_tag::Ptr{Ptr{AVCodecTag}}
    priv_class::Ptr{AVClass}
    next::Ptr{AVOutputFormat}
    priv_data_size::Cint
    write_header::Ptr{Cvoid}
    write_packet::Ptr{Cvoid}
    write_trailer::Ptr{Cvoid}
    interleave_packet::Ptr{Cvoid}
    query_codec::Ptr{Cvoid}
    get_output_timestamp::Ptr{Cvoid}
    control_message::Ptr{Cvoid}
    write_uncoded_frame::Ptr{Cvoid}
    get_device_list::Ptr{Cvoid}
    create_device_capabilities::Ptr{Cvoid}
    free_device_capabilities::Ptr{Cvoid}
    data_codec::AVCodecID
    init::Ptr{Cvoid}
    deinit::Ptr{Cvoid}
    check_bitstream::Ptr{Cvoid}
end

"""
    av_output_audio_device_next(d)

Audio output devices iterator.

If d is NULL, returns the first registered output audio/video device, if d is non-NULL, returns the next registered output audio/video device after d or NULL if d is the last one.
"""
function av_output_audio_device_next(d)
    ccall((:av_output_audio_device_next, libavdevice), Ptr{AVOutputFormat}, (Ptr{AVOutputFormat},), d)
end

"""
    av_output_video_device_next(d)

Video output devices iterator.

If d is NULL, returns the first registered output audio/video device, if d is non-NULL, returns the next registered output audio/video device after d or NULL if d is the last one.
"""
function av_output_video_device_next(d)
    ccall((:av_output_video_device_next, libavdevice), Ptr{AVOutputFormat}, (Ptr{AVOutputFormat},), d)
end

struct AVDeviceRect
    x::Cint
    y::Cint
    width::Cint
    height::Cint
end

"""
    AVAppToDevMessageType

Message types used by [`avdevice_app_to_dev_control_message`](@ref)().
"""
const AVAppToDevMessageType = UInt32
const AV_APP_TO_DEV_NONE = 1313820229 % UInt32
const AV_APP_TO_DEV_WINDOW_SIZE = 1195724621 % UInt32
const AV_APP_TO_DEV_WINDOW_REPAINT = 1380274241 % UInt32
const AV_APP_TO_DEV_PAUSE = 1346458912 % UInt32
const AV_APP_TO_DEV_PLAY = 1347174745 % UInt32
const AV_APP_TO_DEV_TOGGLE_PAUSE = 1346458964 % UInt32
const AV_APP_TO_DEV_SET_VOLUME = 1398165324 % UInt32
const AV_APP_TO_DEV_MUTE = 541939028 % UInt32
const AV_APP_TO_DEV_UNMUTE = 1431131476 % UInt32
const AV_APP_TO_DEV_TOGGLE_MUTE = 1414354260 % UInt32
const AV_APP_TO_DEV_GET_VOLUME = 1196838732 % UInt32
const AV_APP_TO_DEV_GET_MUTE = 1196250452 % UInt32

"""
    AVDevToAppMessageType

Message types used by [`avdevice_dev_to_app_control_message`](@ref)().
"""
const AVDevToAppMessageType = UInt32
const AV_DEV_TO_APP_NONE = 1313820229 % UInt32
const AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = 1111708229 % UInt32
const AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = 1112560197 % UInt32
const AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = 1111771475 % UInt32
const AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = 1111770451 % UInt32
const AV_DEV_TO_APP_BUFFER_OVERFLOW = 1112491596 % UInt32
const AV_DEV_TO_APP_BUFFER_UNDERFLOW = 1112884812 % UInt32
const AV_DEV_TO_APP_BUFFER_READABLE = 1112687648 % UInt32
const AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912 % UInt32
const AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588 % UInt32
const AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868 % UInt32

"""
    AVIODataMarkerType

Different data types that can be returned via the AVIO write\\_data\\_type callback.
"""
const AVIODataMarkerType = UInt32
const AVIO_DATA_MARKER_HEADER = 0 % UInt32
const AVIO_DATA_MARKER_SYNC_POINT = 1 % UInt32
const AVIO_DATA_MARKER_BOUNDARY_POINT = 2 % UInt32
const AVIO_DATA_MARKER_UNKNOWN = 3 % UInt32
const AVIO_DATA_MARKER_TRAILER = 4 % UInt32
const AVIO_DATA_MARKER_FLUSH_POINT = 5 % UInt32

"""
    AVIOContext

Bytestream IO Context. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVIOContext`](@ref)) must not be used outside libav*.

!!! note

    None of the function pointers in [`AVIOContext`](@ref) should be called directly, they should only be set by the client application when implementing custom I/O. Normally these are set to the function pointers specified in [`avio_alloc_context`](@ref)()
"""
struct AVIOContext
    av_class::Ptr{AVClass}
    buffer::Ptr{Cuchar}
    buffer_size::Cint
    buf_ptr::Ptr{Cuchar}
    buf_end::Ptr{Cuchar}
    opaque::Ptr{Cvoid}
    read_packet::Ptr{Cvoid}
    write_packet::Ptr{Cvoid}
    seek::Ptr{Cvoid}
    pos::Int64
    eof_reached::Cint
    write_flag::Cint
    max_packet_size::Cint
    checksum::Culong
    checksum_ptr::Ptr{Cuchar}
    update_checksum::Ptr{Cvoid}
    error::Cint
    read_pause::Ptr{Cvoid}
    read_seek::Ptr{Cvoid}
    seekable::Cint
    maxsize::Int64
    direct::Cint
    bytes_read::Int64
    seek_count::Cint
    writeout_count::Cint
    orig_buffer_size::Cint
    short_seek_threshold::Cint
    protocol_whitelist::Cstring
    protocol_blacklist::Cstring
    write_data_type::Ptr{Cvoid}
    ignore_boundary_point::Cint
    current_type::AVIODataMarkerType
    last_time::Int64
    short_seek_get::Ptr{Cvoid}
    written::Int64
    buf_ptr_max::Ptr{Cuchar}
    min_packet_size::Cint
end

"""
    AVStreamParseType

@}
"""
const AVStreamParseType = UInt32
const AVSTREAM_PARSE_NONE = 0 % UInt32
const AVSTREAM_PARSE_FULL = 1 % UInt32
const AVSTREAM_PARSE_HEADERS = 2 % UInt32
const AVSTREAM_PARSE_TIMESTAMPS = 3 % UInt32
const AVSTREAM_PARSE_FULL_ONCE = 4 % UInt32
const AVSTREAM_PARSE_FULL_RAW = 5 % UInt32

"""
    AVProbeData

This structure contains the data a format has to probe a file.
"""
struct AVProbeData
    filename::Cstring
    buf::Ptr{Cuchar}
    buf_size::Cint
    mime_type::Cstring
end

struct AVIndexEntry
    data::NTuple{24, UInt8}
end

function Base.getproperty(x::Ptr{AVIndexEntry}, f::Symbol)
    f === :pos && return Ptr{Int64}(x + 0)
    f === :timestamp && return Ptr{Int64}(x + 8)
    f === :flags && return (Ptr{Cint}(x + 16), 0, 2)
    f === :size && return (Ptr{Cint}(x + 16), 2, 30)
    f === :min_distance && return Ptr{Cint}(x + 20)
    return getfield(x, f)
end

function Base.getproperty(x::AVIndexEntry, f::Symbol)
    r = Ref{AVIndexEntry}(x)
    ptr = Base.unsafe_convert(Ptr{AVIndexEntry}, r)
    fptr = getproperty(ptr, f)
    begin
        if fptr isa Ptr
            return GC.@preserve(r, unsafe_load(fptr))
        else
            (baseptr, offset, width) = fptr
            ty = eltype(baseptr)
            baseptr32 = convert(Ptr{UInt32}, baseptr)
            u64 = GC.@preserve(r, unsafe_load(baseptr32))
            if offset + width > 32
                u64 |= GC.@preserve(r, unsafe_load(baseptr32 + 4)) << 32
            end
            u64 = u64 >> offset & (1 << width - 1)
            return u64 % ty
        end
    end
end

function Base.setproperty!(x::Ptr{AVIndexEntry}, f::Symbol, v)
    fptr = getproperty(x, f)
    if fptr isa Ptr
        unsafe_store!(getproperty(x, f), v)
    else
        (baseptr, offset, width) = fptr
        baseptr32 = convert(Ptr{UInt32}, baseptr)
        u64 = unsafe_load(baseptr32)
        straddle = offset + width > 32
        if straddle
            u64 |= unsafe_load(baseptr32 + 4) << 32
        end
        mask = 1 << width - 1
        u64 &= ~(mask << offset)
        u64 |= (unsigned(v) & mask) << offset
        unsafe_store!(baseptr32, u64 & typemax(UInt32))
        if straddle
            unsafe_store!(baseptr32 + 4, u64 >> 32)
        end
    end
end

mutable struct AVStreamInternal end

"""
    AVStream

Stream structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVStream`](@ref)) must not be used outside libav*.
"""
struct AVStream
    data::NTuple{496, UInt8}
end

function Base.getproperty(x::Ptr{AVStream}, f::Symbol)
    f === :index && return Ptr{Cint}(x + 0)
    f === :id && return Ptr{Cint}(x + 4)
    f === :codec && return Ptr{Ptr{AVCodecContext}}(x + 8)
    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 16)
    f === :time_base && return Ptr{AVRational}(x + 24)
    f === :start_time && return Ptr{Int64}(x + 32)
    f === :duration && return Ptr{Int64}(x + 40)
    f === :nb_frames && return Ptr{Int64}(x + 48)
    f === :disposition && return Ptr{Cint}(x + 56)
    f === :discard && return Ptr{AVDiscard}(x + 60)
    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 64)
    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 72)
    f === :avg_frame_rate && return Ptr{AVRational}(x + 80)
    f === :attached_pic && return Ptr{AVPacket}(x + 88)
    f === :side_data && return Ptr{Ptr{AVPacketSideData}}(x + 176)
    f === :nb_side_data && return Ptr{Cint}(x + 184)
    f === :event_flags && return Ptr{Cint}(x + 188)
    f === :r_frame_rate && return Ptr{AVRational}(x + 192)
    f === :recommended_encoder_configuration && return Ptr{Cstring}(x + 200)
    f === :codecpar && return Ptr{Ptr{AVCodecParameters}}(x + 208)
    f === :unused && return Ptr{Ptr{Cvoid}}(x + 216)
    f === :pts_wrap_bits && return Ptr{Cint}(x + 224)
    f === :first_dts && return Ptr{Int64}(x + 232)
    f === :cur_dts && return Ptr{Int64}(x + 240)
    f === :last_IP_pts && return Ptr{Int64}(x + 248)
    f === :last_IP_duration && return Ptr{Cint}(x + 256)
    f === :probe_packets && return Ptr{Cint}(x + 260)
    f === :codec_info_nb_frames && return Ptr{Cint}(x + 264)
    f === :need_parsing && return Ptr{AVStreamParseType}(x + 268)
    f === :parser && return Ptr{Ptr{AVCodecParserContext}}(x + 272)
    f === :unused7 && return Ptr{Ptr{Cvoid}}(x + 280)
    f === :unused6 && return Ptr{AVProbeData}(x + 288)
    f === :unused5 && return Ptr{NTuple{17, Int64}}(x + 320)
    f === :index_entries && return Ptr{Ptr{AVIndexEntry}}(x + 456)
    f === :nb_index_entries && return Ptr{Cint}(x + 464)
    f === :index_entries_allocated_size && return Ptr{Cuint}(x + 468)
    f === :stream_identifier && return Ptr{Cint}(x + 472)
    f === :unused8 && return Ptr{Cint}(x + 476)
    f === :unused9 && return Ptr{Cint}(x + 480)
    f === :unused10 && return Ptr{Cint}(x + 484)
    f === :internal && return Ptr{Ptr{AVStreamInternal}}(x + 488)
    return getfield(x, f)
end

function Base.getproperty(x::AVStream, f::Symbol)
    r = Ref{AVStream}(x)
    ptr = Base.unsafe_convert(Ptr{AVStream}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVStream}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVProgram

New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVProgram`](@ref)) must not be used outside libav*.
"""
struct AVProgram
    id::Cint
    flags::Cint
    discard::AVDiscard
    stream_index::Ptr{Cuint}
    nb_stream_indexes::Cuint
    metadata::Ptr{AVDictionary}
    program_num::Cint
    pmt_pid::Cint
    pcr_pid::Cint
    pmt_version::Cint
    start_time::Int64
    end_time::Int64
    pts_wrap_reference::Int64
    pts_wrap_behavior::Cint
end

struct AVChapter
    id::Cint
    time_base::AVRational
    start::Int64
    _end::Int64
    metadata::Ptr{AVDictionary}
end

"""
    AVIOInterruptCB

Callback for checking whether to abort blocking functions. [`AVERROR_EXIT`](@ref) is returned in this case by the interrupted function. During blocking operations, callback is called with opaque as parameter. If the callback returns 1, the blocking operation will be aborted.

No members can be added to this struct without a major bump, if new elements have been added after this struct in [`AVFormatContext`](@ref) or [`AVIOContext`](@ref).
"""
struct AVIOInterruptCB
    callback::Ptr{Cvoid}
    opaque::Ptr{Cvoid}
end

"""
    AVDurationEstimationMethod

The duration of a video can be estimated through various ways, and this enum can be used to know how the duration was estimated.
"""
const AVDurationEstimationMethod = UInt32
const AVFMT_DURATION_FROM_PTS = 0 % UInt32
const AVFMT_DURATION_FROM_STREAM = 1 % UInt32
const AVFMT_DURATION_FROM_BITRATE = 2 % UInt32

mutable struct AVFormatInternal end

# typedef int ( * av_format_control_message ) ( struct AVFormatContext * s , int type , void * data , size_t data_size )
"""
Callback used by devices to communicate with application.
"""
const av_format_control_message = Ptr{Cvoid}

"""
    AVFormatContext

Format I/O context. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof([`AVFormatContext`](@ref)) must not be used outside libav*, use [`avformat_alloc_context`](@ref)() to create an [`AVFormatContext`](@ref).

Fields can be accessed through AVOptions (av\\_opt*), the name string used matches the associated command line parameter name and can be found in libavformat/options\\_table.h. The [`AVOption`](@ref)/command line parameter names differ in some cases from the C structure field names for historic reasons or brevity.
"""
struct AVFormatContext
    data::NTuple{1504, UInt8}
end

function Base.getproperty(x::Ptr{AVFormatContext}, f::Symbol)
    f === :av_class && return Ptr{Ptr{AVClass}}(x + 0)
    f === :iformat && return Ptr{Ptr{AVInputFormat}}(x + 8)
    f === :oformat && return Ptr{Ptr{AVOutputFormat}}(x + 16)
    f === :priv_data && return Ptr{Ptr{Cvoid}}(x + 24)
    f === :pb && return Ptr{Ptr{AVIOContext}}(x + 32)
    f === :ctx_flags && return Ptr{Cint}(x + 40)
    f === :nb_streams && return Ptr{Cuint}(x + 44)
    f === :streams && return Ptr{Ptr{Ptr{AVStream}}}(x + 48)
    f === :filename && return Ptr{NTuple{1024, Cchar}}(x + 56)
    f === :url && return Ptr{Cstring}(x + 1080)
    f === :start_time && return Ptr{Int64}(x + 1088)
    f === :duration && return Ptr{Int64}(x + 1096)
    f === :bit_rate && return Ptr{Int64}(x + 1104)
    f === :packet_size && return Ptr{Cuint}(x + 1112)
    f === :max_delay && return Ptr{Cint}(x + 1116)
    f === :flags && return Ptr{Cint}(x + 1120)
    f === :probesize && return Ptr{Int64}(x + 1128)
    f === :max_analyze_duration && return Ptr{Int64}(x + 1136)
    f === :key && return Ptr{Ptr{UInt8}}(x + 1144)
    f === :keylen && return Ptr{Cint}(x + 1152)
    f === :nb_programs && return Ptr{Cuint}(x + 1156)
    f === :programs && return Ptr{Ptr{Ptr{AVProgram}}}(x + 1160)
    f === :video_codec_id && return Ptr{AVCodecID}(x + 1168)
    f === :audio_codec_id && return Ptr{AVCodecID}(x + 1172)
    f === :subtitle_codec_id && return Ptr{AVCodecID}(x + 1176)
    f === :max_index_size && return Ptr{Cuint}(x + 1180)
    f === :max_picture_buffer && return Ptr{Cuint}(x + 1184)
    f === :nb_chapters && return Ptr{Cuint}(x + 1188)
    f === :chapters && return Ptr{Ptr{Ptr{AVChapter}}}(x + 1192)
    f === :metadata && return Ptr{Ptr{AVDictionary}}(x + 1200)
    f === :start_time_realtime && return Ptr{Int64}(x + 1208)
    f === :fps_probe_size && return Ptr{Cint}(x + 1216)
    f === :error_recognition && return Ptr{Cint}(x + 1220)
    f === :interrupt_callback && return Ptr{AVIOInterruptCB}(x + 1224)
    f === :debug && return Ptr{Cint}(x + 1240)
    f === :max_interleave_delta && return Ptr{Int64}(x + 1248)
    f === :strict_std_compliance && return Ptr{Cint}(x + 1256)
    f === :event_flags && return Ptr{Cint}(x + 1260)
    f === :max_ts_probe && return Ptr{Cint}(x + 1264)
    f === :avoid_negative_ts && return Ptr{Cint}(x + 1268)
    f === :ts_id && return Ptr{Cint}(x + 1272)
    f === :audio_preload && return Ptr{Cint}(x + 1276)
    f === :max_chunk_duration && return Ptr{Cint}(x + 1280)
    f === :max_chunk_size && return Ptr{Cint}(x + 1284)
    f === :use_wallclock_as_timestamps && return Ptr{Cint}(x + 1288)
    f === :avio_flags && return Ptr{Cint}(x + 1292)
    f === :duration_estimation_method && return Ptr{AVDurationEstimationMethod}(x + 1296)
    f === :skip_initial_bytes && return Ptr{Int64}(x + 1304)
    f === :correct_ts_overflow && return Ptr{Cuint}(x + 1312)
    f === :seek2any && return Ptr{Cint}(x + 1316)
    f === :flush_packets && return Ptr{Cint}(x + 1320)
    f === :probe_score && return Ptr{Cint}(x + 1324)
    f === :format_probesize && return Ptr{Cint}(x + 1328)
    f === :codec_whitelist && return Ptr{Cstring}(x + 1336)
    f === :format_whitelist && return Ptr{Cstring}(x + 1344)
    f === :internal && return Ptr{Ptr{AVFormatInternal}}(x + 1352)
    f === :io_repositioned && return Ptr{Cint}(x + 1360)
    f === :video_codec && return Ptr{Ptr{AVCodec}}(x + 1368)
    f === :audio_codec && return Ptr{Ptr{AVCodec}}(x + 1376)
    f === :subtitle_codec && return Ptr{Ptr{AVCodec}}(x + 1384)
    f === :data_codec && return Ptr{Ptr{AVCodec}}(x + 1392)
    f === :metadata_header_padding && return Ptr{Cint}(x + 1400)
    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 1408)
    f === :control_message_cb && return Ptr{av_format_control_message}(x + 1416)
    f === :output_ts_offset && return Ptr{Int64}(x + 1424)
    f === :dump_separator && return Ptr{Ptr{UInt8}}(x + 1432)
    f === :data_codec_id && return Ptr{AVCodecID}(x + 1440)
    f === :open_cb && return Ptr{Ptr{Cvoid}}(x + 1448)
    f === :protocol_whitelist && return Ptr{Cstring}(x + 1456)
    f === :io_open && return Ptr{Ptr{Cvoid}}(x + 1464)
    f === :io_close && return Ptr{Ptr{Cvoid}}(x + 1472)
    f === :protocol_blacklist && return Ptr{Cstring}(x + 1480)
    f === :max_streams && return Ptr{Cint}(x + 1488)
    f === :skip_estimate_duration_from_pts && return Ptr{Cint}(x + 1492)
    f === :max_probe_packets && return Ptr{Cint}(x + 1496)
    return getfield(x, f)
end

function Base.getproperty(x::AVFormatContext, f::Symbol)
    r = Ref{AVFormatContext}(x)
    ptr = Base.unsafe_convert(Ptr{AVFormatContext}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVFormatContext}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    avdevice_app_to_dev_control_message(s, type::AVAppToDevMessageType, data, data_size::Csize_t)

Send control message from application to device.

### Parameters
* `s`: device context. 

* `type`: message type. 

* `data`: message data. Exact type depends on message type. 

* `data_size`: size of message data. 

### Returns
>= 0 on success, negative on error. [`AVERROR`](@ref)(ENOSYS) when device doesn't implement handler of the message.
"""
function avdevice_app_to_dev_control_message(s, type::AVAppToDevMessageType, data, data_size::Csize_t)
    ccall((:avdevice_app_to_dev_control_message, libavdevice), Cint, (Ptr{AVFormatContext}, AVAppToDevMessageType, Ptr{Cvoid}, Csize_t), s, type, data, data_size)
end

"""
    avdevice_dev_to_app_control_message(s, type::AVDevToAppMessageType, data, data_size::Csize_t)

Send control message from device to application.

### Parameters
* `s`: device context. 

* `type`: message type. 

* `data`: message data. Can be NULL. 

* `data_size`: size of message data. 

### Returns
>= 0 on success, negative on error. [`AVERROR`](@ref)(ENOSYS) when application doesn't implement handler of the message.
"""
function avdevice_dev_to_app_control_message(s, type::AVDevToAppMessageType, data, data_size::Csize_t)
    ccall((:avdevice_dev_to_app_control_message, libavdevice), Cint, (Ptr{AVFormatContext}, AVDevToAppMessageType, Ptr{Cvoid}, Csize_t), s, type, data, data_size)
end

"""
    AVDeviceCapabilitiesQuery

Structure describes device capabilities.

It is used by devices in conjunction with av\\_device\\_capabilities [`AVOption`](@ref) table to implement capabilities probing API based on [`AVOption`](@ref) API. Should not be used directly.
"""
struct AVDeviceCapabilitiesQuery
    av_class::Ptr{AVClass}
    device_context::Ptr{AVFormatContext}
    codec::AVCodecID
    sample_format::AVSampleFormat
    pixel_format::AVPixelFormat
    sample_rate::Cint
    channels::Cint
    channel_layout::Int64
    window_width::Cint
    window_height::Cint
    frame_width::Cint
    frame_height::Cint
    fps::AVRational
end

"""
    avdevice_capabilities_create(caps, s, device_options)

Initialize capabilities probing API based on [`AVOption`](@ref) API.

[`avdevice_capabilities_free`](@ref)() must be called when query capabilities API is not used anymore.

### Parameters
* `caps`:\\[out\\] Device capabilities data. Pointer to a NULL pointer must be passed. 

* `s`: Context of the device. 

* `device_options`: An [`AVDictionary`](@ref) filled with device-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL. The same options must be passed later to [`avformat_write_header`](@ref)() for output devices or [`avformat_open_input`](@ref)() for input devices, or at any other place that affects device-private options.

### Returns
>= 0 on success, negative otherwise.
"""
function avdevice_capabilities_create(caps, s, device_options)
    ccall((:avdevice_capabilities_create, libavdevice), Cint, (Ptr{Ptr{AVDeviceCapabilitiesQuery}}, Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), caps, s, device_options)
end

"""
    avdevice_capabilities_free(caps, s)

Free resources created by [`avdevice_capabilities_create`](@ref)()

### Parameters
* `caps`: Device capabilities data to be freed. 

* `s`: Context of the device.
"""
function avdevice_capabilities_free(caps, s)
    ccall((:avdevice_capabilities_free, libavdevice), Cvoid, (Ptr{Ptr{AVDeviceCapabilitiesQuery}}, Ptr{AVFormatContext}), caps, s)
end

"""
    AVDeviceInfo

Structure describes basic parameters of the device.
"""
struct AVDeviceInfo
    device_name::Cstring
    device_description::Cstring
end

"""
    AVDeviceInfoList

List of devices.
"""
struct AVDeviceInfoList
    devices::Ptr{Ptr{AVDeviceInfo}}
    nb_devices::Cint
    default_device::Cint
end

"""
    avdevice_list_devices(s, device_list)

List devices.

Returns available device names and their parameters.

!!! note

    : Some devices may accept system-dependent device names that cannot be autodetected. The list returned by this function cannot be assumed to be always completed.

### Parameters
* `s`: device context. 

* `device_list`:\\[out\\] list of autodetected devices. 

### Returns
count of autodetected devices, negative on error.
"""
function avdevice_list_devices(s, device_list)
    ccall((:avdevice_list_devices, libavdevice), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDeviceInfoList}}), s, device_list)
end

"""
    avdevice_free_list_devices(device_list)

Convenient function to free result of [`avdevice_list_devices`](@ref)().

### Parameters
* `devices`: device list to be freed.
"""
function avdevice_free_list_devices(device_list)
    ccall((:avdevice_free_list_devices, libavdevice), Cvoid, (Ptr{Ptr{AVDeviceInfoList}},), device_list)
end

"""
    avdevice_list_input_sources(device, device_name, device_options, device_list)

List devices.

Returns available device names and their parameters. These are convinient wrappers for [`avdevice_list_devices`](@ref)(). Device context is allocated and deallocated internally.

!!! note

    device argument takes precedence over device\\_name when both are set.

### Parameters
* `device`: device format. May be NULL if device name is set. 

* `device_name`: device name. May be NULL if device format is set. 

* `device_options`: An [`AVDictionary`](@ref) filled with device-private options. May be NULL. The same options must be passed later to [`avformat_write_header`](@ref)() for output devices or [`avformat_open_input`](@ref)() for input devices, or at any other place that affects device-private options. 

* `device_list`:\\[out\\] list of autodetected devices 

### Returns
count of autodetected devices, negative on error. 
"""
function avdevice_list_input_sources(device, device_name, device_options, device_list)
    ccall((:avdevice_list_input_sources, libavdevice), Cint, (Ptr{AVInputFormat}, Cstring, Ptr{AVDictionary}, Ptr{Ptr{AVDeviceInfoList}}), device, device_name, device_options, device_list)
end

function avdevice_list_output_sinks(device, device_name, device_options, device_list)
    ccall((:avdevice_list_output_sinks, libavdevice), Cint, (Ptr{AVOutputFormat}, Cstring, Ptr{AVDictionary}, Ptr{Ptr{AVDeviceInfoList}}), device, device_name, device_options, device_list)
end

"""
    avfilter_version()

Return the [`LIBAVFILTER_VERSION_INT`](@ref) constant.
"""
function avfilter_version()
    ccall((:avfilter_version, libavfilter), Cuint, ())
end

"""
    avfilter_configuration()

Return the libavfilter build-time configuration.
"""
function avfilter_configuration()
    ccall((:avfilter_configuration, libavfilter), Cstring, ())
end

"""
    avfilter_license()

Return the libavfilter license.
"""
function avfilter_license()
    ccall((:avfilter_license, libavfilter), Cstring, ())
end

mutable struct AVFilterPad end

mutable struct AVFilterInternal end

mutable struct AVFilterCommand end

"""
    AVFilterContext

An instance of a filter 
"""
struct AVFilterContext
    av_class::Ptr{AVClass}
    filter::Ptr{Cvoid} # filter::Ptr{AVFilter}
    name::Cstring
    input_pads::Ptr{AVFilterPad}
    inputs::Ptr{Ptr{Cvoid}} # inputs::Ptr{Ptr{AVFilterLink}}
    nb_inputs::Cuint
    output_pads::Ptr{AVFilterPad}
    outputs::Ptr{Ptr{Cvoid}} # outputs::Ptr{Ptr{AVFilterLink}}
    nb_outputs::Cuint
    priv::Ptr{Cvoid}
    graph::Ptr{Cvoid} # graph::Ptr{AVFilterGraph}
    thread_type::Cint
    internal::Ptr{AVFilterInternal}
    command_queue::Ptr{AVFilterCommand}
    enable_str::Cstring
    enable::Ptr{Cvoid}
    var_values::Ptr{Cdouble}
    is_disabled::Cint
    hw_device_ctx::Ptr{AVBufferRef}
    nb_threads::Cint
    ready::Cuint
    extra_hw_frames::Cint
end

function Base.getproperty(x::AVFilterContext, f::Symbol)
    f === :filter && return Ptr{AVFilter}(getfield(x, f))
    f === :inputs && return Ptr{Ptr{AVFilterLink}}(getfield(x, f))
    f === :outputs && return Ptr{Ptr{AVFilterLink}}(getfield(x, f))
    f === :graph && return Ptr{AVFilterGraph}(getfield(x, f))
    return getfield(x, f)
end

mutable struct AVFilterFormats end

mutable struct AVFilterChannelLayouts end

"""
    AVFilterFormatsConfig

Lists of formats / etc. supported by an end of a link.

This structure is directly part of [`AVFilterLink`](@ref), in two copies: one for the source filter, one for the destination filter.

These lists are used for negotiating the format to actually be used, which will be loaded into the format and channel\\_layout members of [`AVFilterLink`](@ref), when chosen.
"""
struct AVFilterFormatsConfig
    formats::Ptr{AVFilterFormats}
    samplerates::Ptr{AVFilterFormats}
    channel_layouts::Ptr{AVFilterChannelLayouts}
end

"""
    AVFilterLink

A link between two filters. This contains pointers to the source and destination filters between which this link exists, and the indexes of the pads involved. In addition, this link also contains the parameters which have been negotiated and agreed upon between the filter, such as image dimensions, format, etc.

Applications must not normally access the link structure directly. Use the buffersrc and buffersink API instead. In the future, access to the header may be reserved for filters implementation.
"""
struct AVFilterLink
    data::NTuple{61680, UInt8}
end

function Base.getproperty(x::Ptr{AVFilterLink}, f::Symbol)
    f === :src && return Ptr{Ptr{AVFilterContext}}(x + 0)
    f === :srcpad && return Ptr{Ptr{AVFilterPad}}(x + 8)
    f === :dst && return Ptr{Ptr{AVFilterContext}}(x + 16)
    f === :dstpad && return Ptr{Ptr{AVFilterPad}}(x + 24)
    f === :type && return Ptr{AVMediaType}(x + 32)
    f === :w && return Ptr{Cint}(x + 36)
    f === :h && return Ptr{Cint}(x + 40)
    f === :sample_aspect_ratio && return Ptr{AVRational}(x + 44)
    f === :channel_layout && return Ptr{UInt64}(x + 56)
    f === :sample_rate && return Ptr{Cint}(x + 64)
    f === :format && return Ptr{Cint}(x + 68)
    f === :time_base && return Ptr{AVRational}(x + 72)
    f === :incfg && return Ptr{AVFilterFormatsConfig}(x + 80)
    f === :outcfg && return Ptr{AVFilterFormatsConfig}(x + 104)
    f === :init_state && return Ptr{Cvoid}(x + 128)
    f === :graph && return Ptr{Ptr{AVFilterGraph}}(x + 136)
    f === :current_pts && return Ptr{Int64}(x + 144)
    f === :current_pts_us && return Ptr{Int64}(x + 152)
    f === :age_index && return Ptr{Cint}(x + 160)
    f === :frame_rate && return Ptr{AVRational}(x + 164)
    f === :partial_buf && return Ptr{Ptr{AVFrame}}(x + 176)
    f === :partial_buf_size && return Ptr{Cint}(x + 184)
    f === :min_samples && return Ptr{Cint}(x + 188)
    f === :max_samples && return Ptr{Cint}(x + 192)
    f === :channels && return Ptr{Cint}(x + 196)
    f === :frame_count_in && return Ptr{Int64}(x + 200)
    f === :frame_count_out && return Ptr{Int64}(x + 208)
    f === :frame_pool && return Ptr{Ptr{Cvoid}}(x + 216)
    f === :frame_wanted_out && return Ptr{Cint}(x + 224)
    f === :hw_frames_ctx && return Ptr{Ptr{AVBufferRef}}(x + 232)
    f === :reserved && return Ptr{NTuple{61440, Cchar}}(x + 240)
    return getfield(x, f)
end

function Base.getproperty(x::AVFilterLink, f::Symbol)
    r = Ref{AVFilterLink}(x)
    ptr = Base.unsafe_convert(Ptr{AVFilterLink}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVFilterLink}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    avfilter_pad_count(pads)

Get the number of elements in a NULL-terminated array of AVFilterPads (e.g. [`AVFilter`](@ref).inputs/outputs).
"""
function avfilter_pad_count(pads)
    ccall((:avfilter_pad_count, libavfilter), Cint, (Ptr{AVFilterPad},), pads)
end

"""
    avfilter_pad_get_name(pads, pad_idx::Integer)

Get the name of an [`AVFilterPad`](@ref).

### Parameters
* `pads`: an array of AVFilterPads 

* `pad_idx`: index of the pad in the array; it is the caller's responsibility to ensure the index is valid

### Returns
name of the pad\\_idx'th pad in pads
"""
function avfilter_pad_get_name(pads, pad_idx::Integer)
    ccall((:avfilter_pad_get_name, libavfilter), Cstring, (Ptr{AVFilterPad}, Cint), pads, pad_idx)
end

"""
    avfilter_pad_get_type(pads, pad_idx::Integer)

Get the type of an [`AVFilterPad`](@ref).

### Parameters
* `pads`: an array of AVFilterPads 

* `pad_idx`: index of the pad in the array; it is the caller's responsibility to ensure the index is valid

### Returns
type of the pad\\_idx'th pad in pads
"""
function avfilter_pad_get_type(pads, pad_idx::Integer)
    ccall((:avfilter_pad_get_type, libavfilter), AVMediaType, (Ptr{AVFilterPad}, Cint), pads, pad_idx)
end

"""
    AVFilter

Filter definition. This defines the pads a filter contains, and all the callback functions used to interact with the filter.
"""
struct AVFilter
    name::Cstring
    description::Cstring
    inputs::Ptr{AVFilterPad}
    outputs::Ptr{AVFilterPad}
    priv_class::Ptr{AVClass}
    flags::Cint
    preinit::Ptr{Cvoid}
    init::Ptr{Cvoid}
    init_dict::Ptr{Cvoid}
    uninit::Ptr{Cvoid}
    query_formats::Ptr{Cvoid}
    priv_size::Cint
    flags_internal::Cint
    next::Ptr{AVFilter}
    process_command::Ptr{Cvoid}
    init_opaque::Ptr{Cvoid}
    activate::Ptr{Cvoid}
end

"""
    avfilter_link(src, srcpad::Integer, dst, dstpad::Integer)

Link two filters together.

### Parameters
* `src`: the source filter 

* `srcpad`: index of the output pad on the source filter 

* `dst`: the destination filter 

* `dstpad`: index of the input pad on the destination filter 

### Returns
zero on success
"""
function avfilter_link(src, srcpad::Integer, dst, dstpad::Integer)
    ccall((:avfilter_link, libavfilter), Cint, (Ptr{AVFilterContext}, Cuint, Ptr{AVFilterContext}, Cuint), src, srcpad, dst, dstpad)
end

"""
    avfilter_link_free(link)

Free the link in *link, and set its pointer to NULL.
"""
function avfilter_link_free(link)
    ccall((:avfilter_link_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterLink}},), link)
end

"""
    avfilter_link_get_channels(link)

Get the number of channels of a link. 

\\deprecated Use [`av_buffersink_get_channels`](@ref)()
"""
function avfilter_link_get_channels(link)
    ccall((:avfilter_link_get_channels, libavfilter), Cint, (Ptr{AVFilterLink},), link)
end

"""
    avfilter_link_set_closed(link, closed::Integer)

Set the closed field of a link. 

\\deprecated applications are not supposed to mess with links, they should close the sinks.
"""
function avfilter_link_set_closed(link, closed::Integer)
    ccall((:avfilter_link_set_closed, libavfilter), Cvoid, (Ptr{AVFilterLink}, Cint), link, closed)
end

"""
    avfilter_config_links(filter)

Negotiate the media format, dimensions, etc of all inputs to a filter.

### Parameters
* `filter`: the filter to negotiate the properties for its inputs 

### Returns
zero on successful negotiation
"""
function avfilter_config_links(filter)
    ccall((:avfilter_config_links, libavfilter), Cint, (Ptr{AVFilterContext},), filter)
end

"""
    avfilter_process_command(filter, cmd, arg, res, res_len::Integer, flags::Integer)

Make the filter instance process a command. It is recommended to use [`avfilter_graph_send_command`](@ref)().
"""
function avfilter_process_command(filter, cmd, arg, res, res_len::Integer, flags::Integer)
    ccall((:avfilter_process_command, libavfilter), Cint, (Ptr{AVFilterContext}, Cstring, Cstring, Cstring, Cint, Cint), filter, cmd, arg, res, res_len, flags)
end

"""
    av_filter_iterate(opaque)

Iterate over all registered filters.

### Parameters
* `opaque`: a pointer where libavfilter will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered filter or NULL when the iteration is finished
"""
function av_filter_iterate(opaque)
    ccall((:av_filter_iterate, libavfilter), Ptr{AVFilter}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    avfilter_register_all()

Initialize the filter system. Register all builtin filters. 
"""
function avfilter_register_all()
    ccall((:avfilter_register_all, libavfilter), Cvoid, ())
end

"""
    avfilter_register(filter)

Register a filter. This is only needed if you plan to use [`avfilter_get_by_name`](@ref) later to lookup the [`AVFilter`](@ref) structure by name. A filter can still by instantiated with [`avfilter_graph_alloc_filter`](@ref) even if it is not registered.

### Parameters
* `filter`: the filter to register 

### Returns
0 if the registration was successful, a negative value otherwise
"""
function avfilter_register(filter)
    ccall((:avfilter_register, libavfilter), Cint, (Ptr{AVFilter},), filter)
end

"""
    avfilter_next(prev)

Iterate over all registered filters. 

### Returns
If prev is non-NULL, next registered filter after prev or NULL if prev is the last filter. If prev is NULL, return the first registered filter.
"""
function avfilter_next(prev)
    ccall((:avfilter_next, libavfilter), Ptr{AVFilter}, (Ptr{AVFilter},), prev)
end

"""
    avfilter_get_by_name(name)

Get a filter definition matching the given name.

### Parameters
* `name`: the filter name to find 

### Returns
the filter definition, if any matching one is registered. NULL if none found.
"""
function avfilter_get_by_name(name)
    ccall((:avfilter_get_by_name, libavfilter), Ptr{AVFilter}, (Cstring,), name)
end

"""
    avfilter_init_str(ctx, args)

Initialize a filter with the supplied parameters.

### Parameters
* `ctx`: uninitialized filter context to initialize 

* `args`: Options to initialize the filter with. This must be a ':'-separated list of options in the 'key=value' form. May be NULL if the options have been set directly using the AVOptions API or there are no options that need to be set. 

### Returns
0 on success, a negative [`AVERROR`](@ref) on failure
"""
function avfilter_init_str(ctx, args)
    ccall((:avfilter_init_str, libavfilter), Cint, (Ptr{AVFilterContext}, Cstring), ctx, args)
end

"""
    avfilter_init_dict(ctx, options)

Initialize a filter with the supplied dictionary of options.

!!! note

    This function and [`avfilter_init_str`](@ref)() do essentially the same thing, the difference is in manner in which the options are passed. It is up to the calling code to choose whichever is more preferable. The two functions also behave differently when some of the provided options are not declared as supported by the filter. In such a case, [`avfilter_init_str`](@ref)() will fail, but this function will leave those extra options in the options [`AVDictionary`](@ref) and continue as usual.

### Parameters
* `ctx`: uninitialized filter context to initialize 

* `options`: An [`AVDictionary`](@ref) filled with options for this filter. On return this parameter will be destroyed and replaced with a dict containing options that were not found. This dictionary must be freed by the caller. May be NULL, then this function is equivalent to [`avfilter_init_str`](@ref)() with the second parameter set to NULL. 

### Returns
0 on success, a negative [`AVERROR`](@ref) on failure
"""
function avfilter_init_dict(ctx, options)
    ccall((:avfilter_init_dict, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{Ptr{AVDictionary}}), ctx, options)
end

"""
    avfilter_free(filter)

Free a filter context. This will also remove the filter from its filtergraph's list of filters.

### Parameters
* `filter`: the filter to free
"""
function avfilter_free(filter)
    ccall((:avfilter_free, libavfilter), Cvoid, (Ptr{AVFilterContext},), filter)
end

"""
    avfilter_insert_filter(link, filt, filt_srcpad_idx::Integer, filt_dstpad_idx::Integer)

Insert a filter in the middle of an existing link.

### Parameters
* `link`: the link into which the filter should be inserted 

* `filt`: the filter to be inserted 

* `filt_srcpad_idx`: the input pad on the filter to connect 

* `filt_dstpad_idx`: the output pad on the filter to connect 

### Returns
zero on success
"""
function avfilter_insert_filter(link, filt, filt_srcpad_idx::Integer, filt_dstpad_idx::Integer)
    ccall((:avfilter_insert_filter, libavfilter), Cint, (Ptr{AVFilterLink}, Ptr{AVFilterContext}, Cuint, Cuint), link, filt, filt_srcpad_idx, filt_dstpad_idx)
end

"""
    avfilter_get_class()

### Returns
[`AVClass`](@ref) for [`AVFilterContext`](@ref).

### See also
[`av_opt_find`](@ref)().
"""
function avfilter_get_class()
    ccall((:avfilter_get_class, libavfilter), Ptr{AVClass}, ())
end

mutable struct AVFilterGraphInternal end

# typedef int ( avfilter_action_func ) ( AVFilterContext * ctx , void * arg , int jobnr , int nb_jobs )
"""
A function pointer passed to the AVFilterGraph.execute callback to be executed multiple times, possibly in parallel.

### Parameters
* `ctx`: the filter context the job belongs to 

* `arg`: an opaque parameter passed through from AVFilterGraph.execute 

* `jobnr`: the index of the job being executed 

* `nb_jobs`: the total number of jobs

### Returns
0 on success, a negative [`AVERROR`](@ref) on error
"""
const avfilter_action_func = Cvoid

# typedef int ( avfilter_execute_func ) ( AVFilterContext * ctx , avfilter_action_func * func , void * arg , int * ret , int nb_jobs )
"""
A function executing multiple jobs, possibly in parallel.

### Parameters
* `ctx`: the filter context to which the jobs belong 

* `func`: the function to be called multiple times 

* `arg`: the argument to be passed to func 

* `ret`: a nb\\_jobs-sized array to be filled with return values from each invocation of func 

* `nb_jobs`: the number of jobs to execute

### Returns
0 on success, a negative [`AVERROR`](@ref) on error
"""
const avfilter_execute_func = Cvoid

struct AVFilterGraph
    data::NTuple{96, UInt8}
end

function Base.getproperty(x::Ptr{AVFilterGraph}, f::Symbol)
    f === :av_class && return Ptr{Ptr{AVClass}}(x + 0)
    f === :filters && return Ptr{Ptr{Ptr{AVFilterContext}}}(x + 8)
    f === :nb_filters && return Ptr{Cuint}(x + 16)
    f === :scale_sws_opts && return Ptr{Cstring}(x + 24)
    f === :resample_lavr_opts && return Ptr{Cstring}(x + 32)
    f === :thread_type && return Ptr{Cint}(x + 40)
    f === :nb_threads && return Ptr{Cint}(x + 44)
    f === :internal && return Ptr{Ptr{AVFilterGraphInternal}}(x + 48)
    f === :opaque && return Ptr{Ptr{Cvoid}}(x + 56)
    f === :execute && return Ptr{Ptr{Cvoid}}(x + 64)
    f === :aresample_swr_opts && return Ptr{Cstring}(x + 72)
    f === :sink_links && return Ptr{Ptr{Ptr{AVFilterLink}}}(x + 80)
    f === :sink_links_count && return Ptr{Cint}(x + 88)
    f === :disable_auto_convert && return Ptr{Cuint}(x + 92)
    return getfield(x, f)
end

function Base.getproperty(x::AVFilterGraph, f::Symbol)
    r = Ref{AVFilterGraph}(x)
    ptr = Base.unsafe_convert(Ptr{AVFilterGraph}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVFilterGraph}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    avfilter_graph_alloc()

Allocate a filter graph.

### Returns
the allocated filter graph on success or NULL.
"""
function avfilter_graph_alloc()
    ccall((:avfilter_graph_alloc, libavfilter), Ptr{AVFilterGraph}, ())
end

"""
    avfilter_graph_alloc_filter(graph, filter, name)

Create a new filter instance in a filter graph.

### Parameters
* `graph`: graph in which the new filter will be used 

* `filter`: the filter to create an instance of 

* `name`: Name to give to the new instance (will be copied to [`AVFilterContext`](@ref).name). This may be used by the caller to identify different filters, libavfilter itself assigns no semantics to this parameter. May be NULL.

### Returns
the context of the newly created filter instance (note that it is also retrievable directly through [`AVFilterGraph`](@ref).filters or with [`avfilter_graph_get_filter`](@ref)()) on success or NULL on failure.
"""
function avfilter_graph_alloc_filter(graph, filter, name)
    ccall((:avfilter_graph_alloc_filter, libavfilter), Ptr{AVFilterContext}, (Ptr{AVFilterGraph}, Ptr{AVFilter}, Cstring), graph, filter, name)
end

"""
    avfilter_graph_get_filter(graph, name)

Get a filter instance identified by instance name from graph.

### Parameters
* `graph`: filter graph to search through. 

* `name`: filter instance name (should be unique in the graph). 

### Returns
the pointer to the found filter instance or NULL if it cannot be found.
"""
function avfilter_graph_get_filter(graph, name)
    ccall((:avfilter_graph_get_filter, libavfilter), Ptr{AVFilterContext}, (Ptr{AVFilterGraph}, Cstring), graph, name)
end

"""
    avfilter_graph_create_filter(filt_ctx, filt, name, args, opaque, graph_ctx)

Create and add a filter instance into an existing graph. The filter instance is created from the filter filt and inited with the parameter args. opaque is currently ignored.

In case of success put in *filt\\_ctx the pointer to the created filter instance, otherwise set *filt\\_ctx to NULL.

### Parameters
* `name`: the instance name to give to the created filter instance 

* `graph_ctx`: the filter graph 

### Returns
a negative [`AVERROR`](@ref) error code in case of failure, a non negative value otherwise
"""
function avfilter_graph_create_filter(filt_ctx, filt, name, args, opaque, graph_ctx)
    ccall((:avfilter_graph_create_filter, libavfilter), Cint, (Ptr{Ptr{AVFilterContext}}, Ptr{AVFilter}, Cstring, Cstring, Ptr{Cvoid}, Ptr{AVFilterGraph}), filt_ctx, filt, name, args, opaque, graph_ctx)
end

"""
    avfilter_graph_set_auto_convert(graph, flags::Integer)

Enable or disable automatic format conversion inside the graph.

Note that format conversion can still happen inside explicitly inserted scale and aresample filters.

### Parameters
* `flags`: any of the AVFILTER\\_AUTO\\_CONVERT\\_* constants
"""
function avfilter_graph_set_auto_convert(graph, flags::Integer)
    ccall((:avfilter_graph_set_auto_convert, libavfilter), Cvoid, (Ptr{AVFilterGraph}, Cuint), graph, flags)
end

const __JL_Ctag_374 = Int32
const AVFILTER_AUTO_CONVERT_ALL = 0 % Int32
const AVFILTER_AUTO_CONVERT_NONE = -1 % Int32

"""
    avfilter_graph_config(graphctx, log_ctx)

Check validity and configure all the links and formats in the graph.

### Parameters
* `graphctx`: the filter graph 

* `log_ctx`: context used for logging 

### Returns
>= 0 in case of success, a negative [`AVERROR`](@ref) code otherwise
"""
function avfilter_graph_config(graphctx, log_ctx)
    ccall((:avfilter_graph_config, libavfilter), Cint, (Ptr{AVFilterGraph}, Ptr{Cvoid}), graphctx, log_ctx)
end

"""
    avfilter_graph_free(graph)

Free a graph, destroy its links, and set *graph to NULL. If *graph is NULL, do nothing.
"""
function avfilter_graph_free(graph)
    ccall((:avfilter_graph_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterGraph}},), graph)
end

"""
    AVFilterInOut

A linked-list of the inputs/outputs of the filter chain.

This is mainly useful for [`avfilter_graph_parse`](@ref)() / [`avfilter_graph_parse2`](@ref)(), where it is used to communicate open (unlinked) inputs and outputs from and to the caller. This struct specifies, per each not connected pad contained in the graph, the filter context and the pad index required for establishing a link.
"""
struct AVFilterInOut
    name::Cstring
    filter_ctx::Ptr{AVFilterContext}
    pad_idx::Cint
    next::Ptr{AVFilterInOut}
end

"""
    avfilter_inout_alloc()

Allocate a single [`AVFilterInOut`](@ref) entry. Must be freed with [`avfilter_inout_free`](@ref)(). 

### Returns
allocated [`AVFilterInOut`](@ref) on success, NULL on failure.
"""
function avfilter_inout_alloc()
    ccall((:avfilter_inout_alloc, libavfilter), Ptr{AVFilterInOut}, ())
end

"""
    avfilter_inout_free(inout)

Free the supplied list of [`AVFilterInOut`](@ref) and set *inout to NULL. If *inout is NULL, do nothing.
"""
function avfilter_inout_free(inout)
    ccall((:avfilter_inout_free, libavfilter), Cvoid, (Ptr{Ptr{AVFilterInOut}},), inout)
end

"""
    avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)

Add a graph described by a string to a graph.

!!! note

    The caller must provide the lists of inputs and outputs, which therefore must be known before calling the function.

!!! note

    The inputs parameter describes inputs of the already existing part of the graph; i.e. from the point of view of the newly created part, they are outputs. Similarly the outputs parameter describes outputs of the already existing filters, which are provided as inputs to the parsed filters.

### Parameters
* `graph`: the filter graph where to link the parsed graph context 

* `filters`: string to be parsed 

* `inputs`: linked list to the inputs of the graph 

* `outputs`: linked list to the outputs of the graph 

### Returns
zero on success, a negative [`AVERROR`](@ref) code on error
"""
function avfilter_graph_parse(graph, filters, inputs, outputs, log_ctx)
    ccall((:avfilter_graph_parse, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{AVFilterInOut}, Ptr{AVFilterInOut}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
end

"""
    avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)

Add a graph described by a string to a graph.

In the graph filters description, if the input label of the first filter is not specified, "in" is assumed; if the output label of the last filter is not specified, "out" is assumed.

### Parameters
* `graph`: the filter graph where to link the parsed graph context 

* `filters`: string to be parsed 

* `inputs`: pointer to a linked list to the inputs of the graph, may be NULL. If non-NULL, *inputs is updated to contain the list of open inputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)(). 

* `outputs`: pointer to a linked list to the outputs of the graph, may be NULL. If non-NULL, *outputs is updated to contain the list of open outputs after the parsing, should be freed with [`avfilter_inout_free`](@ref)(). 

### Returns
non negative on success, a negative [`AVERROR`](@ref) code on error
"""
function avfilter_graph_parse_ptr(graph, filters, inputs, outputs, log_ctx)
    ccall((:avfilter_graph_parse_ptr, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}, Ptr{Cvoid}), graph, filters, inputs, outputs, log_ctx)
end

"""
    avfilter_graph_parse2(graph, filters, inputs, outputs)

Add a graph described by a string to a graph.

!!! note

    This function returns the inputs and outputs that are left unlinked after parsing the graph and the caller then deals with them. 

!!! note

    This function makes no reference whatsoever to already existing parts of the graph and the inputs parameter will on return contain inputs of the newly parsed part of the graph. Analogously the outputs parameter will contain outputs of the newly created filters.

### Parameters
* `graph`:\\[in\\] the filter graph where to link the parsed graph context 

* `filters`:\\[in\\] string to be parsed 

* `inputs`:\\[out\\] a linked list of all free (unlinked) inputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)(). 

* `outputs`:\\[out\\] a linked list of all free (unlinked) outputs of the parsed graph will be returned here. It is to be freed by the caller using [`avfilter_inout_free`](@ref)(). 

### Returns
zero on success, a negative [`AVERROR`](@ref) code on error
"""
function avfilter_graph_parse2(graph, filters, inputs, outputs)
    ccall((:avfilter_graph_parse2, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Ptr{Ptr{AVFilterInOut}}, Ptr{Ptr{AVFilterInOut}}), graph, filters, inputs, outputs)
end

"""
    avfilter_graph_send_command(graph, target, cmd, arg, res, res_len::Integer, flags::Integer)

Send a command to one or more filter instances.

### Parameters
* `graph`: the filter graph 

* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters. 

* `cmd`: the command to send, for handling simplicity all commands must be alphanumeric only 

* `arg`: the argument for the command 

* `res`: a buffer with size res\\_size where the filter(s) can return a response.

### Returns
>=0 on success otherwise an error code. [`AVERROR`](@ref)(ENOSYS) on unsupported commands
"""
function avfilter_graph_send_command(graph, target, cmd, arg, res, res_len::Integer, flags::Integer)
    ccall((:avfilter_graph_send_command, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Cstring, Cstring, Cstring, Cint, Cint), graph, target, cmd, arg, res, res_len, flags)
end

"""
    avfilter_graph_queue_command(graph, target, cmd, arg, flags::Integer, ts::Cdouble)

Queue a command for one or more filter instances.

!!! note

    As this executes commands after this function returns, no return code from the filter is provided, also [`AVFILTER_CMD_FLAG_ONE`](@ref) is not supported.

### Parameters
* `graph`: the filter graph 

* `target`: the filter(s) to which the command should be sent "all" sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters. 

* `cmd`: the command to sent, for handling simplicity all commands must be alphanumeric only 

* `arg`: the argument for the command 

* `ts`: time at which the command should be sent to the filter
"""
function avfilter_graph_queue_command(graph, target, cmd, arg, flags::Integer, ts::Cdouble)
    ccall((:avfilter_graph_queue_command, libavfilter), Cint, (Ptr{AVFilterGraph}, Cstring, Cstring, Cstring, Cint, Cdouble), graph, target, cmd, arg, flags, ts)
end

"""
    avfilter_graph_dump(graph, options)

Dump a graph into a human-readable string representation.

### Parameters
* `graph`: the graph to dump 

* `options`: formatting options; currently ignored 

### Returns
a string, or NULL in case of memory allocation failure; the string must be freed using [`av_free`](@ref)
"""
function avfilter_graph_dump(graph, options)
    ccall((:avfilter_graph_dump, libavfilter), Cstring, (Ptr{AVFilterGraph}, Cstring), graph, options)
end

"""
    avfilter_graph_request_oldest(graph)

Request a frame on the oldest sink link.

If the request returns [`AVERROR_EOF`](@ref), try the next.

Note that this function is not meant to be the sole scheduling mechanism of a filtergraph, only a convenience function to help drain a filtergraph in a balanced way under normal circumstances.

Also note that [`AVERROR_EOF`](@ref) does not mean that frames did not arrive on some of the sinks during the process. When there are multiple sink links, in case the requested link returns an EOF, this may cause a filter to flush pending frames which are sent to another sink link, although unrequested.

### Returns
the return value of ff\\_request\\_frame(), or [`AVERROR_EOF`](@ref) if all links returned [`AVERROR_EOF`](@ref)
"""
function avfilter_graph_request_oldest(graph)
    ccall((:avfilter_graph_request_oldest, libavfilter), Cint, (Ptr{AVFilterGraph},), graph)
end

"""
    av_buffersink_get_frame_flags(ctx, frame, flags::Integer)

Get a frame with filtered data from sink and put it in frame.

### Parameters
* `ctx`: pointer to a buffersink or abuffersink filter context. 

* `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)() 

* `flags`: a combination of AV\\_BUFFERSINK\\_FLAG\\_* flags

### Returns
>= 0 in for success, a negative [`AVERROR`](@ref) code for failure.
"""
function av_buffersink_get_frame_flags(ctx, frame, flags::Integer)
    ccall((:av_buffersink_get_frame_flags, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}, Cint), ctx, frame, flags)
end

"""
    AVBufferSinkParams

Deprecated and unused struct to use for initializing a buffersink context.
"""
struct AVBufferSinkParams
    pixel_fmts::Ptr{AVPixelFormat}
end

"""
    av_buffersink_params_alloc()

Create an [`AVBufferSinkParams`](@ref) structure.

Must be freed with [`av_free`](@ref)().
"""
function av_buffersink_params_alloc()
    ccall((:av_buffersink_params_alloc, libavfilter), Ptr{AVBufferSinkParams}, ())
end

"""
    AVABufferSinkParams

Deprecated and unused struct to use for initializing an abuffersink context.
"""
struct AVABufferSinkParams
    sample_fmts::Ptr{AVSampleFormat}
    channel_layouts::Ptr{Int64}
    channel_counts::Ptr{Cint}
    all_channel_counts::Cint
    sample_rates::Ptr{Cint}
end

"""
    av_abuffersink_params_alloc()

Create an [`AVABufferSinkParams`](@ref) structure.

Must be freed with [`av_free`](@ref)().
"""
function av_abuffersink_params_alloc()
    ccall((:av_abuffersink_params_alloc, libavfilter), Ptr{AVABufferSinkParams}, ())
end

"""
    av_buffersink_set_frame_size(ctx, frame_size::Integer)

Set the frame size for an audio buffer sink.

All calls to av\\_buffersink\\_get\\_buffer\\_ref will return a buffer with exactly the specified number of samples, or [`AVERROR`](@ref)(EAGAIN) if there is not enough. The last buffer at EOF will be padded with 0.
"""
function av_buffersink_set_frame_size(ctx, frame_size::Integer)
    ccall((:av_buffersink_set_frame_size, libavfilter), Cvoid, (Ptr{AVFilterContext}, Cuint), ctx, frame_size)
end

"""
    av_buffersink_get_type(ctx)

` lavfi_buffersink_accessors Buffer sink accessors`

Get the properties of the stream @{
"""
function av_buffersink_get_type(ctx)
    ccall((:av_buffersink_get_type, libavfilter), AVMediaType, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_time_base(ctx)
    ccall((:av_buffersink_get_time_base, libavfilter), AVRational, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_format(ctx)
    ccall((:av_buffersink_get_format, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_frame_rate(ctx)
    ccall((:av_buffersink_get_frame_rate, libavfilter), AVRational, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_w(ctx)
    ccall((:av_buffersink_get_w, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_h(ctx)
    ccall((:av_buffersink_get_h, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_sample_aspect_ratio(ctx)
    ccall((:av_buffersink_get_sample_aspect_ratio, libavfilter), AVRational, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_channels(ctx)
    ccall((:av_buffersink_get_channels, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_channel_layout(ctx)
    ccall((:av_buffersink_get_channel_layout, libavfilter), UInt64, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_sample_rate(ctx)
    ccall((:av_buffersink_get_sample_rate, libavfilter), Cint, (Ptr{AVFilterContext},), ctx)
end

function av_buffersink_get_hw_frames_ctx(ctx)
    ccall((:av_buffersink_get_hw_frames_ctx, libavfilter), Ptr{AVBufferRef}, (Ptr{AVFilterContext},), ctx)
end

"""
    av_buffersink_get_frame(ctx, frame)

Get a frame with filtered data from sink and put it in frame.

### Parameters
* `ctx`: pointer to a context of a buffersink or abuffersink [`AVFilter`](@ref). 

* `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)()

### Returns
- >= 0 if a frame was successfully returned. - [`AVERROR`](@ref)(EAGAIN) if no frames are available at this point; more input frames must be added to the filtergraph to get more output. - [`AVERROR_EOF`](@ref) if there will be no more output frames on this sink. - A different negative [`AVERROR`](@ref) code in other failure cases.
"""
function av_buffersink_get_frame(ctx, frame)
    ccall((:av_buffersink_get_frame, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}), ctx, frame)
end

"""
    av_buffersink_get_samples(ctx, frame, nb_samples::Integer)

Same as [`av_buffersink_get_frame`](@ref)(), but with the ability to specify the number of samples read. This function is less efficient than [`av_buffersink_get_frame`](@ref)(), because it copies the data around.

!!! warning

    do not mix this function with [`av_buffersink_get_frame`](@ref)(). Use only one or the other with a single sink, not both.

### Parameters
* `ctx`: pointer to a context of the abuffersink [`AVFilter`](@ref). 

* `frame`: pointer to an allocated frame that will be filled with data. The data must be freed using [`av_frame_unref`](@ref)() / [`av_frame_free`](@ref)() frame will contain exactly nb\\_samples audio samples, except at the end of stream, when it can contain less than nb\\_samples.

### Returns
The return codes have the same meaning as for [`av_buffersink_get_frame`](@ref)().
"""
function av_buffersink_get_samples(ctx, frame, nb_samples::Integer)
    ccall((:av_buffersink_get_samples, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}, Cint), ctx, frame, nb_samples)
end

"""
    __JL_Ctag_421

` lavfi_buffersrc Buffer source API`

` lavfi`

@{
"""
const __JL_Ctag_421 = UInt32
const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1 % UInt32
const AV_BUFFERSRC_FLAG_PUSH = 4 % UInt32
const AV_BUFFERSRC_FLAG_KEEP_REF = 8 % UInt32

"""
    av_buffersrc_get_nb_failed_requests(buffer_src)

Get the number of failed requests.

A failed request is when the request\\_frame method is called while no frame is present in the buffer. The number is reset when a frame is added.
"""
function av_buffersrc_get_nb_failed_requests(buffer_src)
    ccall((:av_buffersrc_get_nb_failed_requests, libavfilter), Cuint, (Ptr{AVFilterContext},), buffer_src)
end

"""
    AVBufferSrcParameters

This structure contains the parameters describing the frames that will be passed to this filter.

It should be allocated with [`av_buffersrc_parameters_alloc`](@ref)() and freed with [`av_free`](@ref)(). All the allocated fields in it remain owned by the caller.
"""
struct AVBufferSrcParameters
    format::Cint
    time_base::AVRational
    width::Cint
    height::Cint
    sample_aspect_ratio::AVRational
    frame_rate::AVRational
    hw_frames_ctx::Ptr{AVBufferRef}
    sample_rate::Cint
    channel_layout::UInt64
end

"""
    av_buffersrc_parameters_alloc()

Allocate a new [`AVBufferSrcParameters`](@ref) instance. It should be freed by the caller with [`av_free`](@ref)().
"""
function av_buffersrc_parameters_alloc()
    ccall((:av_buffersrc_parameters_alloc, libavfilter), Ptr{AVBufferSrcParameters}, ())
end

"""
    av_buffersrc_parameters_set(ctx, param)

Initialize the buffersrc or abuffersrc filter with the provided parameters. This function may be called multiple times, the later calls override the previous ones. Some of the parameters may also be set through AVOptions, then whatever method is used last takes precedence.

### Parameters
* `ctx`: an instance of the buffersrc or abuffersrc filter 

* `param`: the stream parameters. The frames later passed to this filter must conform to those parameters. All the allocated fields in param remain owned by the caller, libavfilter will make internal copies or references when necessary. 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_buffersrc_parameters_set(ctx, param)
    ccall((:av_buffersrc_parameters_set, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVBufferSrcParameters}), ctx, param)
end

"""
    av_buffersrc_write_frame(ctx, frame)

Add a frame to the buffer source.

This function is equivalent to [`av_buffersrc_add_frame_flags`](@ref)() with the AV\\_BUFFERSRC\\_FLAG\\_KEEP\\_REF flag.

### Parameters
* `ctx`: an instance of the buffersrc filter 

* `frame`: frame to be added. If the frame is reference counted, this function will make a new reference to it. Otherwise the frame data will be copied.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error
"""
function av_buffersrc_write_frame(ctx, frame)
    ccall((:av_buffersrc_write_frame, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}), ctx, frame)
end

"""
    av_buffersrc_add_frame(ctx, frame)

Add a frame to the buffer source.

!!! note

    the difference between this function and [`av_buffersrc_write_frame`](@ref)() is that [`av_buffersrc_write_frame`](@ref)() creates a new reference to the input frame, while this function takes ownership of the reference passed to it.

This function is equivalent to [`av_buffersrc_add_frame_flags`](@ref)() without the AV\\_BUFFERSRC\\_FLAG\\_KEEP\\_REF flag.

### Parameters
* `ctx`: an instance of the buffersrc filter 

* `frame`: frame to be added. If the frame is reference counted, this function will take ownership of the reference(s) and reset the frame. Otherwise the frame data will be copied. If this function returns an error, the input frame is not touched.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error.
"""
function av_buffersrc_add_frame(ctx, frame)
    ccall((:av_buffersrc_add_frame, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}), ctx, frame)
end

"""
    av_buffersrc_add_frame_flags(buffer_src, frame, flags::Integer)

Add a frame to the buffer source.

By default, if the frame is reference-counted, this function will take ownership of the reference(s) and reset the frame. This can be controlled using the flags.

If this function returns an error, the input frame is not touched.

### Parameters
* `buffer_src`: pointer to a buffer source context 

* `frame`: a frame, or NULL to mark EOF 

* `flags`: a combination of AV\\_BUFFERSRC\\_FLAG\\_* 

### Returns
>= 0 in case of success, a negative [`AVERROR`](@ref) code in case of failure
"""
function av_buffersrc_add_frame_flags(buffer_src, frame, flags::Integer)
    ccall((:av_buffersrc_add_frame_flags, libavfilter), Cint, (Ptr{AVFilterContext}, Ptr{AVFrame}, Cint), buffer_src, frame, flags)
end

"""
    av_buffersrc_close(ctx, pts::Int64, flags::Integer)

Close the buffer source after EOF.

This is similar to passing NULL to [`av_buffersrc_add_frame_flags`](@ref)() except it takes the timestamp of the EOF, i.e. the timestamp of the end of the last frame.
"""
function av_buffersrc_close(ctx, pts::Int64, flags::Integer)
    ccall((:av_buffersrc_close, libavfilter), Cint, (Ptr{AVFilterContext}, Int64, Cuint), ctx, pts, flags)
end

"""
    av_get_packet(s, pkt, size::Integer)

Allocate and read the payload of a packet and initialize its fields with default values.

### Parameters
* `s`: associated IO context 

* `pkt`: packet 

* `size`: desired payload size 

### Returns
>0 (read size) if OK, AVERROR\\_xxx otherwise
"""
function av_get_packet(s, pkt, size::Integer)
    ccall((:av_get_packet, libavformat), Cint, (Ptr{AVIOContext}, Ptr{AVPacket}, Cint), s, pkt, size)
end

"""
    av_append_packet(s, pkt, size::Integer)

Read data and append it to the current content of the [`AVPacket`](@ref). If pkt->size is 0 this is identical to [`av_get_packet`](@ref). Note that this uses [`av_grow_packet`](@ref) and thus involves a realloc which is inefficient. Thus this function should only be used when there is no reasonable way to know (an upper bound of) the final size.

### Parameters
* `s`: associated IO context 

* `pkt`: packet 

* `size`: amount of data to read 

### Returns
>0 (read size) if OK, AVERROR\\_xxx otherwise, previous data will not be lost even if an error occurs.
"""
function av_append_packet(s, pkt, size::Integer)
    ccall((:av_append_packet, libavformat), Cint, (Ptr{AVIOContext}, Ptr{AVPacket}, Cint), s, pkt, size)
end

"""
    av_stream_get_r_frame_rate(s)

Accessors for some [`AVStream`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
"""
function av_stream_get_r_frame_rate(s)
    ccall((:av_stream_get_r_frame_rate, libavformat), AVRational, (Ptr{AVStream},), s)
end

function av_stream_set_r_frame_rate(s, r::AVRational)
    ccall((:av_stream_set_r_frame_rate, libavformat), Cvoid, (Ptr{AVStream}, AVRational), s, r)
end

function av_stream_get_recommended_encoder_configuration(s)
    ccall((:av_stream_get_recommended_encoder_configuration, libavformat), Cstring, (Ptr{AVStream},), s)
end

function av_stream_set_recommended_encoder_configuration(s, configuration)
    ccall((:av_stream_set_recommended_encoder_configuration, libavformat), Cvoid, (Ptr{AVStream}, Cstring), s, configuration)
end

function av_stream_get_parser(s)
    ccall((:av_stream_get_parser, libavformat), Ptr{AVCodecParserContext}, (Ptr{AVStream},), s)
end

"""
    av_stream_get_end_pts(st)

Returns the pts of the last muxed packet + its duration

the retuned value is undefined when used with a demuxer.
"""
function av_stream_get_end_pts(st)
    ccall((:av_stream_get_end_pts, libavformat), Int64, (Ptr{AVStream},), st)
end

# typedef int ( * AVOpenCallback ) ( struct AVFormatContext * s , AVIOContext * * pb , const char * url , int flags , const AVIOInterruptCB * int_cb , AVDictionary * * options )
const AVOpenCallback = Ptr{Cvoid}

"""
    av_format_get_probe_score(s)

Accessors for some [`AVFormatContext`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
"""
function av_format_get_probe_score(s)
    ccall((:av_format_get_probe_score, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

function av_format_get_video_codec(s)
    ccall((:av_format_get_video_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
end

function av_format_set_video_codec(s, c)
    ccall((:av_format_set_video_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
end

function av_format_get_audio_codec(s)
    ccall((:av_format_get_audio_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
end

function av_format_set_audio_codec(s, c)
    ccall((:av_format_set_audio_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
end

function av_format_get_subtitle_codec(s)
    ccall((:av_format_get_subtitle_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
end

function av_format_set_subtitle_codec(s, c)
    ccall((:av_format_set_subtitle_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
end

function av_format_get_data_codec(s)
    ccall((:av_format_get_data_codec, libavformat), Ptr{AVCodec}, (Ptr{AVFormatContext},), s)
end

function av_format_set_data_codec(s, c)
    ccall((:av_format_set_data_codec, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
end

function av_format_get_metadata_header_padding(s)
    ccall((:av_format_get_metadata_header_padding, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

function av_format_set_metadata_header_padding(s, c::Integer)
    ccall((:av_format_set_metadata_header_padding, libavformat), Cvoid, (Ptr{AVFormatContext}, Cint), s, c)
end

function av_format_get_opaque(s)
    ccall((:av_format_get_opaque, libavformat), Ptr{Cvoid}, (Ptr{AVFormatContext},), s)
end

function av_format_set_opaque(s, opaque)
    ccall((:av_format_set_opaque, libavformat), Cvoid, (Ptr{AVFormatContext}, Ptr{Cvoid}), s, opaque)
end

function av_format_get_control_message_cb(s)
    ccall((:av_format_get_control_message_cb, libavformat), av_format_control_message, (Ptr{AVFormatContext},), s)
end

function av_format_set_control_message_cb(s, callback::av_format_control_message)
    ccall((:av_format_set_control_message_cb, libavformat), Cvoid, (Ptr{AVFormatContext}, av_format_control_message), s, callback)
end

function av_format_get_open_cb(s)
    ccall((:av_format_get_open_cb, libavformat), AVOpenCallback, (Ptr{AVFormatContext},), s)
end

function av_format_set_open_cb(s, callback::AVOpenCallback)
    ccall((:av_format_set_open_cb, libavformat), Cvoid, (Ptr{AVFormatContext}, AVOpenCallback), s, callback)
end

"""
    av_format_inject_global_side_data(s)

This function will cause global side data to be injected in the next packet of each stream as well as after any subsequent seek.
"""
function av_format_inject_global_side_data(s)
    ccall((:av_format_inject_global_side_data, libavformat), Cvoid, (Ptr{AVFormatContext},), s)
end

"""
    av_fmt_ctx_get_duration_estimation_method(ctx)

Returns the method used to set ctx->duration.

### Returns
AVFMT\\_DURATION\\_FROM\\_PTS, AVFMT\\_DURATION\\_FROM\\_STREAM, or AVFMT\\_DURATION\\_FROM\\_BITRATE.
"""
function av_fmt_ctx_get_duration_estimation_method(ctx)
    ccall((:av_fmt_ctx_get_duration_estimation_method, libavformat), AVDurationEstimationMethod, (Ptr{AVFormatContext},), ctx)
end

"""
    avformat_version()

Return the [`LIBAVFORMAT_VERSION_INT`](@ref) constant.
"""
function avformat_version()
    ccall((:avformat_version, libavformat), Cuint, ())
end

"""
    avformat_configuration()

Return the libavformat build-time configuration.
"""
function avformat_configuration()
    ccall((:avformat_configuration, libavformat), Cstring, ())
end

"""
    avformat_license()

Return the libavformat license.
"""
function avformat_license()
    ccall((:avformat_license, libavformat), Cstring, ())
end

"""
    av_register_all()

Initialize libavformat and register all the muxers, demuxers and protocols. If you do not call this function, then you can select exactly which formats you want to support.

### See also
[`av_register_input_format`](@ref)(), [`av_register_output_format`](@ref)()
"""
function av_register_all()
    ccall((:av_register_all, libavformat), Cvoid, ())
end

function av_register_input_format(format)
    ccall((:av_register_input_format, libavformat), Cvoid, (Ptr{AVInputFormat},), format)
end

function av_register_output_format(format)
    ccall((:av_register_output_format, libavformat), Cvoid, (Ptr{AVOutputFormat},), format)
end

"""
    avformat_network_init()

Do global initialization of network libraries. This is optional, and not recommended anymore.

This functions only exists to work around thread-safety issues with older GnuTLS or OpenSSL libraries. If libavformat is linked to newer versions of those libraries, or if you do not use them, calling this function is unnecessary. Otherwise, you need to call this function before any other threads using them are started.

This function will be deprecated once support for older GnuTLS and OpenSSL libraries is removed, and this function has no purpose anymore.
"""
function avformat_network_init()
    ccall((:avformat_network_init, libavformat), Cint, ())
end

"""
    avformat_network_deinit()

Undo the initialization done by [`avformat_network_init`](@ref). Call it only once for each time you called [`avformat_network_init`](@ref).
"""
function avformat_network_deinit()
    ccall((:avformat_network_deinit, libavformat), Cint, ())
end

"""
    av_iformat_next(f)

If f is NULL, returns the first registered input format, if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.
"""
function av_iformat_next(f)
    ccall((:av_iformat_next, libavformat), Ptr{AVInputFormat}, (Ptr{AVInputFormat},), f)
end

"""
    av_oformat_next(f)

If f is NULL, returns the first registered output format, if f is non-NULL, returns the next registered output format after f or NULL if f is the last one.
"""
function av_oformat_next(f)
    ccall((:av_oformat_next, libavformat), Ptr{AVOutputFormat}, (Ptr{AVOutputFormat},), f)
end

"""
    av_muxer_iterate(opaque)

Iterate over all registered muxers.

### Parameters
* `opaque`: a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered muxer or NULL when the iteration is finished
"""
function av_muxer_iterate(opaque)
    ccall((:av_muxer_iterate, libavformat), Ptr{AVOutputFormat}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    av_demuxer_iterate(opaque)

Iterate over all registered demuxers.

### Parameters
* `opaque`: a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.

### Returns
the next registered demuxer or NULL when the iteration is finished
"""
function av_demuxer_iterate(opaque)
    ccall((:av_demuxer_iterate, libavformat), Ptr{AVInputFormat}, (Ptr{Ptr{Cvoid}},), opaque)
end

"""
    avformat_alloc_context()

Allocate an [`AVFormatContext`](@ref). [`avformat_free_context`](@ref)() can be used to free the context and everything allocated by the framework within it.
"""
function avformat_alloc_context()
    ccall((:avformat_alloc_context, libavformat), Ptr{AVFormatContext}, ())
end

"""
    avformat_free_context(s)

Free an [`AVFormatContext`](@ref) and all its streams. 

### Parameters
* `s`: context to free
"""
function avformat_free_context(s)
    ccall((:avformat_free_context, libavformat), Cvoid, (Ptr{AVFormatContext},), s)
end

"""
    avformat_get_class()

Get the [`AVClass`](@ref) for [`AVFormatContext`](@ref). It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.

### See also
[`av_opt_find`](@ref)().
"""
function avformat_get_class()
    ccall((:avformat_get_class, libavformat), Ptr{AVClass}, ())
end

"""
    avformat_new_stream(s, c)

Add a new stream to a media file.

When demuxing, it is called by the demuxer in read\\_header(). If the flag [`AVFMTCTX_NOHEADER`](@ref) is set in s.ctx\\_flags, then it may also be called in read\\_packet().

When muxing, should be called by the user before [`avformat_write_header`](@ref)().

User is required to call [`avcodec_close`](@ref)() and [`avformat_free_context`](@ref)() to clean up the allocation by [`avformat_new_stream`](@ref)().

### Parameters
* `s`: media file handle 

* `c`: If non-NULL, the [`AVCodecContext`](@ref) corresponding to the new stream will be initialized to use this codec. This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.

### Returns
newly created stream or NULL on error.
"""
function avformat_new_stream(s, c)
    ccall((:avformat_new_stream, libavformat), Ptr{AVStream}, (Ptr{AVFormatContext}, Ptr{AVCodec}), s, c)
end

"""
    av_stream_add_side_data(st, type::AVPacketSideDataType, data, size::Csize_t)

Wrap an existing array as stream side data.

### Parameters
* `st`: stream 

* `type`: side information type 

* `data`: the side data array. It must be allocated with the [`av_malloc`](@ref)() family of functions. The ownership of the data is transferred to st. 

* `size`: side information size 

### Returns
zero on success, a negative [`AVERROR`](@ref) code on failure. On failure, the stream is unchanged and the data remains owned by the caller.
"""
function av_stream_add_side_data(st, type::AVPacketSideDataType, data, size::Csize_t)
    ccall((:av_stream_add_side_data, libavformat), Cint, (Ptr{AVStream}, AVPacketSideDataType, Ptr{UInt8}, Csize_t), st, type, data, size)
end

"""
    av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Integer)

Allocate new information from stream.

### Parameters
* `stream`: stream 

* `type`: desired side information type 

* `size`: side information size 

### Returns
pointer to fresh allocated data or NULL otherwise
"""
function av_stream_new_side_data(stream, type::AVPacketSideDataType, size::Integer)
    ccall((:av_stream_new_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Cint), stream, type, size)
end

"""
    av_stream_get_side_data(stream, type::AVPacketSideDataType, size)

Get side information from stream.

### Parameters
* `stream`: stream 

* `type`: desired side information type 

* `size`: If supplied, *size will be set to the size of the side data or to zero if the desired side data is not present. 

### Returns
pointer to data if present or NULL otherwise
"""
function av_stream_get_side_data(stream, type::AVPacketSideDataType, size)
    ccall((:av_stream_get_side_data, libavformat), Ptr{UInt8}, (Ptr{AVStream}, AVPacketSideDataType, Ptr{Cint}), stream, type, size)
end

function av_new_program(s, id::Integer)
    ccall((:av_new_program, libavformat), Ptr{AVProgram}, (Ptr{AVFormatContext}, Cint), s, id)
end

"""
    avformat_alloc_output_context2(ctx, oformat, format_name, filename)

Allocate an [`AVFormatContext`](@ref) for an output format. [`avformat_free_context`](@ref)() can be used to free the context and everything allocated by the framework within it.

### Parameters
* `*ctx`: is set to the created format context, or to NULL in case of failure 

* `oformat`: format to use for allocating the context, if NULL format\\_name and filename are used instead 

* `format_name`: the name of output format to use for allocating the context, if NULL filename is used instead 

* `filename`: the name of the filename to use for allocating the context, may be NULL 

### Returns
>= 0 in case of success, a negative [`AVERROR`](@ref) code in case of failure
"""
function avformat_alloc_output_context2(ctx, oformat, format_name, filename)
    ccall((:avformat_alloc_output_context2, libavformat), Cint, (Ptr{Ptr{AVFormatContext}}, Ptr{AVOutputFormat}, Cstring, Cstring), ctx, oformat, format_name, filename)
end

"""
    av_find_input_format(short_name)

Find [`AVInputFormat`](@ref) based on the short name of the input format.
"""
function av_find_input_format(short_name)
    ccall((:av_find_input_format, libavformat), Ptr{AVInputFormat}, (Cstring,), short_name)
end

"""
    av_probe_input_format(pd, is_opened::Integer)

Guess the file format.

### Parameters
* `pd`: data to be probed 

* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed.
"""
function av_probe_input_format(pd, is_opened::Integer)
    ccall((:av_probe_input_format, libavformat), Ptr{AVInputFormat}, (Ptr{AVProbeData}, Cint), pd, is_opened)
end

"""
    av_probe_input_format2(pd, is_opened::Integer, score_max)

Guess the file format.

### Parameters
* `pd`: data to be probed 

* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed. 

* `score_max`: A probe score larger that this is required to accept a detection, the variable is set to the actual detection score afterwards. If the score is <= [`AVPROBE_SCORE_MAX`](@ref) / 4 it is recommended to retry with a larger probe buffer.
"""
function av_probe_input_format2(pd, is_opened::Integer, score_max)
    ccall((:av_probe_input_format2, libavformat), Ptr{AVInputFormat}, (Ptr{AVProbeData}, Cint, Ptr{Cint}), pd, is_opened, score_max)
end

"""
    av_probe_input_format3(pd, is_opened::Integer, score_ret)

Guess the file format.

### Parameters
* `is_opened`: Whether the file is already opened; determines whether demuxers with or without [`AVFMT_NOFILE`](@ref) are probed. 

* `score_ret`: The score of the best detection.
"""
function av_probe_input_format3(pd, is_opened::Integer, score_ret)
    ccall((:av_probe_input_format3, libavformat), Ptr{AVInputFormat}, (Ptr{AVProbeData}, Cint, Ptr{Cint}), pd, is_opened, score_ret)
end

"""
    av_probe_input_buffer2(pb, fmt, url, logctx, offset::Integer, max_probe_size::Integer)

Probe a bytestream to determine the input format. Each time a probe returns with a score that is too low, the probe buffer size is increased and another attempt is made. When the maximum probe size is reached, the input format with the highest score is returned.

### Parameters
* `pb`: the bytestream to probe 

* `fmt`: the input format is put here 

* `url`: the url of the stream 

* `logctx`: the log context 

* `offset`: the offset within the bytestream to probe from 

* `max_probe_size`: the maximum probe buffer size (zero for default) 

### Returns
the score in case of success, a negative value corresponding to an the maximal score is [`AVPROBE_SCORE_MAX`](@ref) [`AVERROR`](@ref) code otherwise
"""
function av_probe_input_buffer2(pb, fmt, url, logctx, offset::Integer, max_probe_size::Integer)
    ccall((:av_probe_input_buffer2, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Ptr{AVInputFormat}}, Cstring, Ptr{Cvoid}, Cuint, Cuint), pb, fmt, url, logctx, offset, max_probe_size)
end

"""
    av_probe_input_buffer(pb, fmt, url, logctx, offset::Integer, max_probe_size::Integer)

Like [`av_probe_input_buffer2`](@ref)() but returns 0 on success
"""
function av_probe_input_buffer(pb, fmt, url, logctx, offset::Integer, max_probe_size::Integer)
    ccall((:av_probe_input_buffer, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Ptr{AVInputFormat}}, Cstring, Ptr{Cvoid}, Cuint, Cuint), pb, fmt, url, logctx, offset, max_probe_size)
end

"""
    avformat_open_input(ps, url, fmt, options)

Open an input stream and read the header. The codecs are not opened. The stream must be closed with [`avformat_close_input`](@ref)().

!!! note

    If you want to use custom IO, preallocate the format context and set its pb field.

### Parameters
* `ps`: Pointer to user-supplied [`AVFormatContext`](@ref) (allocated by [`avformat_alloc_context`](@ref)). May be a pointer to NULL, in which case an [`AVFormatContext`](@ref) is allocated by this function and written into ps. Note that a user-supplied [`AVFormatContext`](@ref) will be freed on failure. 

* `url`: URL of the stream to open. 

* `fmt`: If non-NULL, this parameter forces a specific input format. Otherwise the format is autodetected. 

* `options`: A dictionary filled with [`AVFormatContext`](@ref) and demuxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.

### Returns
0 on success, a negative [`AVERROR`](@ref) on failure.
"""
function avformat_open_input(ps, url, fmt, options)
    ccall((:avformat_open_input, libavformat), Cint, (Ptr{Ptr{AVFormatContext}}, Cstring, Ptr{AVInputFormat}, Ptr{Ptr{AVDictionary}}), ps, url, fmt, options)
end

"""
    av_demuxer_open(ic)

\\deprecated Use an [`AVDictionary`](@ref) to pass options to a demuxer.
"""
function av_demuxer_open(ic)
    ccall((:av_demuxer_open, libavformat), Cint, (Ptr{AVFormatContext},), ic)
end

"""
    avformat_find_stream_info(ic, options)

Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.

!!! note

    this function isn't guaranteed to open all the codecs, so options being non-empty at return is a perfectly normal behavior.

\\todo Let the user decide somehow what information is needed so that we do not waste time getting stuff the user does not need.

### Parameters
* `ic`: media file handle 

* `options`: If non-NULL, an ic.nb\\_streams long array of pointers to dictionaries, where i-th member contains options for codec corresponding to i-th stream. On return each dictionary will be filled with options that were not found. 

### Returns
>=0 if OK, AVERROR\\_xxx on error
"""
function avformat_find_stream_info(ic, options)
    ccall((:avformat_find_stream_info, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), ic, options)
end

"""
    av_find_program_from_stream(ic, last, s::Integer)

Find the programs which belong to a given stream.

### Parameters
* `ic`: media file handle 

* `last`: the last found program, the search will start after this program, or from the beginning if it is NULL 

* `s`: stream index 

### Returns
the next program which belongs to s, NULL if no program is found or the last program is not among the programs of ic.
"""
function av_find_program_from_stream(ic, last, s::Integer)
    ccall((:av_find_program_from_stream, libavformat), Ptr{AVProgram}, (Ptr{AVFormatContext}, Ptr{AVProgram}, Cint), ic, last, s)
end

function av_program_add_stream_index(ac, progid::Integer, idx::Integer)
    ccall((:av_program_add_stream_index, libavformat), Cvoid, (Ptr{AVFormatContext}, Cint, Cuint), ac, progid, idx)
end

"""
    av_find_best_stream(ic, type::AVMediaType, wanted_stream_nb::Integer, related_stream::Integer, decoder_ret, flags::Integer)

Find the "best" stream in the file. The best stream is determined according to various heuristics as the most likely to be what the user expects. If the decoder parameter is non-NULL, [`av_find_best_stream`](@ref) will find the default decoder for the stream's codec; streams for which no decoder can be found are ignored.

!!! note

    If [`av_find_best_stream`](@ref) returns successfully and decoder\\_ret is not NULL, then *decoder\\_ret is guaranteed to be set to a valid [`AVCodec`](@ref).

### Parameters
* `ic`: media file handle 

* `type`: stream type: video, audio, subtitles, etc. 

* `wanted_stream_nb`: user-requested stream number, or -1 for automatic selection 

* `related_stream`: try to find a stream related (eg. in the same program) to this one, or -1 if none 

* `decoder_ret`: if non-NULL, returns the decoder for the selected stream 

* `flags`: flags; none are currently defined 

### Returns
the non-negative stream number in case of success, [`AVERROR_STREAM_NOT_FOUND`](@ref) if no stream with the requested type could be found, [`AVERROR_DECODER_NOT_FOUND`](@ref) if streams were found but no decoder 
"""
function av_find_best_stream(ic, type::AVMediaType, wanted_stream_nb::Integer, related_stream::Integer, decoder_ret, flags::Integer)
    ccall((:av_find_best_stream, libavformat), Cint, (Ptr{AVFormatContext}, AVMediaType, Cint, Cint, Ptr{Ptr{AVCodec}}, Cint), ic, type, wanted_stream_nb, related_stream, decoder_ret, flags)
end

"""
    av_read_frame(s, pkt)

Return the next frame of a stream. This function returns what is stored in the file, and does not validate that what is there are valid frames for the decoder. It will split what is stored in the file into frames and return one for each call. It will not omit invalid data between valid frames so as to give the decoder the maximum information possible for decoding.

On success, the returned packet is reference-counted (pkt->buf is set) and valid indefinitely. The packet must be freed with [`av_packet_unref`](@ref)() when it is no longer needed. For video, the packet contains exactly one frame. For audio, it contains an integer number of frames if each frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames have a variable size (e.g. MPEG audio), then it contains one frame.

pkt->pts, pkt->dts and pkt->duration are always set to correct values in [`AVStream`](@ref).time\\_base units (and guessed if the format cannot provide them). pkt->pts can be [`AV_NOPTS_VALUE`](@ref) if the video format has B-frames, so it is better to rely on pkt->dts if you do not decompress the payload.

!!! note

    pkt will be initialized, so it may be uninitialized, but it must not contain data that needs to be freed.

### Returns
0 if OK, < 0 on error or end of file. On error, pkt will be blank (as if it came from [`av_packet_alloc`](@ref)()).
"""
function av_read_frame(s, pkt)
    ccall((:av_read_frame, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVPacket}), s, pkt)
end

"""
    av_seek_frame(s, stream_index::Integer, timestamp::Int64, flags::Integer)

Seek to the keyframe at timestamp. 'timestamp' in 'stream\\_index'.

### Parameters
* `s`: media file handle 

* `stream_index`: If stream\\_index is (-1), a default stream is selected, and timestamp is automatically converted from [`AV_TIME_BASE`](@ref) units to the stream specific time\\_base. 

* `timestamp`: Timestamp in [`AVStream`](@ref).time\\_base units or, if no stream is specified, in [`AV_TIME_BASE`](@ref) units. 

* `flags`: flags which select direction and seeking mode 

### Returns
>= 0 on success
"""
function av_seek_frame(s, stream_index::Integer, timestamp::Int64, flags::Integer)
    ccall((:av_seek_frame, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Int64, Cint), s, stream_index, timestamp, flags)
end

"""
    avformat_seek_file(s, stream_index::Integer, min_ts::Int64, ts::Int64, max_ts::Int64, flags::Integer)

Seek to timestamp ts. Seeking will be done so that the point from which all active streams can be presented successfully will be closest to ts and within min/max\\_ts. Active streams are all streams that have [`AVStream`](@ref).discard < AVDISCARD\\_ALL.

If flags contain [`AVSEEK_FLAG_BYTE`](@ref), then all timestamps are in bytes and are the file position (this may not be supported by all demuxers). If flags contain [`AVSEEK_FLAG_FRAME`](@ref), then all timestamps are in frames in the stream with stream\\_index (this may not be supported by all demuxers). Otherwise all timestamps are in units of the stream selected by stream\\_index or if stream\\_index is -1, in [`AV_TIME_BASE`](@ref) units. If flags contain [`AVSEEK_FLAG_ANY`](@ref), then non-keyframes are treated as keyframes (this may not be supported by all demuxers). If flags contain [`AVSEEK_FLAG_BACKWARD`](@ref), it is ignored.

!!! note

    This is part of the new seek API which is still under construction.

### Parameters
* `s`: media file handle 

* `stream_index`: index of the stream which is used as time base reference 

* `min_ts`: smallest acceptable timestamp 

* `ts`: target timestamp 

* `max_ts`: largest acceptable timestamp 

* `flags`: flags 

### Returns
>=0 on success, error code otherwise
"""
function avformat_seek_file(s, stream_index::Integer, min_ts::Int64, ts::Int64, max_ts::Int64, flags::Integer)
    ccall((:avformat_seek_file, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Int64, Int64, Int64, Cint), s, stream_index, min_ts, ts, max_ts, flags)
end

"""
    avformat_flush(s)

Discard all internally buffered data. This can be useful when dealing with discontinuities in the byte stream. Generally works only with formats that can resync. This includes headerless formats like MPEG-TS/TS but should also work with NUT, Ogg and in a limited way AVI for example.

The set of streams, the detected duration, stream parameters and codecs do not change when calling this function. If you want a complete reset, it's better to open a new [`AVFormatContext`](@ref).

This does not flush the [`AVIOContext`](@ref) (s->pb). If necessary, call [`avio_flush`](@ref)(s->pb) before calling this function.

### Parameters
* `s`: media file handle 

### Returns
>=0 on success, error code otherwise
"""
function avformat_flush(s)
    ccall((:avformat_flush, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    av_read_play(s)

Start playing a network-based stream (e.g. RTSP stream) at the current position.
"""
function av_read_play(s)
    ccall((:av_read_play, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    av_read_pause(s)

Pause a network-based stream (e.g. RTSP stream).

Use [`av_read_play`](@ref)() to resume it.
"""
function av_read_pause(s)
    ccall((:av_read_pause, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    avformat_close_input(s)

Close an opened input [`AVFormatContext`](@ref). Free it and all its contents and set *s to NULL.
"""
function avformat_close_input(s)
    ccall((:avformat_close_input, libavformat), Cvoid, (Ptr{Ptr{AVFormatContext}},), s)
end

"""
    avformat_write_header(s, options)

Allocate the stream private data and write the stream header to an output media file.

### Parameters
* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened [`AVIOContext`](@ref). 

* `options`: An [`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.

### Returns
[`AVSTREAM_INIT_IN_WRITE_HEADER`](@ref) on success if the codec had not already been fully initialized in avformat\\_init, [`AVSTREAM_INIT_IN_INIT_OUTPUT`](@ref) on success if the codec had already been fully initialized in avformat\\_init, negative [`AVERROR`](@ref) on failure.

### See also
[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), [`av_oformat_next`](@ref), [`avformat_init_output`](@ref).
"""
function avformat_write_header(s, options)
    ccall((:avformat_write_header, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), s, options)
end

"""
    avformat_init_output(s, options)

Allocate the stream private data and initialize the codec, but do not write the header. May optionally be used before [`avformat_write_header`](@ref) to initialize stream parameters before actually writing the header. If using this function, do not pass the same options to [`avformat_write_header`](@ref).

### Parameters
* `s`: Media file handle, must be allocated with [`avformat_alloc_context`](@ref)(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened [`AVIOContext`](@ref). 

* `options`: An [`AVDictionary`](@ref) filled with [`AVFormatContext`](@ref) and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.

### Returns
[`AVSTREAM_INIT_IN_WRITE_HEADER`](@ref) on success if the codec requires [`avformat_write_header`](@ref) to fully initialize, [`AVSTREAM_INIT_IN_INIT_OUTPUT`](@ref) on success if the codec has been fully initialized, negative [`AVERROR`](@ref) on failure.

### See also
[`av_opt_find`](@ref), [`av_dict_set`](@ref), [`avio_open`](@ref), [`av_oformat_next`](@ref), [`avformat_write_header`](@ref).
"""
function avformat_init_output(s, options)
    ccall((:avformat_init_output, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{Ptr{AVDictionary}}), s, options)
end

"""
    av_write_frame(s, pkt)

Write a packet to an output media file.

This function passes the packet directly to the muxer, without any buffering or reordering. The caller is responsible for correctly interleaving the packets if the format requires it. Callers that want libavformat to handle the interleaving should call [`av_interleaved_write_frame`](@ref)() instead of this function.

### Parameters
* `s`: media file handle 

* `pkt`: The packet containing the data to be written. Note that unlike [`av_interleaved_write_frame`](@ref)(), this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet). <br> This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets passed to this function must be strictly increasing when compared in their respective timebases (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration") should also be set if known. 

### Returns
< 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush

### See also
[`av_interleaved_write_frame`](@ref)()
"""
function av_write_frame(s, pkt)
    ccall((:av_write_frame, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVPacket}), s, pkt)
end

"""
    av_interleaved_write_frame(s, pkt)

Write a packet to an output media file ensuring correct interleaving.

This function will buffer the packets internally as needed to make sure the packets in the output file are properly interleaved in the order of increasing dts. Callers doing their own interleaving should call [`av_write_frame`](@ref)() instead of this function.

Using this function instead of [`av_write_frame`](@ref)() can give muxers advance knowledge of future packets, improving e.g. the behaviour of the mp4 muxer for VFR content in fragmenting mode.

### Parameters
* `s`: media file handle 

* `pkt`: The packet containing the data to be written. <br> If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. The caller must not access the data through this reference after this function returns. If the packet is not reference-counted, libavformat will make a copy. <br> This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues. <br> Packet's AVPacket.stream_index "stream\\_index" field must be set to the index of the corresponding stream in AVFormatContext.streams "s->streams". <br> The timestamps (AVPacket.pts "pts", AVPacket.dts "dts") must be set to correct values in the stream's timebase (unless the output format is flagged with the [`AVFMT_NOTIMESTAMPS`](@ref) flag, then they can be set to [`AV_NOPTS_VALUE`](@ref)). The dts for subsequent packets in one stream must be strictly increasing (unless the output format is flagged with the [`AVFMT_TS_NONSTRICT`](@ref), then they merely have to be nondecreasing). AVPacket.duration "duration") should also be set if known.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error. Libavformat will always take care of freeing the packet, even if this function fails.

### See also
[`av_write_frame`](@ref)(), [`AVFormatContext`](@ref).max\\_interleave\\_delta
"""
function av_interleaved_write_frame(s, pkt)
    ccall((:av_interleaved_write_frame, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVPacket}), s, pkt)
end

"""
    av_write_uncoded_frame(s, stream_index::Integer, frame)

Write an uncoded frame to an output media file.

The frame must be correctly interleaved according to the container specification; if not, [`av_interleaved_write_uncoded_frame`](@ref)() must be used.

See [`av_interleaved_write_uncoded_frame`](@ref)() for details.
"""
function av_write_uncoded_frame(s, stream_index::Integer, frame)
    ccall((:av_write_uncoded_frame, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Ptr{AVFrame}), s, stream_index, frame)
end

"""
    av_interleaved_write_uncoded_frame(s, stream_index::Integer, frame)

Write an uncoded frame to an output media file.

If the muxer supports it, this function makes it possible to write an [`AVFrame`](@ref) structure directly, without encoding it into a packet. It is mostly useful for devices and similar special muxers that use raw video or PCM data and will not serialize it into a byte stream.

To test whether it is possible to use it with a given muxer and stream, use [`av_write_uncoded_frame_query`](@ref)().

The caller gives up ownership of the frame and must not access it afterwards.

### Returns
>=0 for success, a negative code on error
"""
function av_interleaved_write_uncoded_frame(s, stream_index::Integer, frame)
    ccall((:av_interleaved_write_uncoded_frame, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Ptr{AVFrame}), s, stream_index, frame)
end

"""
    av_write_uncoded_frame_query(s, stream_index::Integer)

Test whether a muxer supports uncoded frame.

### Returns
>=0 if an uncoded frame can be written to that muxer and stream, <0 if not
"""
function av_write_uncoded_frame_query(s, stream_index::Integer)
    ccall((:av_write_uncoded_frame_query, libavformat), Cint, (Ptr{AVFormatContext}, Cint), s, stream_index)
end

"""
    av_write_trailer(s)

Write the stream trailer to an output media file and free the file private data.

May only be called after a successful call to [`avformat_write_header`](@ref).

### Parameters
* `s`: media file handle 

### Returns
0 if OK, AVERROR\\_xxx on error
"""
function av_write_trailer(s)
    ccall((:av_write_trailer, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    av_guess_format(short_name, filename, mime_type)

Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match.

### Parameters
* `short_name`: if non-NULL checks if short\\_name matches with the names of the registered formats 

* `filename`: if non-NULL checks if filename terminates with the extensions of the registered formats 

* `mime_type`: if non-NULL checks if mime\\_type matches with the MIME type of the registered formats
"""
function av_guess_format(short_name, filename, mime_type)
    ccall((:av_guess_format, libavformat), Ptr{AVOutputFormat}, (Cstring, Cstring, Cstring), short_name, filename, mime_type)
end

"""
    av_guess_codec(fmt, short_name, filename, mime_type, type::AVMediaType)

Guess the codec ID based upon muxer and filename.
"""
function av_guess_codec(fmt, short_name, filename, mime_type, type::AVMediaType)
    ccall((:av_guess_codec, libavformat), AVCodecID, (Ptr{AVOutputFormat}, Cstring, Cstring, Cstring, AVMediaType), fmt, short_name, filename, mime_type, type)
end

"""
    av_get_output_timestamp(s, stream::Integer, dts, wall)

Get timing information for the data currently output. The exact meaning of "currently output" depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time. 

### Parameters
* `s`: media file handle 

* `stream`: stream in the media file 

* `dts`:\\[out\\] DTS of the last packet output for the stream, in stream time\\_base units 

* `wall`:\\[out\\] absolute time when that packet whas output, in microsecond 

### Returns
0 if OK, [`AVERROR`](@ref)(ENOSYS) if the format does not support it Note: some formats or devices may not allow to measure dts and wall atomically.
"""
function av_get_output_timestamp(s, stream::Integer, dts, wall)
    ccall((:av_get_output_timestamp, libavformat), Cint, (Ptr{AVFormatContext}, Cint, Ptr{Int64}, Ptr{Int64}), s, stream, dts, wall)
end

"""
    av_hex_dump(f, buf, size::Integer)

Send a nice hexadecimal dump of a buffer to the specified file stream.

### Parameters
* `f`: The file stream pointer where the dump should be sent to. 

* `buf`: buffer 

* `size`: buffer size

### See also
[`av_hex_dump_log`](@ref), [`av_pkt_dump2`](@ref), [`av_pkt_dump_log2`](@ref)
"""
function av_hex_dump(f, buf, size::Integer)
    ccall((:av_hex_dump, libavformat), Cvoid, (Ptr{Libc.FILE}, Ptr{UInt8}, Cint), f, buf, size)
end

"""
    av_hex_dump_log(avcl, level::Integer, buf, size::Integer)

Send a nice hexadecimal dump of a buffer to the log.

### Parameters
* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct. 

* `level`: The importance level of the message, lower values signifying higher importance. 

* `buf`: buffer 

* `size`: buffer size

### See also
[`av_hex_dump`](@ref), [`av_pkt_dump2`](@ref), [`av_pkt_dump_log2`](@ref)
"""
function av_hex_dump_log(avcl, level::Integer, buf, size::Integer)
    ccall((:av_hex_dump_log, libavformat), Cvoid, (Ptr{Cvoid}, Cint, Ptr{UInt8}, Cint), avcl, level, buf, size)
end

"""
    av_pkt_dump2(f, pkt, dump_payload::Integer, st)

Send a nice dump of a packet to the specified file stream.

### Parameters
* `f`: The file stream pointer where the dump should be sent to. 

* `pkt`: packet to dump 

* `dump_payload`: True if the payload must be displayed, too. 

* `st`: [`AVStream`](@ref) that the packet belongs to
"""
function av_pkt_dump2(f, pkt, dump_payload::Integer, st)
    ccall((:av_pkt_dump2, libavformat), Cvoid, (Ptr{Libc.FILE}, Ptr{AVPacket}, Cint, Ptr{AVStream}), f, pkt, dump_payload, st)
end

"""
    av_pkt_dump_log2(avcl, level::Integer, pkt, dump_payload::Integer, st)

Send a nice dump of a packet to the log.

### Parameters
* `avcl`: A pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct. 

* `level`: The importance level of the message, lower values signifying higher importance. 

* `pkt`: packet to dump 

* `dump_payload`: True if the payload must be displayed, too. 

* `st`: [`AVStream`](@ref) that the packet belongs to
"""
function av_pkt_dump_log2(avcl, level::Integer, pkt, dump_payload::Integer, st)
    ccall((:av_pkt_dump_log2, libavformat), Cvoid, (Ptr{Cvoid}, Cint, Ptr{AVPacket}, Cint, Ptr{AVStream}), avcl, level, pkt, dump_payload, st)
end

"""
    av_codec_get_id(tags, tag::Integer)

Get the [`AVCodecID`](@ref) for the given codec tag tag. If no codec id is found returns AV\\_CODEC\\_ID\\_NONE.

### Parameters
* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 

* `tag`: codec tag to match to a codec ID
"""
function av_codec_get_id(tags, tag::Integer)
    ccall((:av_codec_get_id, libavformat), AVCodecID, (Ptr{Ptr{AVCodecTag}}, Cuint), tags, tag)
end

"""
    av_codec_get_tag(tags, id::AVCodecID)

Get the codec tag for the given codec id id. If no codec tag is found returns 0.

### Parameters
* `tags`: list of supported codec\\_id-codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 

* `id`: codec ID to match to a codec tag
"""
function av_codec_get_tag(tags, id::AVCodecID)
    ccall((:av_codec_get_tag, libavformat), Cuint, (Ptr{Ptr{AVCodecTag}}, AVCodecID), tags, id)
end

"""
    av_codec_get_tag2(tags, id::AVCodecID, tag)

Get the codec tag for the given codec id.

### Parameters
* `tags`: list of supported codec\\_id - codec\\_tag pairs, as stored in [`AVInputFormat`](@ref).codec\\_tag and [`AVOutputFormat`](@ref).codec\\_tag 

* `id`: codec id that should be searched for in the list 

* `tag`: A pointer to the found tag 

### Returns
0 if id was not found in tags, > 0 if it was found
"""
function av_codec_get_tag2(tags, id::AVCodecID, tag)
    ccall((:av_codec_get_tag2, libavformat), Cint, (Ptr{Ptr{AVCodecTag}}, AVCodecID, Ptr{Cuint}), tags, id, tag)
end

function av_find_default_stream_index(s)
    ccall((:av_find_default_stream_index, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    av_index_search_timestamp(st, timestamp::Int64, flags::Integer)

Get the index for a specific timestamp.

### Parameters
* `st`: stream that the timestamp belongs to 

* `timestamp`: timestamp to retrieve the index for 

* `flags`: if [`AVSEEK_FLAG_BACKWARD`](@ref) then the returned index will correspond to the timestamp which is <= the requested one, if backward is 0, then it will be >= if [`AVSEEK_FLAG_ANY`](@ref) seek to any frame, only keyframes otherwise 

### Returns
< 0 if no such timestamp could be found
"""
function av_index_search_timestamp(st, timestamp::Int64, flags::Integer)
    ccall((:av_index_search_timestamp, libavformat), Cint, (Ptr{AVStream}, Int64, Cint), st, timestamp, flags)
end

"""
    av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)

Add an index entry into a sorted list. Update the entry if the list already contains it.

### Parameters
* `timestamp`: timestamp in the time base of the given stream
"""
function av_add_index_entry(st, pos::Int64, timestamp::Int64, size::Integer, distance::Integer, flags::Integer)
    ccall((:av_add_index_entry, libavformat), Cint, (Ptr{AVStream}, Int64, Int64, Cint, Cint, Cint), st, pos, timestamp, size, distance, flags)
end

"""
    av_url_split(proto, proto_size::Integer, authorization, authorization_size::Integer, hostname, hostname_size::Integer, port_ptr, path, path_size::Integer, url)

Split a URL string into components.

The pointers to buffers for storing individual components may be null, in order to ignore that component. Buffers for components not found are set to empty strings. If the port is not found, it is set to a negative value.

### Parameters
* `proto`: the buffer for the protocol 

* `proto_size`: the size of the proto buffer 

* `authorization`: the buffer for the authorization 

* `authorization_size`: the size of the authorization buffer 

* `hostname`: the buffer for the host name 

* `hostname_size`: the size of the hostname buffer 

* `port_ptr`: a pointer to store the port number in 

* `path`: the buffer for the path 

* `path_size`: the size of the path buffer 

* `url`: the URL to split
"""
function av_url_split(proto, proto_size::Integer, authorization, authorization_size::Integer, hostname, hostname_size::Integer, port_ptr, path, path_size::Integer, url)
    ccall((:av_url_split, libavformat), Cvoid, (Cstring, Cint, Cstring, Cint, Cstring, Cint, Ptr{Cint}, Cstring, Cint, Cstring), proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url)
end

"""
    av_dump_format(ic, index::Integer, url, is_output::Integer)

Print detailed information about the input or output format, such as duration, bitrate, streams, container, programs, metadata, side data, codec and time base.

### Parameters
* `ic`: the context to analyze 

* `index`: index of the stream to dump information about 

* `url`: the URL to print, such as source or destination file 

* `is_output`: Select whether the specified context is an input(0) or output(1)
"""
function av_dump_format(ic, index::Integer, url, is_output::Integer)
    ccall((:av_dump_format, libavformat), Cvoid, (Ptr{AVFormatContext}, Cint, Cstring, Cint), ic, index, url, is_output)
end

"""
    av_get_frame_filename2(buf, buf_size::Integer, path, number::Integer, flags::Integer)

Return in 'buf' the path with 'd' replaced by a number.

Also handles the '0nd' format where 'n' is the total number of digits and '%%'.

### Parameters
* `buf`: destination buffer 

* `buf_size`: destination buffer size 

* `path`: numbered sequence string 

* `number`: frame number 

* `flags`: AV\\_FRAME\\_FILENAME\\_FLAGS\\_* 

### Returns
0 if OK, -1 on format error
"""
function av_get_frame_filename2(buf, buf_size::Integer, path, number::Integer, flags::Integer)
    ccall((:av_get_frame_filename2, libavformat), Cint, (Cstring, Cint, Cstring, Cint, Cint), buf, buf_size, path, number, flags)
end

function av_get_frame_filename(buf, buf_size::Integer, path, number::Integer)
    ccall((:av_get_frame_filename, libavformat), Cint, (Cstring, Cint, Cstring, Cint), buf, buf_size, path, number)
end

"""
    av_filename_number_test(filename)

Check whether filename actually is a numbered sequence generator.

### Parameters
* `filename`: possible numbered sequence string 

### Returns
1 if a valid numbered sequence string, 0 otherwise
"""
function av_filename_number_test(filename)
    ccall((:av_filename_number_test, libavformat), Cint, (Cstring,), filename)
end

"""
    av_sdp_create(ac, n_files::Integer, buf, size::Integer)

Generate an SDP for an RTP session.

Note, this overwrites the id values of AVStreams in the muxer contexts for getting unique dynamic payload types.

### Parameters
* `ac`: array of AVFormatContexts describing the RTP streams. If the array is composed by only one context, such context can contain multiple AVStreams (one [`AVStream`](@ref) per RTP stream). Otherwise, all the contexts in the array (an [`AVCodecContext`](@ref) per RTP stream) must contain only one [`AVStream`](@ref). 

* `n_files`: number of AVCodecContexts contained in ac 

* `buf`: buffer where the SDP will be stored (must be allocated by the caller) 

* `size`: the size of the buffer 

### Returns
0 if OK, AVERROR\\_xxx on error
"""
function av_sdp_create(ac, n_files::Integer, buf, size::Integer)
    ccall((:av_sdp_create, libavformat), Cint, (Ptr{Ptr{AVFormatContext}}, Cint, Cstring, Cint), ac, n_files, buf, size)
end

"""
    av_match_ext(filename, extensions)

Return a positive value if the given filename has one of the given extensions, 0 otherwise.

### Parameters
* `filename`: file name to check against the given extensions 

* `extensions`: a comma-separated list of filename extensions
"""
function av_match_ext(filename, extensions)
    ccall((:av_match_ext, libavformat), Cint, (Cstring, Cstring), filename, extensions)
end

"""
    avformat_query_codec(ofmt, codec_id::AVCodecID, std_compliance::Integer)

Test if the given container can store a codec.

### Parameters
* `ofmt`: container to check for compatibility 

* `codec_id`: codec to potentially store in container 

* `std_compliance`: standards compliance level, one of FF\\_COMPLIANCE\\_*

### Returns
1 if codec with ID codec\\_id can be stored in ofmt, 0 if it cannot. A negative number if this information is not available.
"""
function avformat_query_codec(ofmt, codec_id::AVCodecID, std_compliance::Integer)
    ccall((:avformat_query_codec, libavformat), Cint, (Ptr{AVOutputFormat}, AVCodecID, Cint), ofmt, codec_id, std_compliance)
end

"""
    avformat_get_riff_video_tags()

` riff_fourcc RIFF FourCCs`

@{ Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are meant to be passed to [`av_codec_get_id`](@ref)()/[`av_codec_get_tag`](@ref)() as in the following code: 

```c++
 uint32_t tag = MKTAG('H', '2', '6', '4');
 const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
 enum AVCodecID id = av_codec_get_id(table, tag);
```

### Returns
the table mapping RIFF FourCCs for video to libavcodec [`AVCodecID`](@ref).
"""
function avformat_get_riff_video_tags()
    ccall((:avformat_get_riff_video_tags, libavformat), Ptr{AVCodecTag}, ())
end

"""
    avformat_get_riff_audio_tags()

### Returns
the table mapping RIFF FourCCs for audio to [`AVCodecID`](@ref).
"""
function avformat_get_riff_audio_tags()
    ccall((:avformat_get_riff_audio_tags, libavformat), Ptr{AVCodecTag}, ())
end

"""
    avformat_get_mov_video_tags()

### Returns
the table mapping MOV FourCCs for video to libavcodec [`AVCodecID`](@ref).
"""
function avformat_get_mov_video_tags()
    ccall((:avformat_get_mov_video_tags, libavformat), Ptr{AVCodecTag}, ())
end

"""
    avformat_get_mov_audio_tags()

### Returns
the table mapping MOV FourCCs for audio to [`AVCodecID`](@ref).
"""
function avformat_get_mov_audio_tags()
    ccall((:avformat_get_mov_audio_tags, libavformat), Ptr{AVCodecTag}, ())
end

"""
    av_guess_sample_aspect_ratio(format, stream, frame)

Guess the sample aspect ratio of a frame, based on both the stream and the frame aspect ratio.

Since the frame aspect ratio is set by the codec but the stream aspect ratio is set by the demuxer, these two may not be equal. This function tries to return the value that you should use if you would like to display the frame.

Basic logic is to use the stream aspect ratio if it is set to something sane otherwise use the frame aspect ratio. This way a container setting, which is usually easy to modify can override the coded value in the frames.

### Parameters
* `format`: the format context which the stream is part of 

* `stream`: the stream which the frame is part of 

* `frame`: the frame with the aspect ratio to be determined 

### Returns
the guessed (valid) sample\\_aspect\\_ratio, 0/1 if no idea
"""
function av_guess_sample_aspect_ratio(format, stream, frame)
    ccall((:av_guess_sample_aspect_ratio, libavformat), AVRational, (Ptr{AVFormatContext}, Ptr{AVStream}, Ptr{AVFrame}), format, stream, frame)
end

"""
    av_guess_frame_rate(ctx, stream, frame)

Guess the frame rate, based on both the container and codec information.

### Parameters
* `ctx`: the format context which the stream is part of 

* `stream`: the stream which the frame is part of 

* `frame`: the frame for which the frame rate should be determined, may be NULL 

### Returns
the guessed (valid) frame rate, 0/1 if no idea
"""
function av_guess_frame_rate(ctx, stream, frame)
    ccall((:av_guess_frame_rate, libavformat), AVRational, (Ptr{AVFormatContext}, Ptr{AVStream}, Ptr{AVFrame}), ctx, stream, frame)
end

"""
    avformat_match_stream_specifier(s, st, spec)

Check if the stream st contained in s is matched by the stream specifier spec.

See the "stream specifiers" chapter in the documentation for the syntax of spec.

!!! note

    A stream specifier can match several streams in the format.

### Returns
>0 if st is matched by spec; 0 if st is not matched by spec; [`AVERROR`](@ref) code if spec is invalid
"""
function avformat_match_stream_specifier(s, st, spec)
    ccall((:avformat_match_stream_specifier, libavformat), Cint, (Ptr{AVFormatContext}, Ptr{AVStream}, Cstring), s, st, spec)
end

function avformat_queue_attached_pictures(s)
    ccall((:avformat_queue_attached_pictures, libavformat), Cint, (Ptr{AVFormatContext},), s)
end

"""
    av_apply_bitstream_filters(codec, pkt, bsfc)

Apply a list of bitstream filters to a packet.

### Parameters
* `codec`: [`AVCodecContext`](@ref), usually from an [`AVStream`](@ref) 

* `pkt`: the packet to apply filters to. If, on success, the returned packet has size == 0 and side\\_data\\_elems == 0, it indicates that the packet should be dropped 

* `bsfc`: a NULL-terminated list of filters to apply 

### Returns
>=0 on success; [`AVERROR`](@ref) code on failure
"""
function av_apply_bitstream_filters(codec, pkt, bsfc)
    ccall((:av_apply_bitstream_filters, libavformat), Cint, (Ptr{AVCodecContext}, Ptr{AVPacket}, Ptr{AVBitStreamFilterContext}), codec, pkt, bsfc)
end

const AVTimebaseSource = Int32
const AVFMT_TBCF_AUTO = -1 % Int32
const AVFMT_TBCF_DECODER = 0 % Int32
const AVFMT_TBCF_DEMUXER = 1 % Int32
const AVFMT_TBCF_R_FRAMERATE = 2 % Int32

"""
    avformat_transfer_internal_stream_timing_info(ofmt, ost, ist, copy_tb::AVTimebaseSource)

Transfer internal timing information from one stream to another.

This function is useful when doing stream copy.

### Parameters
* `ofmt`: target output format for ost 

* `ost`: output stream which needs timings copy and adjustments 

* `ist`: reference input stream to copy timings from 

* `copy_tb`: define from where the stream codec timebase needs to be imported
"""
function avformat_transfer_internal_stream_timing_info(ofmt, ost, ist, copy_tb::AVTimebaseSource)
    ccall((:avformat_transfer_internal_stream_timing_info, libavformat), Cint, (Ptr{AVOutputFormat}, Ptr{AVStream}, Ptr{AVStream}, AVTimebaseSource), ofmt, ost, ist, copy_tb)
end

"""
    av_stream_get_codec_timebase(st)

Get the internal codec timebase from a stream.

### Parameters
* `st`: input stream to extract the timebase from
"""
function av_stream_get_codec_timebase(st)
    ccall((:av_stream_get_codec_timebase, libavformat), AVRational, (Ptr{AVStream},), st)
end

"""
    avio_print_string_array(s, strings)

Write a NULL terminated array of strings to the context. Usually you don't need to use this function directly but its macro wrapper, [`avio_print`](@ref).
"""
function avio_print_string_array(s, strings)
    ccall((:avio_print_string_array, libavformat), Cvoid, (Ptr{AVIOContext}, Ptr{Cstring}), s, strings)
end

"""
    AVIODirEntryType

Directory entry types.
"""
const AVIODirEntryType = UInt32
const AVIO_ENTRY_UNKNOWN = 0 % UInt32
const AVIO_ENTRY_BLOCK_DEVICE = 1 % UInt32
const AVIO_ENTRY_CHARACTER_DEVICE = 2 % UInt32
const AVIO_ENTRY_DIRECTORY = 3 % UInt32
const AVIO_ENTRY_NAMED_PIPE = 4 % UInt32
const AVIO_ENTRY_SYMBOLIC_LINK = 5 % UInt32
const AVIO_ENTRY_SOCKET = 6 % UInt32
const AVIO_ENTRY_FILE = 7 % UInt32
const AVIO_ENTRY_SERVER = 8 % UInt32
const AVIO_ENTRY_SHARE = 9 % UInt32
const AVIO_ENTRY_WORKGROUP = 10 % UInt32

"""
    AVIODirEntry

Describes single entry of the directory.

Only name and type fields are guaranteed be set. Rest of fields are protocol or/and platform dependent and might be unknown.
"""
struct AVIODirEntry
    name::Cstring
    type::Cint
    utf8::Cint
    size::Int64
    modification_timestamp::Int64
    access_timestamp::Int64
    status_change_timestamp::Int64
    user_id::Int64
    group_id::Int64
    filemode::Int64
end

mutable struct URLContext end

struct AVIODirContext
    url_context::Ptr{URLContext}
end

"""
    avio_find_protocol_name(url)

Return the name of the protocol that will handle the passed URL.

NULL is returned if no protocol could be found for the given URL.

### Returns
Name of the protocol or NULL.
"""
function avio_find_protocol_name(url)
    ccall((:avio_find_protocol_name, libavformat), Cstring, (Cstring,), url)
end

"""
    avio_check(url, flags::Integer)

Return AVIO\\_FLAG\\_* access flags corresponding to the access permissions of the resource in url, or a negative value corresponding to an [`AVERROR`](@ref) code in case of failure. The returned access flags are masked by the value in flags.

!!! note

    This function is intrinsically unsafe, in the sense that the checked resource may change its existence or permission status from one call to another. Thus you should not trust the returned value, unless you are sure that no other processes are accessing the checked resource.
"""
function avio_check(url, flags::Integer)
    ccall((:avio_check, libavformat), Cint, (Cstring, Cint), url, flags)
end

"""
    avpriv_io_move(url_src, url_dst)

Move or rename a resource.

!!! note

    url\\_src and url\\_dst should share the same protocol and authority.

### Parameters
* `url_src`: url to resource to be moved 

* `url_dst`: new url to resource if the operation succeeded 

### Returns
>=0 on success or negative on error.
"""
function avpriv_io_move(url_src, url_dst)
    ccall((:avpriv_io_move, libavformat), Cint, (Cstring, Cstring), url_src, url_dst)
end

"""
    avpriv_io_delete(url)

Delete a resource.

### Parameters
* `url`: resource to be deleted. 

### Returns
>=0 on success or negative on error.
"""
function avpriv_io_delete(url)
    ccall((:avpriv_io_delete, libavformat), Cint, (Cstring,), url)
end

"""
    avio_open_dir(s, url, options)

Open directory for reading.

### Parameters
* `s`: directory read context. Pointer to a NULL pointer must be passed. 

* `url`: directory to be listed. 

* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dictionary containing options that were not found. May be NULL. 

### Returns
>=0 on success or negative on error.
"""
function avio_open_dir(s, url, options)
    ccall((:avio_open_dir, libavformat), Cint, (Ptr{Ptr{AVIODirContext}}, Cstring, Ptr{Ptr{AVDictionary}}), s, url, options)
end

"""
    avio_read_dir(s, next)

Get next directory entry.

Returned entry must be freed with [`avio_free_directory_entry`](@ref)(). In particular it may outlive [`AVIODirContext`](@ref).

### Parameters
* `s`: directory read context. 

* `next`:\\[out\\] next entry or NULL when no more entries. 

### Returns
>=0 on success or negative on error. End of list is not considered an error.
"""
function avio_read_dir(s, next)
    ccall((:avio_read_dir, libavformat), Cint, (Ptr{AVIODirContext}, Ptr{Ptr{AVIODirEntry}}), s, next)
end

"""
    avio_close_dir(s)

Close directory.

!!! note

    Entries created using [`avio_read_dir`](@ref)() are not deleted and must be freeded with [`avio_free_directory_entry`](@ref)().

### Parameters
* `s`: directory read context. 

### Returns
>=0 on success or negative on error.
"""
function avio_close_dir(s)
    ccall((:avio_close_dir, libavformat), Cint, (Ptr{Ptr{AVIODirContext}},), s)
end

"""
    avio_free_directory_entry(entry)

Free entry allocated by [`avio_read_dir`](@ref)().

### Parameters
* `entry`: entry to be freed.
"""
function avio_free_directory_entry(entry)
    ccall((:avio_free_directory_entry, libavformat), Cvoid, (Ptr{Ptr{AVIODirEntry}},), entry)
end

"""
    avio_alloc_context(buffer, buffer_size::Integer, write_flag::Integer, opaque, read_packet, write_packet, seek)

Allocate and initialize an [`AVIOContext`](@ref) for buffered I/O. It must be later freed with [`avio_context_free`](@ref)().

### Parameters
* `buffer`: Memory block for input/output operations via [`AVIOContext`](@ref). The buffer must be allocated with [`av_malloc`](@ref)() and friends. It may be freed and replaced with a new buffer by libavformat. [`AVIOContext`](@ref).buffer holds the buffer currently in use, which must be later freed with [`av_free`](@ref)(). 

* `buffer_size`: The buffer size is very important for performance. For protocols with fixed blocksize it should be set to this blocksize. For others a typical size is a cache page, e.g. 4kb. 

* `write_flag`: Set to 1 if the buffer should be writable, 0 otherwise. 

* `opaque`: An opaque pointer to user-specific data. 

* `read_packet`: A function for refilling the buffer, may be NULL. For stream protocols, must never return 0 but rather a proper [`AVERROR`](@ref) code. 

* `write_packet`: A function for writing the buffer contents, may be NULL. The function may not change the input buffers content. 

* `seek`: A function for seeking to specified byte position, may be NULL.

### Returns
Allocated [`AVIOContext`](@ref) or NULL on failure.
"""
function avio_alloc_context(buffer, buffer_size::Integer, write_flag::Integer, opaque, read_packet, write_packet, seek)
    ccall((:avio_alloc_context, libavformat), Ptr{AVIOContext}, (Ptr{Cuchar}, Cint, Cint, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek)
end

"""
    avio_context_free(s)

Free the supplied IO context and everything associated with it.

### Parameters
* `s`: Double pointer to the IO context. This function will write NULL into s.
"""
function avio_context_free(s)
    ccall((:avio_context_free, libavformat), Cvoid, (Ptr{Ptr{AVIOContext}},), s)
end

function avio_w8(s, b::Integer)
    ccall((:avio_w8, libavformat), Cvoid, (Ptr{AVIOContext}, Cint), s, b)
end

function avio_write(s, buf, size::Integer)
    ccall((:avio_write, libavformat), Cvoid, (Ptr{AVIOContext}, Ptr{Cuchar}, Cint), s, buf, size)
end

function avio_wl64(s, val::UInt64)
    ccall((:avio_wl64, libavformat), Cvoid, (Ptr{AVIOContext}, UInt64), s, val)
end

function avio_wb64(s, val::UInt64)
    ccall((:avio_wb64, libavformat), Cvoid, (Ptr{AVIOContext}, UInt64), s, val)
end

function avio_wl32(s, val::Integer)
    ccall((:avio_wl32, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

function avio_wb32(s, val::Integer)
    ccall((:avio_wb32, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

function avio_wl24(s, val::Integer)
    ccall((:avio_wl24, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

function avio_wb24(s, val::Integer)
    ccall((:avio_wb24, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

function avio_wl16(s, val::Integer)
    ccall((:avio_wl16, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

function avio_wb16(s, val::Integer)
    ccall((:avio_wb16, libavformat), Cvoid, (Ptr{AVIOContext}, Cuint), s, val)
end

"""
    avio_put_str(s, str)

Write a NULL-terminated string. 

### Returns
number of bytes written.
"""
function avio_put_str(s, str)
    ccall((:avio_put_str, libavformat), Cint, (Ptr{AVIOContext}, Cstring), s, str)
end

"""
    avio_put_str16le(s, str)

Convert an UTF-8 string to UTF-16LE and write it. 

### Parameters
* `s`: the [`AVIOContext`](@ref) 

* `str`: NULL-terminated UTF-8 string

### Returns
number of bytes written.
"""
function avio_put_str16le(s, str)
    ccall((:avio_put_str16le, libavformat), Cint, (Ptr{AVIOContext}, Cstring), s, str)
end

"""
    avio_put_str16be(s, str)

Convert an UTF-8 string to UTF-16BE and write it. 

### Parameters
* `s`: the [`AVIOContext`](@ref) 

* `str`: NULL-terminated UTF-8 string

### Returns
number of bytes written.
"""
function avio_put_str16be(s, str)
    ccall((:avio_put_str16be, libavformat), Cint, (Ptr{AVIOContext}, Cstring), s, str)
end

"""
    avio_write_marker(s, time::Int64, type::AVIODataMarkerType)

Mark the written bytestream as a specific type.

Zero-length ranges are omitted from the output.

### Parameters
* `time`: the stream time the current bytestream pos corresponds to (in [`AV_TIME_BASE`](@ref) units), or [`AV_NOPTS_VALUE`](@ref) if unknown or not applicable 

* `type`: the kind of data written starting at the current pos
"""
function avio_write_marker(s, time::Int64, type::AVIODataMarkerType)
    ccall((:avio_write_marker, libavformat), Cvoid, (Ptr{AVIOContext}, Int64, AVIODataMarkerType), s, time, type)
end

"""
    avio_seek(s, offset::Int64, whence::Integer)

fseek() equivalent for [`AVIOContext`](@ref). 

### Returns
new position or [`AVERROR`](@ref).
"""
function avio_seek(s, offset::Int64, whence::Integer)
    ccall((:avio_seek, libavformat), Int64, (Ptr{AVIOContext}, Int64, Cint), s, offset, whence)
end

"""
    avio_skip(s, offset::Int64)

Skip given number of bytes forward 

### Returns
new position or [`AVERROR`](@ref).
"""
function avio_skip(s, offset::Int64)
    ccall((:avio_skip, libavformat), Int64, (Ptr{AVIOContext}, Int64), s, offset)
end

"""
    avio_tell(s)

ftell() equivalent for [`AVIOContext`](@ref). 

### Returns
position or [`AVERROR`](@ref).
"""
function avio_tell(s)
    ccall((:avio_tell, libavformat), Int64, (Ptr{AVIOContext},), s)
end

"""
    avio_size(s)

Get the filesize. 

### Returns
filesize or [`AVERROR`](@ref)
"""
function avio_size(s)
    ccall((:avio_size, libavformat), Int64, (Ptr{AVIOContext},), s)
end

"""
    avio_feof(s)

Similar to feof() but also returns nonzero on read errors. 

### Returns
non zero if and only if at end of file or a read error happened when reading.
"""
function avio_feof(s)
    ccall((:avio_feof, libavformat), Cint, (Ptr{AVIOContext},), s)
end

"""
    avio_flush(s)

Force flushing of buffered data.

For write streams, force the buffered data to be immediately written to the output, without to wait to fill the internal buffer.

For read streams, discard all currently buffered data, and advance the reported file position to that of the underlying stream. This does not read new data, and does not perform any seeks.
"""
function avio_flush(s)
    ccall((:avio_flush, libavformat), Cvoid, (Ptr{AVIOContext},), s)
end

"""
    avio_read(s, buf, size::Integer)

Read size bytes from [`AVIOContext`](@ref) into buf. 

### Returns
number of bytes read or [`AVERROR`](@ref)
"""
function avio_read(s, buf, size::Integer)
    ccall((:avio_read, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Cuchar}, Cint), s, buf, size)
end

"""
    avio_read_partial(s, buf, size::Integer)

Read size bytes from [`AVIOContext`](@ref) into buf. Unlike [`avio_read`](@ref)(), this is allowed to read fewer bytes than requested. The missing bytes can be read in the next call. This always tries to read at least 1 byte. Useful to reduce latency in certain cases. 

### Returns
number of bytes read or [`AVERROR`](@ref)
"""
function avio_read_partial(s, buf, size::Integer)
    ccall((:avio_read_partial, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Cuchar}, Cint), s, buf, size)
end

"""
    avio_r8(s)

` Functions for reading from AVIOContext`

@{

!!! note

    return 0 if EOF, so you cannot use it if EOF handling is necessary
"""
function avio_r8(s)
    ccall((:avio_r8, libavformat), Cint, (Ptr{AVIOContext},), s)
end

function avio_rl16(s)
    ccall((:avio_rl16, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rl24(s)
    ccall((:avio_rl24, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rl32(s)
    ccall((:avio_rl32, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rl64(s)
    ccall((:avio_rl64, libavformat), UInt64, (Ptr{AVIOContext},), s)
end

function avio_rb16(s)
    ccall((:avio_rb16, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rb24(s)
    ccall((:avio_rb24, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rb32(s)
    ccall((:avio_rb32, libavformat), Cuint, (Ptr{AVIOContext},), s)
end

function avio_rb64(s)
    ccall((:avio_rb64, libavformat), UInt64, (Ptr{AVIOContext},), s)
end

"""
    avio_get_str(pb, maxlen::Integer, buf, buflen::Integer)

Read a string from pb into buf. The reading will terminate when either a NULL character was encountered, maxlen bytes have been read, or nothing more can be read from pb. The result is guaranteed to be NULL-terminated, it will be truncated if buf is too small. Note that the string is not interpreted or validated in any way, it might get truncated in the middle of a sequence for multi-byte encodings.

### Returns
number of bytes read (is always <= maxlen). If reading ends on EOF or error, the return value will be one more than bytes actually read.
"""
function avio_get_str(pb, maxlen::Integer, buf, buflen::Integer)
    ccall((:avio_get_str, libavformat), Cint, (Ptr{AVIOContext}, Cint, Cstring, Cint), pb, maxlen, buf, buflen)
end

"""
    avio_get_str16le(pb, maxlen::Integer, buf, buflen::Integer)

Read a UTF-16 string from pb and convert it to UTF-8. The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read. 

### Returns
number of bytes read (is always <= maxlen)
"""
function avio_get_str16le(pb, maxlen::Integer, buf, buflen::Integer)
    ccall((:avio_get_str16le, libavformat), Cint, (Ptr{AVIOContext}, Cint, Cstring, Cint), pb, maxlen, buf, buflen)
end

function avio_get_str16be(pb, maxlen::Integer, buf, buflen::Integer)
    ccall((:avio_get_str16be, libavformat), Cint, (Ptr{AVIOContext}, Cint, Cstring, Cint), pb, maxlen, buf, buflen)
end

"""
    avio_open(s, url, flags::Integer)

Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url. 

!!! note

    When the resource indicated by url has been opened in read+write mode, the [`AVIOContext`](@ref) can be used only for writing.

### Parameters
* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL. 

* `url`: resource to access 

* `flags`: flags which control how the resource indicated by url is to be opened 

### Returns
>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code in case of failure
"""
function avio_open(s, url, flags::Integer)
    ccall((:avio_open, libavformat), Cint, (Ptr{Ptr{AVIOContext}}, Cstring, Cint), s, url, flags)
end

"""
    avio_open2(s, url, flags::Integer, int_cb, options)

Create and initialize a [`AVIOContext`](@ref) for accessing the resource indicated by url. 

!!! note

    When the resource indicated by url has been opened in read+write mode, the [`AVIOContext`](@ref) can be used only for writing.

### Parameters
* `s`: Used to return the pointer to the created [`AVIOContext`](@ref). In case of failure the pointed to value is set to NULL. 

* `url`: resource to access 

* `flags`: flags which control how the resource indicated by url is to be opened 

* `int_cb`: an interrupt callback to be used at the protocols level 

* `options`: A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL. 

### Returns
>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code in case of failure
"""
function avio_open2(s, url, flags::Integer, int_cb, options)
    ccall((:avio_open2, libavformat), Cint, (Ptr{Ptr{AVIOContext}}, Cstring, Cint, Ptr{AVIOInterruptCB}, Ptr{Ptr{AVDictionary}}), s, url, flags, int_cb, options)
end

"""
    avio_close(s)

Close the resource accessed by the [`AVIOContext`](@ref) s and free it. This function can only be used if s was opened by [`avio_open`](@ref)().

The internal buffer is automatically flushed before closing the resource.

### Returns
0 on success, an [`AVERROR`](@ref) < 0 on error. 

### See also
[`avio_closep`](@ref)
"""
function avio_close(s)
    ccall((:avio_close, libavformat), Cint, (Ptr{AVIOContext},), s)
end

"""
    avio_closep(s)

Close the resource accessed by the [`AVIOContext`](@ref) *s, free it and set the pointer pointing to it to NULL. This function can only be used if s was opened by [`avio_open`](@ref)().

The internal buffer is automatically flushed before closing the resource.

### Returns
0 on success, an [`AVERROR`](@ref) < 0 on error. 

### See also
[`avio_close`](@ref)
"""
function avio_closep(s)
    ccall((:avio_closep, libavformat), Cint, (Ptr{Ptr{AVIOContext}},), s)
end

"""
    avio_open_dyn_buf(s)

Open a write only memory stream.

### Parameters
* `s`: new IO context 

### Returns
zero if no error.
"""
function avio_open_dyn_buf(s)
    ccall((:avio_open_dyn_buf, libavformat), Cint, (Ptr{Ptr{AVIOContext}},), s)
end

"""
    avio_get_dyn_buf(s, pbuffer)

Return the written size and a pointer to the buffer. The [`AVIOContext`](@ref) stream is left intact. The buffer must NOT be freed. No padding is added to the buffer.

### Parameters
* `s`: IO context 

* `pbuffer`: pointer to a byte buffer 

### Returns
the length of the byte buffer
"""
function avio_get_dyn_buf(s, pbuffer)
    ccall((:avio_get_dyn_buf, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Ptr{UInt8}}), s, pbuffer)
end

"""
    avio_close_dyn_buf(s, pbuffer)

Return the written size and a pointer to the buffer. The buffer must be freed with [`av_free`](@ref)(). Padding of [`AV_INPUT_BUFFER_PADDING_SIZE`](@ref) is added to the buffer.

### Parameters
* `s`: IO context 

* `pbuffer`: pointer to a byte buffer 

### Returns
the length of the byte buffer
"""
function avio_close_dyn_buf(s, pbuffer)
    ccall((:avio_close_dyn_buf, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Ptr{UInt8}}), s, pbuffer)
end

"""
    avio_enum_protocols(opaque, output::Integer)

Iterate through names of available protocols.

### Parameters
* `opaque`: A private pointer representing current protocol. It must be a pointer to NULL on first iteration and will be updated by successive calls to [`avio_enum_protocols`](@ref). 

* `output`: If set to 1, iterate over output protocols, otherwise over input protocols.

### Returns
A static string containing the name of current protocol or NULL
"""
function avio_enum_protocols(opaque, output::Integer)
    ccall((:avio_enum_protocols, libavformat), Cstring, (Ptr{Ptr{Cvoid}}, Cint), opaque, output)
end

"""
    avio_protocol_get_class(name)

Get [`AVClass`](@ref) by names of available protocols.

### Returns
A [`AVClass`](@ref) of input protocol name or NULL
"""
function avio_protocol_get_class(name)
    ccall((:avio_protocol_get_class, libavformat), Ptr{AVClass}, (Cstring,), name)
end

"""
    avio_pause(h, pause::Integer)

Pause and resume playing - only meaningful if using a network streaming protocol (e.g. MMS).

### Parameters
* `h`: IO context from which to call the read\\_pause function pointer 

* `pause`: 1 for pause, 0 for resume
"""
function avio_pause(h, pause::Integer)
    ccall((:avio_pause, libavformat), Cint, (Ptr{AVIOContext}, Cint), h, pause)
end

"""
    avio_seek_time(h, stream_index::Integer, timestamp::Int64, flags::Integer)

Seek to a given timestamp relative to some component stream. Only meaningful if using a network streaming protocol (e.g. MMS.).

### Parameters
* `h`: IO context from which to call the seek function pointers 

* `stream_index`: The stream index that the timestamp is relative to. If stream\\_index is (-1) the timestamp should be in [`AV_TIME_BASE`](@ref) units from the beginning of the presentation. If a stream\\_index >= 0 is used and the protocol does not support seeking based on component streams, the call will fail. 

* `timestamp`: timestamp in [`AVStream`](@ref).time\\_base units or if there is no stream specified then in [`AV_TIME_BASE`](@ref) units. 

* `flags`: Optional combination of [`AVSEEK_FLAG_BACKWARD`](@ref), [`AVSEEK_FLAG_BYTE`](@ref) and [`AVSEEK_FLAG_ANY`](@ref). The protocol may silently ignore [`AVSEEK_FLAG_BACKWARD`](@ref) and [`AVSEEK_FLAG_ANY`](@ref), but [`AVSEEK_FLAG_BYTE`](@ref) will fail if used and not supported. 

### Returns
>= 0 on success 

### See also
[`AVInputFormat`](@ref)::read\\_seek
"""
function avio_seek_time(h, stream_index::Integer, timestamp::Int64, flags::Integer)
    ccall((:avio_seek_time, libavformat), Int64, (Ptr{AVIOContext}, Cint, Int64, Cint), h, stream_index, timestamp, flags)
end

"""
    AVBPrint

Buffer to print data progressively

The string buffer grows as necessary and is always 0-terminated. The content of the string is never accessed, and thus is encoding-agnostic and can even hold binary data.

Small buffers are kept in the structure itself, and thus require no memory allocation at all (unless the contents of the buffer is needed after the structure goes out of scope). This is almost as lightweight as declaring a local "char buf[512]".

The length of the string can go beyond the allocated size: the buffer is then truncated, but the functions still keep account of the actual total length.

In other words, buf->len can be greater than buf->size and records the total length of what would have been to the buffer if there had been enough memory.

Append operations do not need to be tested for failure: if a memory allocation fails, data stop being appended to the buffer, but the length is still updated. This situation can be tested with [`av_bprint_is_complete`](@ref)().

The size\\_max field determines several possible behaviours:

size\\_max = -1 (= UINT\\_MAX) or any large value will let the buffer be reallocated as necessary, with an amortized linear cost.

size\\_max = 0 prevents writing anything to the buffer: only the total length is computed. The write operations can then possibly be repeated in a buffer with exactly the necessary size (using size\\_init = size\\_max = len + 1).

size\\_max = 1 is automatically replaced by the exact size available in the structure itself, thus ensuring no dynamic memory allocation. The internal buffer is large enough to hold a reasonable paragraph of text, such as the current paragraph.
"""
struct AVBPrint
    str::Cstring
    len::Cuint
    size::Cuint
    size_max::Cuint
    reserved_internal_buffer::NTuple{1, Cchar}
    reserved_padding::NTuple{1000, Cchar}
end

"""
    avio_read_to_bprint(h, pb, max_size::Csize_t)

Read contents of h into print buffer, up to max\\_size bytes, or up to EOF.

### Returns
0 for success (max\\_size bytes read or EOF reached), negative error code otherwise
"""
function avio_read_to_bprint(h, pb, max_size::Csize_t)
    ccall((:avio_read_to_bprint, libavformat), Cint, (Ptr{AVIOContext}, Ptr{AVBPrint}, Csize_t), h, pb, max_size)
end

"""
    avio_accept(s, c)

Accept and allocate a client context on a server context. 

### Parameters
* `s`: the server context 

* `c`: the client context, must be unallocated 

### Returns
>= 0 on success or a negative value corresponding to an [`AVERROR`](@ref) on failure
"""
function avio_accept(s, c)
    ccall((:avio_accept, libavformat), Cint, (Ptr{AVIOContext}, Ptr{Ptr{AVIOContext}}), s, c)
end

"""
    avio_handshake(c)

Perform one step of the protocol handshake to accept a new client. This function must be called on a client returned by [`avio_accept`](@ref)() before using it as a read/write context. It is separate from [`avio_accept`](@ref)() because it may block. A step of the handshake is defined by places where the application may decide to change the proceedings. For example, on a protocol with a request header and a reply header, each one can constitute a step because the application may use the parameters from the request to change parameters in the reply; or each individual chunk of the request can constitute a step. If the handshake is already finished, [`avio_handshake`](@ref)() does nothing and returns 0 immediately.

### Parameters
* `c`: the client context to perform the handshake on 

### Returns
0 on a complete and successful handshake > 0 if the handshake progressed, but is not complete < 0 for an [`AVERROR`](@ref) code
"""
function avio_handshake(c)
    ccall((:avio_handshake, libavformat), Cint, (Ptr{AVIOContext},), c)
end

const AVAdler = Culong

"""
    av_adler32_update(adler::AVAdler, buf, len::Integer)

Calculate the Adler32 checksum of a buffer.

Passing the return value to a subsequent [`av_adler32_update`](@ref)() call allows the checksum of multiple buffers to be calculated as though they were concatenated.

### Parameters
* `adler`: initial checksum value 

* `buf`: pointer to input buffer 

* `len`: size of input buffer 

### Returns
updated checksum
"""
function av_adler32_update(adler::AVAdler, buf, len::Integer)
    ccall((:av_adler32_update, libavutil), AVAdler, (AVAdler, Ptr{UInt8}, Cuint), adler, buf, len)
end

mutable struct AVAES end

"""
    av_aes_alloc()

Allocate an [`AVAES`](@ref) context.
"""
function av_aes_alloc()
    ccall((:av_aes_alloc, libavutil), Ptr{AVAES}, ())
end

"""
    av_aes_init(a, key, key_bits::Integer, decrypt::Integer)

Initialize an [`AVAES`](@ref) context. 

### Parameters
* `key_bits`: 128, 192 or 256 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_aes_init(a, key, key_bits::Integer, decrypt::Integer)
    ccall((:av_aes_init, libavutil), Cint, (Ptr{AVAES}, Ptr{UInt8}, Cint, Cint), a, key, key_bits, decrypt)
end

"""
    av_aes_crypt(a, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context. 

### Parameters
* `count`: number of 16 byte blocks 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_aes_crypt(a, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_aes_crypt, libavutil), Cvoid, (Ptr{AVAES}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), a, dst, src, count, iv, decrypt)
end

mutable struct AVAESCTR end

"""
    av_aes_ctr_alloc()

Allocate an [`AVAESCTR`](@ref) context.
"""
function av_aes_ctr_alloc()
    ccall((:av_aes_ctr_alloc, libavutil), Ptr{AVAESCTR}, ())
end

"""
    av_aes_ctr_init(a, key)

Initialize an [`AVAESCTR`](@ref) context. 

### Parameters
* `key`: encryption key, must have a length of [`AES_CTR_KEY_SIZE`](@ref)
"""
function av_aes_ctr_init(a, key)
    ccall((:av_aes_ctr_init, libavutil), Cint, (Ptr{AVAESCTR}, Ptr{UInt8}), a, key)
end

"""
    av_aes_ctr_free(a)

Release an [`AVAESCTR`](@ref) context.
"""
function av_aes_ctr_free(a)
    ccall((:av_aes_ctr_free, libavutil), Cvoid, (Ptr{AVAESCTR},), a)
end

"""
    av_aes_ctr_crypt(a, dst, src, size::Integer)

Process a buffer using a previously initialized context. 

### Parameters
* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `size`: the size of src and dst
"""
function av_aes_ctr_crypt(a, dst, src, size::Integer)
    ccall((:av_aes_ctr_crypt, libavutil), Cvoid, (Ptr{AVAESCTR}, Ptr{UInt8}, Ptr{UInt8}, Cint), a, dst, src, size)
end

"""
    av_aes_ctr_get_iv(a)

Get the current iv
"""
function av_aes_ctr_get_iv(a)
    ccall((:av_aes_ctr_get_iv, libavutil), Ptr{UInt8}, (Ptr{AVAESCTR},), a)
end

"""
    av_aes_ctr_set_random_iv(a)

Generate a random iv
"""
function av_aes_ctr_set_random_iv(a)
    ccall((:av_aes_ctr_set_random_iv, libavutil), Cvoid, (Ptr{AVAESCTR},), a)
end

"""
    av_aes_ctr_set_iv(a, iv)

Forcefully change the 8-byte iv
"""
function av_aes_ctr_set_iv(a, iv)
    ccall((:av_aes_ctr_set_iv, libavutil), Cvoid, (Ptr{AVAESCTR}, Ptr{UInt8}), a, iv)
end

"""
    av_aes_ctr_set_full_iv(a, iv)

Forcefully change the "full" 16-byte iv, including the counter
"""
function av_aes_ctr_set_full_iv(a, iv)
    ccall((:av_aes_ctr_set_full_iv, libavutil), Cvoid, (Ptr{AVAESCTR}, Ptr{UInt8}), a, iv)
end

"""
    av_aes_ctr_increment_iv(a)

Increment the top 64 bit of the iv (performed after each frame)
"""
function av_aes_ctr_increment_iv(a)
    ccall((:av_aes_ctr_increment_iv, libavutil), Cvoid, (Ptr{AVAESCTR},), a)
end

mutable struct AVAudioFifo end

"""
    av_audio_fifo_free(af)

Free an [`AVAudioFifo`](@ref).

### Parameters
* `af`: [`AVAudioFifo`](@ref) to free
"""
function av_audio_fifo_free(af)
    ccall((:av_audio_fifo_free, libavutil), Cvoid, (Ptr{AVAudioFifo},), af)
end

"""
    av_audio_fifo_alloc(sample_fmt::AVSampleFormat, channels::Integer, nb_samples::Integer)

Allocate an [`AVAudioFifo`](@ref).

### Parameters
* `sample_fmt`: sample format 

* `channels`: number of channels 

* `nb_samples`: initial allocation size, in samples 

### Returns
newly allocated [`AVAudioFifo`](@ref), or NULL on error
"""
function av_audio_fifo_alloc(sample_fmt::AVSampleFormat, channels::Integer, nb_samples::Integer)
    ccall((:av_audio_fifo_alloc, libavutil), Ptr{AVAudioFifo}, (AVSampleFormat, Cint, Cint), sample_fmt, channels, nb_samples)
end

"""
    av_audio_fifo_realloc(af, nb_samples::Integer)

Reallocate an [`AVAudioFifo`](@ref).

### Parameters
* `af`: [`AVAudioFifo`](@ref) to reallocate 

* `nb_samples`: new allocation size, in samples 

### Returns
0 if OK, or negative [`AVERROR`](@ref) code on failure
"""
function av_audio_fifo_realloc(af, nb_samples::Integer)
    ccall((:av_audio_fifo_realloc, libavutil), Cint, (Ptr{AVAudioFifo}, Cint), af, nb_samples)
end

"""
    av_audio_fifo_write(af, data, nb_samples::Integer)

Write data to an [`AVAudioFifo`](@ref).

The [`AVAudioFifo`](@ref) will be reallocated automatically if the available space is less than nb\\_samples.

### Parameters
* `af`: [`AVAudioFifo`](@ref) to write to 

* `data`: audio data plane pointers 

* `nb_samples`: number of samples to write 

### Returns
number of samples actually written, or negative [`AVERROR`](@ref) code on failure. If successful, the number of samples actually written will always be nb\\_samples.

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
"""
function av_audio_fifo_write(af, data, nb_samples::Integer)
    ccall((:av_audio_fifo_write, libavutil), Cint, (Ptr{AVAudioFifo}, Ptr{Ptr{Cvoid}}, Cint), af, data, nb_samples)
end

"""
    av_audio_fifo_peek(af, data, nb_samples::Integer)

Peek data from an [`AVAudioFifo`](@ref).

### Parameters
* `af`: [`AVAudioFifo`](@ref) to read from 

* `data`: audio data plane pointers 

* `nb_samples`: number of samples to peek 

### Returns
number of samples actually peek, or negative [`AVERROR`](@ref) code on failure. The number of samples actually peek will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
"""
function av_audio_fifo_peek(af, data, nb_samples::Integer)
    ccall((:av_audio_fifo_peek, libavutil), Cint, (Ptr{AVAudioFifo}, Ptr{Ptr{Cvoid}}, Cint), af, data, nb_samples)
end

"""
    av_audio_fifo_peek_at(af, data, nb_samples::Integer, offset::Integer)

Peek data from an [`AVAudioFifo`](@ref).

### Parameters
* `af`: [`AVAudioFifo`](@ref) to read from 

* `data`: audio data plane pointers 

* `nb_samples`: number of samples to peek 

* `offset`: offset from current read position 

### Returns
number of samples actually peek, or negative [`AVERROR`](@ref) code on failure. The number of samples actually peek will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
"""
function av_audio_fifo_peek_at(af, data, nb_samples::Integer, offset::Integer)
    ccall((:av_audio_fifo_peek_at, libavutil), Cint, (Ptr{AVAudioFifo}, Ptr{Ptr{Cvoid}}, Cint, Cint), af, data, nb_samples, offset)
end

"""
    av_audio_fifo_read(af, data, nb_samples::Integer)

Read data from an [`AVAudioFifo`](@ref).

### Parameters
* `af`: [`AVAudioFifo`](@ref) to read from 

* `data`: audio data plane pointers 

* `nb_samples`: number of samples to read 

### Returns
number of samples actually read, or negative [`AVERROR`](@ref) code on failure. The number of samples actually read will not be greater than nb\\_samples, and will only be less than nb\\_samples if [`av_audio_fifo_size`](@ref) is less than nb\\_samples.

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
"""
function av_audio_fifo_read(af, data, nb_samples::Integer)
    ccall((:av_audio_fifo_read, libavutil), Cint, (Ptr{AVAudioFifo}, Ptr{Ptr{Cvoid}}, Cint), af, data, nb_samples)
end

"""
    av_audio_fifo_drain(af, nb_samples::Integer)

Drain data from an [`AVAudioFifo`](@ref).

Removes the data without reading it.

### Parameters
* `af`: [`AVAudioFifo`](@ref) to drain 

* `nb_samples`: number of samples to drain 

### Returns
0 if OK, or negative [`AVERROR`](@ref) code on failure
"""
function av_audio_fifo_drain(af, nb_samples::Integer)
    ccall((:av_audio_fifo_drain, libavutil), Cint, (Ptr{AVAudioFifo}, Cint), af, nb_samples)
end

"""
    av_audio_fifo_reset(af)

Reset the [`AVAudioFifo`](@ref) buffer.

This empties all data in the buffer.

### Parameters
* `af`: [`AVAudioFifo`](@ref) to reset
"""
function av_audio_fifo_reset(af)
    ccall((:av_audio_fifo_reset, libavutil), Cvoid, (Ptr{AVAudioFifo},), af)
end

"""
    av_audio_fifo_size(af)

Get the current number of samples in the [`AVAudioFifo`](@ref) available for reading.

### Parameters
* `af`: the [`AVAudioFifo`](@ref) to query 

### Returns
number of samples available for reading
"""
function av_audio_fifo_size(af)
    ccall((:av_audio_fifo_size, libavutil), Cint, (Ptr{AVAudioFifo},), af)
end

"""
    av_audio_fifo_space(af)

Get the current number of samples in the [`AVAudioFifo`](@ref) available for writing.

### Parameters
* `af`: the [`AVAudioFifo`](@ref) to query 

### Returns
number of samples available for writing
"""
function av_audio_fifo_space(af)
    ccall((:av_audio_fifo_space, libavutil), Cint, (Ptr{AVAudioFifo},), af)
end

"""
    av_assert0_fpu()

Assert that floating point operations can be executed.

This will [`av_assert0`](@ref)() that the cpu is not in MMX state on X86
"""
function av_assert0_fpu()
    ccall((:av_assert0_fpu, libavutil), Cvoid, ())
end

"""
    av_strstart(str, pfx, ptr)

Return non-zero if pfx is a prefix of str. If it is, *ptr is set to the address of the first character in str after the prefix.

### Parameters
* `str`: input string 

* `pfx`: prefix to test 

* `ptr`: updated if the prefix is matched inside str 

### Returns
non-zero if the prefix matches, zero otherwise
"""
function av_strstart(str, pfx, ptr)
    ccall((:av_strstart, libavutil), Cint, (Cstring, Cstring, Ptr{Cstring}), str, pfx, ptr)
end

"""
    av_stristart(str, pfx, ptr)

Return non-zero if pfx is a prefix of str independent of case. If it is, *ptr is set to the address of the first character in str after the prefix.

### Parameters
* `str`: input string 

* `pfx`: prefix to test 

* `ptr`: updated if the prefix is matched inside str 

### Returns
non-zero if the prefix matches, zero otherwise
"""
function av_stristart(str, pfx, ptr)
    ccall((:av_stristart, libavutil), Cint, (Cstring, Cstring, Ptr{Cstring}), str, pfx, ptr)
end

"""
    av_stristr(haystack, needle)

Locate the first case-independent occurrence in the string haystack of the string needle. A zero-length string needle is considered to match at the start of haystack.

This function is a case-insensitive version of the standard strstr().

### Parameters
* `haystack`: string to search in 

* `needle`: string to search for 

### Returns
pointer to the located match within haystack or a null pointer if no match
"""
function av_stristr(haystack, needle)
    ccall((:av_stristr, libavutil), Cstring, (Cstring, Cstring), haystack, needle)
end

"""
    av_strnstr(haystack, needle, hay_length::Csize_t)

Locate the first occurrence of the string needle in the string haystack where not more than hay\\_length characters are searched. A zero-length string needle is considered to match at the start of haystack.

This function is a length-limited version of the standard strstr().

### Parameters
* `haystack`: string to search in 

* `needle`: string to search for 

* `hay_length`: length of string to search in 

### Returns
pointer to the located match within haystack or a null pointer if no match
"""
function av_strnstr(haystack, needle, hay_length::Csize_t)
    ccall((:av_strnstr, libavutil), Cstring, (Cstring, Cstring, Csize_t), haystack, needle, hay_length)
end

"""
    av_strlcpy(dst, src, size::Csize_t)

Copy the string src to dst, but no more than size - 1 bytes, and null-terminate dst.

This function is the same as BSD strlcpy().

!!! warning

    since the return value is the length of src, src absolutely \\_must\\_ be a properly 0-terminated string, otherwise this will read beyond the end of the buffer and possibly crash.

### Parameters
* `dst`: destination buffer 

* `src`: source string 

* `size`: size of destination buffer 

### Returns
the length of src
"""
function av_strlcpy(dst, src, size::Csize_t)
    ccall((:av_strlcpy, libavutil), Csize_t, (Cstring, Cstring, Csize_t), dst, src, size)
end

"""
    av_strlcat(dst, src, size::Csize_t)

Append the string src to the string dst, but to a total length of no more than size - 1 bytes, and null-terminate dst.

This function is similar to BSD strlcat(), but differs when size <= strlen(dst).

!!! warning

    since the return value use the length of src and dst, these absolutely \\_must\\_ be a properly 0-terminated strings, otherwise this will read beyond the end of the buffer and possibly crash.

### Parameters
* `dst`: destination buffer 

* `src`: source string 

* `size`: size of destination buffer 

### Returns
the total length of src and dst
"""
function av_strlcat(dst, src, size::Csize_t)
    ccall((:av_strlcat, libavutil), Csize_t, (Cstring, Cstring, Csize_t), dst, src, size)
end

"""
    av_strnlen(s, len::Csize_t)

Get the count of continuous non zero chars starting from the beginning.

### Parameters
* `len`: maximum number of characters to check in the string, that is the maximum value which is returned by the function
"""
function av_strnlen(s, len::Csize_t)
    ccall((:av_strnlen, libavutil), Csize_t, (Cstring, Csize_t), s, len)
end

"""
    av_d2str(d::Cdouble)

Convert a number to an av\\_malloced string. 

\\deprecated use [`av_asprintf`](@ref)() with "f" or a more specific format
"""
function av_d2str(d::Cdouble)
    ccall((:av_d2str, libavutil), Cstring, (Cdouble,), d)
end

"""
    av_get_token(buf, term)

Unescape the given string until a non escaped terminating char, and return the token corresponding to the unescaped string.

The normal \\ and ' escaping is supported. Leading and trailing whitespaces are removed, unless they are escaped with '\\' or are enclosed between ''.

### Parameters
* `buf`: the buffer to parse, buf will be updated to point to the terminating char 

* `term`: a 0-terminated list of terminating chars 

### Returns
the malloced unescaped string, which must be av\\_freed by the user, NULL in case of allocation failure
"""
function av_get_token(buf, term)
    ccall((:av_get_token, libavutil), Cstring, (Ptr{Cstring}, Cstring), buf, term)
end

"""
    av_strtok(s, delim, saveptr)

Split the string into several tokens which can be accessed by successive calls to [`av_strtok`](@ref)().

A token is defined as a sequence of characters not belonging to the set specified in delim.

On the first call to [`av_strtok`](@ref)(), s should point to the string to parse, and the value of saveptr is ignored. In subsequent calls, s should be NULL, and saveptr should be unchanged since the previous call.

This function is similar to strtok\\_r() defined in POSIX.1.

### Parameters
* `s`: the string to parse, may be NULL 

* `delim`: 0-terminated list of token delimiters, must be non-NULL 

* `saveptr`: user-provided pointer which points to stored information necessary for [`av_strtok`](@ref)() to continue scanning the same string. saveptr is updated to point to the next character after the first delimiter found, or to NULL if the string was terminated 

### Returns
the found token, or NULL when no token is found
"""
function av_strtok(s, delim, saveptr)
    ccall((:av_strtok, libavutil), Cstring, (Cstring, Cstring, Ptr{Cstring}), s, delim, saveptr)
end

"""
    av_isdigit(c::Integer)

Locale-independent conversion of ASCII isdigit.
"""
function av_isdigit(c::Integer)
    ccall((:av_isdigit, libavutil), Cint, (Cint,), c)
end

"""
    av_isgraph(c::Integer)

Locale-independent conversion of ASCII isgraph.
"""
function av_isgraph(c::Integer)
    ccall((:av_isgraph, libavutil), Cint, (Cint,), c)
end

"""
    av_isspace(c::Integer)

Locale-independent conversion of ASCII isspace.
"""
function av_isspace(c::Integer)
    ccall((:av_isspace, libavutil), Cint, (Cint,), c)
end

"""
    av_toupper(c::Integer)

Locale-independent conversion of ASCII characters to uppercase.
"""
function av_toupper(c::Integer)
    ccall((:av_toupper, libavutil), Cint, (Cint,), c)
end

"""
    av_tolower(c::Integer)

Locale-independent conversion of ASCII characters to lowercase.
"""
function av_tolower(c::Integer)
    ccall((:av_tolower, libavutil), Cint, (Cint,), c)
end

"""
    av_isxdigit(c::Integer)

Locale-independent conversion of ASCII isxdigit.
"""
function av_isxdigit(c::Integer)
    ccall((:av_isxdigit, libavutil), Cint, (Cint,), c)
end

"""
    av_strcasecmp(a, b)

Locale-independent case-insensitive compare. 

!!! note

    This means only ASCII-range characters are case-insensitive
"""
function av_strcasecmp(a, b)
    ccall((:av_strcasecmp, libavutil), Cint, (Cstring, Cstring), a, b)
end

"""
    av_strncasecmp(a, b, n::Csize_t)

Locale-independent case-insensitive compare. 

!!! note

    This means only ASCII-range characters are case-insensitive
"""
function av_strncasecmp(a, b, n::Csize_t)
    ccall((:av_strncasecmp, libavutil), Cint, (Cstring, Cstring, Csize_t), a, b, n)
end

"""
    av_strireplace(str, from, to)

Locale-independent strings replace. 

!!! note

    This means only ASCII-range characters are replace
"""
function av_strireplace(str, from, to)
    ccall((:av_strireplace, libavutil), Cstring, (Cstring, Cstring, Cstring), str, from, to)
end

"""
    av_basename(path)

Thread safe basename. 

### Parameters
* `path`: the string to parse, on DOS both \\ and / are considered separators. 

### Returns
pointer to the basename substring. If path does not contain a slash, the function returns a copy of path. If path is a NULL pointer or points to an empty string, a pointer to a string "." is returned.
"""
function av_basename(path)
    ccall((:av_basename, libavutil), Cstring, (Cstring,), path)
end

"""
    av_dirname(path)

Thread safe dirname. 

!!! note

    the function may modify the contents of the path, so copies should be passed.

### Parameters
* `path`: the string to parse, on DOS both \\ and / are considered separators. 

### Returns
A pointer to a string that's the parent directory of path. If path is a NULL pointer or points to an empty string, a pointer to a string "." is returned. 
"""
function av_dirname(path)
    ccall((:av_dirname, libavutil), Cstring, (Cstring,), path)
end

"""
    av_match_name(name, names)

Match instances of a name in a comma-separated list of names. List entries are checked from the start to the end of the names list, the first match ends further processing. If an entry prefixed with '-' matches, then 0 is returned. The "ALL" list entry is considered to match all names.

### Parameters
* `name`: Name to look for. 

* `names`: List of names. 

### Returns
1 on match, 0 otherwise.
"""
function av_match_name(name, names)
    ccall((:av_match_name, libavutil), Cint, (Cstring, Cstring), name, names)
end

"""
    av_append_path_component(path, component)

Append path component to the existing path. Path separator '/' is placed between when needed. Resulting string have to be freed with [`av_free`](@ref)(). 

### Parameters
* `path`: base path 

* `component`: component to be appended 

### Returns
new path or NULL on error.
"""
function av_append_path_component(path, component)
    ccall((:av_append_path_component, libavutil), Cstring, (Cstring, Cstring), path, component)
end

const AVEscapeMode = UInt32
const AV_ESCAPE_MODE_AUTO = 0 % UInt32
const AV_ESCAPE_MODE_BACKSLASH = 1 % UInt32
const AV_ESCAPE_MODE_QUOTE = 2 % UInt32
const AV_ESCAPE_MODE_XML = 3 % UInt32

"""
    av_escape(dst, src, special_chars, mode::AVEscapeMode, flags::Integer)

Escape string in src, and put the escaped string in an allocated string in *dst, which must be freed with [`av_free`](@ref)().

### Parameters
* `dst`: pointer where an allocated string is put 

* `src`: string to escape, must be non-NULL 

* `special_chars`: string containing the special characters which need to be escaped, can be NULL 

* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice. 

* `flags`: flags which control how to escape, see AV\\_ESCAPE\\_FLAG\\_ macros 

### Returns
the length of the allocated string, or a negative error code in case of error 

### See also
[`av_bprint_escape`](@ref)()
"""
function av_escape(dst, src, special_chars, mode::AVEscapeMode, flags::Integer)
    ccall((:av_escape, libavutil), Cint, (Ptr{Cstring}, Cstring, Cstring, AVEscapeMode, Cint), dst, src, special_chars, mode, flags)
end

"""
    av_utf8_decode(codep, bufp, buf_end, flags::Integer)

Read and decode a single UTF-8 code point (character) from the buffer in *buf, and update *buf to point to the next byte to decode.

In case of an invalid byte sequence, the pointer will be updated to the next byte after the invalid sequence and the function will return an error code.

Depending on the specified flags, the function will also fail in case the decoded code point does not belong to a valid range.

!!! note

    For speed-relevant code a carefully implemented use of [`GET_UTF8`](@ref)() may be preferred.

### Parameters
* `codep`: pointer used to return the parsed code in case of success. The value in *codep is set even in case the range check fails. 

* `bufp`: pointer to the address the first byte of the sequence to decode, updated by the function to point to the byte next after the decoded sequence 

* `buf_end`: pointer to the end of the buffer, points to the next byte past the last in the buffer. This is used to avoid buffer overreads (in case of an unfinished UTF-8 sequence towards the end of the buffer). 

* `flags`: a collection of AV\\_UTF8\\_FLAG\\_* flags 

### Returns
>= 0 in case a sequence was successfully read, a negative value in case of invalid sequence
"""
function av_utf8_decode(codep, bufp, buf_end, flags::Integer)
    ccall((:av_utf8_decode, libavutil), Cint, (Ptr{Int32}, Ptr{Ptr{UInt8}}, Ptr{UInt8}, Cuint), codep, bufp, buf_end, flags)
end

"""
    av_match_list(name, list, separator::Cchar)

Check if a name is in a list. 

### Returns
0 if not found, or the 1 based index where it has been found in the list.
"""
function av_match_list(name, list, separator::Cchar)
    ccall((:av_match_list, libavutil), Cint, (Cstring, Cstring, Cchar), name, list, separator)
end

"""
    av_int_list_length_for_size(elsize::Integer, list, term::UInt64)

Compute the length of an integer list.

### Parameters
* `elsize`: size in bytes of each list element (only 1, 2, 4 or 8) 

* `term`: list terminator (usually 0 or -1) 

* `list`: pointer to the list 

### Returns
length of the list, in elements, not counting the terminator
"""
function av_int_list_length_for_size(elsize::Integer, list, term::UInt64)
    ccall((:av_int_list_length_for_size, libavutil), Cuint, (Cuint, Ptr{Cvoid}, UInt64), elsize, list, term)
end

"""
    av_fourcc_make_string(buf, fourcc::Integer)

Fill the provided buffer with a string containing a FourCC (four-character code) representation.

### Parameters
* `buf`: a buffer with size in bytes of at least [`AV_FOURCC_MAX_STRING_SIZE`](@ref) 

* `fourcc`: the fourcc to represent 

### Returns
the buffer in input
"""
function av_fourcc_make_string(buf, fourcc::Integer)
    ccall((:av_fourcc_make_string, libavutil), Cstring, (Cstring, UInt32), buf, fourcc)
end

"""
    avutil_version()

Return the [`LIBAVUTIL_VERSION_INT`](@ref) constant.
"""
function avutil_version()
    ccall((:avutil_version, libavutil), Cuint, ())
end

"""
    av_version_info()

Return an informative version string. This usually is the actual release version number or a git commit description. This string has no fixed format and can change any time. It should never be parsed by code.
"""
function av_version_info()
    ccall((:av_version_info, libavutil), Cstring, ())
end

"""
    avutil_configuration()

Return the libavutil build-time configuration.
"""
function avutil_configuration()
    ccall((:avutil_configuration, libavutil), Cstring, ())
end

"""
    avutil_license()

Return the libavutil license.
"""
function avutil_license()
    ccall((:avutil_license, libavutil), Cstring, ())
end

"""
    av_get_media_type_string(media_type::AVMediaType)

Return a string describing the media\\_type enum, NULL if media\\_type is unknown.
"""
function av_get_media_type_string(media_type::AVMediaType)
    ccall((:av_get_media_type_string, libavutil), Cstring, (AVMediaType,), media_type)
end

"""
    av_get_picture_type_char(pict_type::AVPictureType)

Return a single letter to describe the given picture type pict\\_type.

### Parameters
* `pict_type`:\\[in\\] the picture type 

### Returns
a single character representing the picture type, '?' if pict\\_type is unknown
"""
function av_get_picture_type_char(pict_type::AVPictureType)
    ccall((:av_get_picture_type_char, libavutil), Cchar, (AVPictureType,), pict_type)
end

"""
    av_x_if_null(p, x)

Return x default pointer in case p is NULL.
"""
function av_x_if_null(p, x)
    ccall((:av_x_if_null, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), p, x)
end

"""
    av_fopen_utf8(path, mode)

Open a file using a UTF-8 filename. The API of this function matches POSIX fopen(), errors are returned through errno.
"""
function av_fopen_utf8(path, mode)
    ccall((:av_fopen_utf8, libavutil), Ptr{Libc.FILE}, (Cstring, Cstring), path, mode)
end

"""
    av_get_time_base_q()

Return the fractional representation of the internal time base.
"""
function av_get_time_base_q()
    ccall((:av_get_time_base_q, libavutil), AVRational, ())
end

"""
    av_base64_decode(out, in, out_size::Integer)

Decode a base64-encoded string.

### Parameters
* `out`: buffer for decoded data 

* `in`: null-terminated input string 

* `out_size`: size in bytes of the out buffer, must be at least 3/4 of the length of in, that is [`AV_BASE64_DECODE_SIZE`](@ref)(strlen(in)) 

### Returns
number of bytes written, or a negative value in case of invalid input
"""
function av_base64_decode(out, in, out_size::Integer)
    ccall((:av_base64_decode, libavutil), Cint, (Ptr{UInt8}, Cstring, Cint), out, in, out_size)
end

"""
    av_base64_encode(out, out_size::Integer, in, in_size::Integer)

Encode data to base64 and null-terminate.

### Parameters
* `out`: buffer for encoded data 

* `out_size`: size in bytes of the out buffer (including the null terminator), must be at least [`AV_BASE64_SIZE`](@ref)(in\\_size) 

* `in`: input buffer containing the data to encode 

* `in_size`: size in bytes of the in buffer 

### Returns
out or NULL in case of error
"""
function av_base64_encode(out, out_size::Integer, in, in_size::Integer)
    ccall((:av_base64_encode, libavutil), Cstring, (Cstring, Cint, Ptr{UInt8}, Cint), out, out_size, in, in_size)
end

struct AVBlowfish
    p::NTuple{18, UInt32}
    s::NTuple{4, NTuple{256, UInt32}}
end

"""
    av_blowfish_alloc()

Allocate an [`AVBlowfish`](@ref) context.
"""
function av_blowfish_alloc()
    ccall((:av_blowfish_alloc, libavutil), Ptr{AVBlowfish}, ())
end

"""
    av_blowfish_init(ctx, key, key_len::Integer)

Initialize an [`AVBlowfish`](@ref) context.

### Parameters
* `ctx`: an [`AVBlowfish`](@ref) context 

* `key`: a key 

* `key_len`: length of the key
"""
function av_blowfish_init(ctx, key, key_len::Integer)
    ccall((:av_blowfish_init, libavutil), Cvoid, (Ptr{AVBlowfish}, Ptr{UInt8}, Cint), ctx, key, key_len)
end

"""
    av_blowfish_crypt_ecb(ctx, xl, xr, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context.

### Parameters
* `ctx`: an [`AVBlowfish`](@ref) context 

* `xl`: left four bytes halves of input to be encrypted 

* `xr`: right four bytes halves of input to be encrypted 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_blowfish_crypt_ecb(ctx, xl, xr, decrypt::Integer)
    ccall((:av_blowfish_crypt_ecb, libavutil), Cvoid, (Ptr{AVBlowfish}, Ptr{UInt32}, Ptr{UInt32}, Cint), ctx, xl, xr, decrypt)
end

"""
    av_blowfish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context.

### Parameters
* `ctx`: an [`AVBlowfish`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `iv`: initialization vector for CBC mode, if NULL ECB will be used 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_blowfish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_blowfish_crypt, libavutil), Cvoid, (Ptr{AVBlowfish}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

struct ff_pad_helper_AVBPrint
    str::Cstring
    len::Cuint
    size::Cuint
    size_max::Cuint
    reserved_internal_buffer::NTuple{1, Cchar}
end

"""
    av_bprint_init(buf, size_init::Integer, size_max::Integer)

Init a print buffer.

### Parameters
* `buf`: buffer to init 

* `size_init`: initial size (including the final 0) 

* `size_max`: maximum size; 0 means do not write anything, just count the length; 1 is replaced by the maximum value for automatic storage; any large value means that the internal buffer will be reallocated as needed up to that limit; -1 is converted to UINT\\_MAX, the largest limit possible. Check also AV\\_BPRINT\\_SIZE\\_* macros.
"""
function av_bprint_init(buf, size_init::Integer, size_max::Integer)
    ccall((:av_bprint_init, libavutil), Cvoid, (Ptr{AVBPrint}, Cuint, Cuint), buf, size_init, size_max)
end

"""
    av_bprint_init_for_buffer(buf, buffer, size::Integer)

Init a print buffer using a pre-existing buffer.

The buffer will not be reallocated.

### Parameters
* `buf`: buffer structure to init 

* `buffer`: byte buffer to use for the string data 

* `size`: size of buffer
"""
function av_bprint_init_for_buffer(buf, buffer, size::Integer)
    ccall((:av_bprint_init_for_buffer, libavutil), Cvoid, (Ptr{AVBPrint}, Cstring, Cuint), buf, buffer, size)
end

"""
    av_bprint_chars(buf, c::Cchar, n::Integer)

Append char c n times to a print buffer.
"""
function av_bprint_chars(buf, c::Cchar, n::Integer)
    ccall((:av_bprint_chars, libavutil), Cvoid, (Ptr{AVBPrint}, Cchar, Cuint), buf, c, n)
end

"""
    av_bprint_append_data(buf, data, size::Integer)

Append data to a print buffer.

param buf bprint buffer to use param data pointer to data param size size of data
"""
function av_bprint_append_data(buf, data, size::Integer)
    ccall((:av_bprint_append_data, libavutil), Cvoid, (Ptr{AVBPrint}, Cstring, Cuint), buf, data, size)
end

mutable struct tm end

"""
    av_bprint_strftime(buf, fmt, tm_)

Append a formatted date and time to a print buffer.

param buf bprint buffer to use param fmt date and time format string, see strftime() param [`tm`](@ref) broken-down time structure to translate

!!! note

    due to poor design of the standard strftime function, it may produce poor results if the format string expands to a very long text and the bprint buffer is near the limit stated by the size\\_max option.
"""
function av_bprint_strftime(buf, fmt, tm_)
    ccall((:av_bprint_strftime, libavutil), Cvoid, (Ptr{AVBPrint}, Cstring, Ptr{tm}), buf, fmt, tm_)
end

"""
    av_bprint_get_buffer(buf, size::Integer, mem, actual_size)

Allocate bytes in the buffer for external use.

### Parameters
* `buf`:\\[in\\] buffer structure 

* `size`:\\[in\\] required size 

* `mem`:\\[out\\] pointer to the memory area 

* `actual_size`:\\[out\\] size of the memory area after allocation; can be larger or smaller than size
"""
function av_bprint_get_buffer(buf, size::Integer, mem, actual_size)
    ccall((:av_bprint_get_buffer, libavutil), Cvoid, (Ptr{AVBPrint}, Cuint, Ptr{Ptr{Cuchar}}, Ptr{Cuint}), buf, size, mem, actual_size)
end

"""
    av_bprint_clear(buf)

Reset the string to "" but keep internal allocated data.
"""
function av_bprint_clear(buf)
    ccall((:av_bprint_clear, libavutil), Cvoid, (Ptr{AVBPrint},), buf)
end

"""
    av_bprint_is_complete(buf)

Test if the print buffer is complete (not truncated).

It may have been truncated due to a memory allocation failure or the size\\_max limit (compare size and size\\_max if necessary).
"""
function av_bprint_is_complete(buf)
    ccall((:av_bprint_is_complete, libavutil), Cint, (Ptr{AVBPrint},), buf)
end

"""
    av_bprint_finalize(buf, ret_str)

Finalize a print buffer.

The print buffer can no longer be used afterwards, but the len and size fields are still valid.

* [out] ret\\_str if not NULL, used to return a permanent copy of the buffer contents, or NULL if memory allocation fails; if NULL, the buffer is discarded and freed 

### Returns
0 for success or error code (probably [`AVERROR`](@ref)(ENOMEM))
"""
function av_bprint_finalize(buf, ret_str)
    ccall((:av_bprint_finalize, libavutil), Cint, (Ptr{AVBPrint}, Ptr{Cstring}), buf, ret_str)
end

"""
    av_bprint_escape(dstbuf, src, special_chars, mode::AVEscapeMode, flags::Integer)

Escape the content in src and append it to dstbuf.

### Parameters
* `dstbuf`: already inited destination bprint buffer 

* `src`: string containing the text to escape 

* `special_chars`: string containing the special characters which need to be escaped, can be NULL 

* `mode`: escape mode to employ, see AV\\_ESCAPE\\_MODE\\_* macros. Any unknown value for mode will be considered equivalent to AV\\_ESCAPE\\_MODE\\_BACKSLASH, but this behaviour can change without notice. 

* `flags`: flags which control how to escape, see AV\\_ESCAPE\\_FLAG\\_* macros
"""
function av_bprint_escape(dstbuf, src, special_chars, mode::AVEscapeMode, flags::Integer)
    ccall((:av_bprint_escape, libavutil), Cvoid, (Ptr{AVBPrint}, Cstring, Cstring, AVEscapeMode, Cint), dstbuf, src, special_chars, mode, flags)
end

function av_bswap16(x::UInt16)
    ccall((:av_bswap16, libavutil), UInt16, (UInt16,), x)
end

function av_bswap32(x::Integer)
    ccall((:av_bswap32, libavutil), UInt32, (UInt32,), x)
end

function av_bswap64(x::UInt64)
    ccall((:av_bswap64, libavutil), UInt64, (UInt64,), x)
end

function av_buffer_alloc(size::Integer)
    ccall((:av_buffer_alloc, libavutil), Ptr{AVBufferRef}, (Cint,), size)
end

function av_buffer_allocz(size::Integer)
    ccall((:av_buffer_allocz, libavutil), Ptr{AVBufferRef}, (Cint,), size)
end

function av_buffer_create(data, size::Integer, free, opaque, flags::Integer)
    ccall((:av_buffer_create, libavutil), Ptr{AVBufferRef}, (Ptr{UInt8}, Cint, Ptr{Cvoid}, Ptr{Cvoid}, Cint), data, size, free, opaque, flags)
end

"""
    av_buffer_default_free(opaque, data)

Default free callback, which calls [`av_free`](@ref)() on the buffer data. This function is meant to be passed to [`av_buffer_create`](@ref)(), not called directly.
"""
function av_buffer_default_free(opaque, data)
    ccall((:av_buffer_default_free, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{UInt8}), opaque, data)
end

"""
    av_buffer_ref(buf)

Create a new reference to an [`AVBuffer`](@ref).

### Returns
a new [`AVBufferRef`](@ref) referring to the same [`AVBuffer`](@ref) as buf or NULL on failure.
"""
function av_buffer_ref(buf)
    ccall((:av_buffer_ref, libavutil), Ptr{AVBufferRef}, (Ptr{AVBufferRef},), buf)
end

"""
    av_buffer_unref(buf)

Free a given reference and automatically free the buffer if there are no more references to it.

### Parameters
* `buf`: the reference to be freed. The pointer is set to NULL on return.
"""
function av_buffer_unref(buf)
    ccall((:av_buffer_unref, libavutil), Cvoid, (Ptr{Ptr{AVBufferRef}},), buf)
end

"""
    av_buffer_is_writable(buf)

### Returns
1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying [`AVBuffer`](@ref)). Return 0 otherwise. A positive answer is valid until [`av_buffer_ref`](@ref)() is called on buf.
"""
function av_buffer_is_writable(buf)
    ccall((:av_buffer_is_writable, libavutil), Cint, (Ptr{AVBufferRef},), buf)
end

"""
    av_buffer_get_opaque(buf)

### Returns
the opaque parameter set by [`av_buffer_create`](@ref).
"""
function av_buffer_get_opaque(buf)
    ccall((:av_buffer_get_opaque, libavutil), Ptr{Cvoid}, (Ptr{AVBufferRef},), buf)
end

function av_buffer_get_ref_count(buf)
    ccall((:av_buffer_get_ref_count, libavutil), Cint, (Ptr{AVBufferRef},), buf)
end

"""
    av_buffer_make_writable(buf)

Create a writable reference from a given buffer reference, avoiding data copy if possible.

### Parameters
* `buf`: buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable [`AVBufferRef`](@ref) is written in its place. On failure, buf is left untouched. 

### Returns
0 on success, a negative [`AVERROR`](@ref) on failure.
"""
function av_buffer_make_writable(buf)
    ccall((:av_buffer_make_writable, libavutil), Cint, (Ptr{Ptr{AVBufferRef}},), buf)
end

function av_buffer_realloc(buf, size::Integer)
    ccall((:av_buffer_realloc, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, Cint), buf, size)
end

"""
    av_buffer_replace(dst, src)

Ensure dst refers to the same data as src.

When *dst is already equivalent to src, do nothing. Otherwise unreference dst and replace it with a new reference to src.

### Parameters
* `dst`: Pointer to either a valid buffer reference or NULL. On success, this will point to a buffer reference equivalent to src. On failure, dst will be left untouched. 

* `src`: A buffer reference to replace dst with. May be NULL, then this function is equivalent to [`av_buffer_unref`](@ref)(dst). 

### Returns
0 on success [`AVERROR`](@ref)(ENOMEM) on memory allocation failure.
"""
function av_buffer_replace(dst, src)
    ccall((:av_buffer_replace, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, Ptr{AVBufferRef}), dst, src)
end

mutable struct AVBufferPool end

function av_buffer_pool_init(size::Integer, alloc)
    ccall((:av_buffer_pool_init, libavutil), Ptr{AVBufferPool}, (Cint, Ptr{Cvoid}), size, alloc)
end

function av_buffer_pool_init2(size::Integer, opaque, alloc, pool_free)
    ccall((:av_buffer_pool_init2, libavutil), Ptr{AVBufferPool}, (Cint, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), size, opaque, alloc, pool_free)
end

"""
    av_buffer_pool_uninit(pool)

Mark the pool as being available for freeing. It will actually be freed only once all the allocated buffers associated with the pool are released. Thus it is safe to call this function while some of the allocated buffers are still in use.

### Parameters
* `pool`: pointer to the pool to be freed. It will be set to NULL.
"""
function av_buffer_pool_uninit(pool)
    ccall((:av_buffer_pool_uninit, libavutil), Cvoid, (Ptr{Ptr{AVBufferPool}},), pool)
end

"""
    av_buffer_pool_get(pool)

Allocate a new [`AVBuffer`](@ref), reusing an old buffer from the pool when available. This function may be called simultaneously from multiple threads.

### Returns
a reference to the new buffer on success, NULL on error.
"""
function av_buffer_pool_get(pool)
    ccall((:av_buffer_pool_get, libavutil), Ptr{AVBufferRef}, (Ptr{AVBufferPool},), pool)
end

"""
    av_buffer_pool_buffer_get_opaque(ref)

Query the original opaque parameter of an allocated buffer in the pool.

!!! note

    the opaque parameter of ref is used by the buffer pool implementation, therefore you have to use this function to access the original opaque parameter of an allocated buffer.

### Parameters
* `ref`: a buffer reference to a buffer returned by [`av_buffer_pool_get`](@ref). 

### Returns
the opaque parameter set by the buffer allocator function of the buffer pool.
"""
function av_buffer_pool_buffer_get_opaque(ref)
    ccall((:av_buffer_pool_buffer_get_opaque, libavutil), Ptr{Cvoid}, (Ptr{AVBufferRef},), ref)
end

mutable struct AVCAMELLIA end

"""
    av_camellia_alloc()

Allocate an [`AVCAMELLIA`](@ref) context To free the struct: [`av_free`](@ref)(ptr)
"""
function av_camellia_alloc()
    ccall((:av_camellia_alloc, libavutil), Ptr{AVCAMELLIA}, ())
end

"""
    av_camellia_init(ctx, key, key_bits::Integer)

Initialize an [`AVCAMELLIA`](@ref) context.

### Parameters
* `ctx`: an [`AVCAMELLIA`](@ref) context 

* `key`: a key of 16, 24, 32 bytes used for encryption/decryption 

* `key_bits`: number of keybits: possible are 128, 192, 256
"""
function av_camellia_init(ctx, key, key_bits::Integer)
    ccall((:av_camellia_init, libavutil), Cint, (Ptr{AVCAMELLIA}, Ptr{UInt8}, Cint), ctx, key, key_bits)
end

"""
    av_camellia_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context

### Parameters
* `ctx`: an [`AVCAMELLIA`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 16 byte blocks 

* `iv`: initialization vector for CBC mode, NULL for ECB mode 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_camellia_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_camellia_crypt, libavutil), Cvoid, (Ptr{AVCAMELLIA}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

mutable struct AVCAST5 end

"""
    av_cast5_alloc()

Allocate an [`AVCAST5`](@ref) context To free the struct: [`av_free`](@ref)(ptr)
"""
function av_cast5_alloc()
    ccall((:av_cast5_alloc, libavutil), Ptr{AVCAST5}, ())
end

"""
    av_cast5_init(ctx, key, key_bits::Integer)

Initialize an [`AVCAST5`](@ref) context.

### Parameters
* `ctx`: an [`AVCAST5`](@ref) context 

* `key`: a key of 5,6,...16 bytes used for encryption/decryption 

* `key_bits`: number of keybits: possible are 40,48,...,128 

### Returns
0 on success, less than 0 on failure
"""
function av_cast5_init(ctx, key, key_bits::Integer)
    ccall((:av_cast5_init, libavutil), Cint, (Ptr{AVCAST5}, Ptr{UInt8}, Cint), ctx, key, key_bits)
end

"""
    av_cast5_crypt(ctx, dst, src, count::Integer, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context, ECB mode only

### Parameters
* `ctx`: an [`AVCAST5`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_cast5_crypt(ctx, dst, src, count::Integer, decrypt::Integer)
    ccall((:av_cast5_crypt, libavutil), Cvoid, (Ptr{AVCAST5}, Ptr{UInt8}, Ptr{UInt8}, Cint, Cint), ctx, dst, src, count, decrypt)
end

"""
    av_cast5_crypt2(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context

### Parameters
* `ctx`: an [`AVCAST5`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `iv`: initialization vector for CBC mode, NULL for ECB mode 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_cast5_crypt2(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_cast5_crypt2, libavutil), Cvoid, (Ptr{AVCAST5}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

const AVMatrixEncoding = UInt32
const AV_MATRIX_ENCODING_NONE = 0 % UInt32
const AV_MATRIX_ENCODING_DOLBY = 1 % UInt32
const AV_MATRIX_ENCODING_DPLII = 2 % UInt32
const AV_MATRIX_ENCODING_DPLIIX = 3 % UInt32
const AV_MATRIX_ENCODING_DPLIIZ = 4 % UInt32
const AV_MATRIX_ENCODING_DOLBYEX = 5 % UInt32
const AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6 % UInt32
const AV_MATRIX_ENCODING_NB = 7 % UInt32

"""
    av_get_channel_layout(name)

Return a channel layout id that matches name, or 0 if no match is found.

name can be one or several of the following notations, separated by '+' or '|': - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0, 5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix); - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC, SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR); - a number of channels, in decimal, followed by 'c', yielding the default channel layout for that number of channels (

Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"

### See also
[`av_get_default_channel_layout`](@ref)); - a channel layout mask, in hexadecimal starting with "0x" (see the AV\\_CH\\_* macros).
"""
function av_get_channel_layout(name)
    ccall((:av_get_channel_layout, libavutil), UInt64, (Cstring,), name)
end

"""
    av_get_extended_channel_layout(name, channel_layout, nb_channels)

Return a channel layout and the number of channels based on the specified name.

This function is similar to (

### Parameters
* `name`:\\[in\\] channel layout specification string 

* `channel_layout`:\\[out\\] parsed channel layout (0 if unknown) 

* `nb_channels`:\\[out\\] number of channels

### Returns
0 on success, [`AVERROR`](@ref)(EINVAL) if the parsing fails.

### See also
[`av_get_channel_layout`](@ref)), but can also parse unknown channel layout specifications.
"""
function av_get_extended_channel_layout(name, channel_layout, nb_channels)
    ccall((:av_get_extended_channel_layout, libavutil), Cint, (Cstring, Ptr{UInt64}, Ptr{Cint}), name, channel_layout, nb_channels)
end

"""
    av_get_channel_layout_string(buf, buf_size::Integer, nb_channels::Integer, channel_layout::UInt64)

Return a description of a channel layout. If nb\\_channels is <= 0, it is guessed from the channel\\_layout.

### Parameters
* `buf`: put here the string containing the channel layout 

* `buf_size`: size in bytes of the buffer
"""
function av_get_channel_layout_string(buf, buf_size::Integer, nb_channels::Integer, channel_layout::UInt64)
    ccall((:av_get_channel_layout_string, libavutil), Cvoid, (Cstring, Cint, Cint, UInt64), buf, buf_size, nb_channels, channel_layout)
end

"""
    av_bprint_channel_layout(bp, nb_channels::Integer, channel_layout::UInt64)

Append a description of a channel layout to a bprint buffer.
"""
function av_bprint_channel_layout(bp, nb_channels::Integer, channel_layout::UInt64)
    ccall((:av_bprint_channel_layout, libavutil), Cvoid, (Ptr{AVBPrint}, Cint, UInt64), bp, nb_channels, channel_layout)
end

"""
    av_get_channel_layout_nb_channels(channel_layout::UInt64)

Return the number of channels in the channel layout.
"""
function av_get_channel_layout_nb_channels(channel_layout::UInt64)
    ccall((:av_get_channel_layout_nb_channels, libavutil), Cint, (UInt64,), channel_layout)
end

"""
    av_get_default_channel_layout(nb_channels::Integer)

Return default channel layout for a given number of channels.
"""
function av_get_default_channel_layout(nb_channels::Integer)
    ccall((:av_get_default_channel_layout, libavutil), Int64, (Cint,), nb_channels)
end

"""
    av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)

Get the index of a channel in channel\\_layout.

### Parameters
* `channel`: a channel layout describing exactly one channel which must be present in channel\\_layout.

### Returns
index of channel in channel\\_layout on success, a negative [`AVERROR`](@ref) on error.
"""
function av_get_channel_layout_channel_index(channel_layout::UInt64, channel::UInt64)
    ccall((:av_get_channel_layout_channel_index, libavutil), Cint, (UInt64, UInt64), channel_layout, channel)
end

"""
    av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)

Get the channel with the given index in channel\\_layout.
"""
function av_channel_layout_extract_channel(channel_layout::UInt64, index::Integer)
    ccall((:av_channel_layout_extract_channel, libavutil), UInt64, (UInt64, Cint), channel_layout, index)
end

"""
    av_get_channel_name(channel::UInt64)

Get the name of a given channel.

### Returns
channel name on success, NULL on error.
"""
function av_get_channel_name(channel::UInt64)
    ccall((:av_get_channel_name, libavutil), Cstring, (UInt64,), channel)
end

"""
    av_get_channel_description(channel::UInt64)

Get the description of a given channel.

### Parameters
* `channel`: a channel layout with a single channel 

### Returns
channel description on success, NULL on error
"""
function av_get_channel_description(channel::UInt64)
    ccall((:av_get_channel_description, libavutil), Cstring, (UInt64,), channel)
end

"""
    av_get_standard_channel_layout(index::Integer, layout, name)

Get the value and name of a standard channel layout.

### Parameters
* `index`:\\[in\\] index in an internal list, starting at 0 

* `layout`:\\[out\\] channel layout mask 

* `name`:\\[out\\] name of the layout 

### Returns
0 if the layout exists, <0 if index is beyond the limits
"""
function av_get_standard_channel_layout(index::Integer, layout, name)
    ccall((:av_get_standard_channel_layout, libavutil), Cint, (Cuint, Ptr{UInt64}, Ptr{Cstring}), index, layout, name)
end

"""
    av_ceil_log2_c(x::Integer)

Compute ceil(log2(x)). 

### Parameters
* `x`: value used to compute ceil(log2(x)) 

### Returns
computed ceiling of log2(x)
"""
function av_ceil_log2_c(x::Integer)
    ccall((:av_ceil_log2_c, libavutil), Cint, (Cint,), x)
end

"""
    av_clip_c(a::Integer, amin::Integer, amax::Integer)

Clip a signed integer value into the amin-amax range. 

### Parameters
* `a`: value to clip 

* `amin`: minimum value of the clip range 

* `amax`: maximum value of the clip range 

### Returns
clipped value
"""
function av_clip_c(a::Integer, amin::Integer, amax::Integer)
    ccall((:av_clip_c, libavutil), Cint, (Cint, Cint, Cint), a, amin, amax)
end

"""
    av_clip64_c(a::Int64, amin::Int64, amax::Int64)

Clip a signed 64bit integer value into the amin-amax range. 

### Parameters
* `a`: value to clip 

* `amin`: minimum value of the clip range 

* `amax`: maximum value of the clip range 

### Returns
clipped value
"""
function av_clip64_c(a::Int64, amin::Int64, amax::Int64)
    ccall((:av_clip64_c, libavutil), Int64, (Int64, Int64, Int64), a, amin, amax)
end

"""
    av_clip_uint8_c(a::Integer)

Clip a signed integer value into the 0-255 range. 

### Parameters
* `a`: value to clip 

### Returns
clipped value
"""
function av_clip_uint8_c(a::Integer)
    ccall((:av_clip_uint8_c, libavutil), UInt8, (Cint,), a)
end

"""
    av_clip_int8_c(a::Integer)

Clip a signed integer value into the -128,127 range. 

### Parameters
* `a`: value to clip 

### Returns
clipped value
"""
function av_clip_int8_c(a::Integer)
    ccall((:av_clip_int8_c, libavutil), Int8, (Cint,), a)
end

"""
    av_clip_uint16_c(a::Integer)

Clip a signed integer value into the 0-65535 range. 

### Parameters
* `a`: value to clip 

### Returns
clipped value
"""
function av_clip_uint16_c(a::Integer)
    ccall((:av_clip_uint16_c, libavutil), UInt16, (Cint,), a)
end

"""
    av_clip_int16_c(a::Integer)

Clip a signed integer value into the -32768,32767 range. 

### Parameters
* `a`: value to clip 

### Returns
clipped value
"""
function av_clip_int16_c(a::Integer)
    ccall((:av_clip_int16_c, libavutil), Int16, (Cint,), a)
end

"""
    av_clipl_int32_c(a::Int64)

Clip a signed 64-bit integer value into the -2147483648,2147483647 range. 

### Parameters
* `a`: value to clip 

### Returns
clipped value
"""
function av_clipl_int32_c(a::Int64)
    ccall((:av_clipl_int32_c, libavutil), Int32, (Int64,), a)
end

"""
    av_clip_intp2_c(a::Integer, p::Integer)

Clip a signed integer into the -(2^p),(2^p-1) range. 

### Parameters
* `a`: value to clip 

* `p`: bit position to clip at 

### Returns
clipped value
"""
function av_clip_intp2_c(a::Integer, p::Integer)
    ccall((:av_clip_intp2_c, libavutil), Cint, (Cint, Cint), a, p)
end

"""
    av_clip_uintp2_c(a::Integer, p::Integer)

Clip a signed integer to an unsigned power of two range. 

### Parameters
* `a`: value to clip 

* `p`: bit position to clip at 

### Returns
clipped value
"""
function av_clip_uintp2_c(a::Integer, p::Integer)
    ccall((:av_clip_uintp2_c, libavutil), Cuint, (Cint, Cint), a, p)
end

"""
    av_mod_uintp2_c(a::Integer, p::Integer)

Clear high bits from an unsigned integer starting with specific bit position 

### Parameters
* `a`: value to clip 

* `p`: bit position to clip at 

### Returns
clipped value
"""
function av_mod_uintp2_c(a::Integer, p::Integer)
    ccall((:av_mod_uintp2_c, libavutil), Cuint, (Cuint, Cuint), a, p)
end

"""
    av_sat_add32_c(a::Integer, b::Integer)

Add two signed 32-bit values with saturation.

### Parameters
* `a`: one value 

* `b`: another value 

### Returns
sum with signed saturation
"""
function av_sat_add32_c(a::Integer, b::Integer)
    ccall((:av_sat_add32_c, libavutil), Cint, (Cint, Cint), a, b)
end

"""
    av_sat_dadd32_c(a::Integer, b::Integer)

Add a doubled value to another value with saturation at both stages.

### Parameters
* `a`: first value 

* `b`: value doubled and added to a 

### Returns
sum sat(a + sat(2*b)) with signed saturation
"""
function av_sat_dadd32_c(a::Integer, b::Integer)
    ccall((:av_sat_dadd32_c, libavutil), Cint, (Cint, Cint), a, b)
end

"""
    av_sat_sub32_c(a::Integer, b::Integer)

Subtract two signed 32-bit values with saturation.

### Parameters
* `a`: one value 

* `b`: another value 

### Returns
difference with signed saturation
"""
function av_sat_sub32_c(a::Integer, b::Integer)
    ccall((:av_sat_sub32_c, libavutil), Cint, (Cint, Cint), a, b)
end

"""
    av_sat_dsub32_c(a::Integer, b::Integer)

Subtract a doubled value from another value with saturation at both stages.

### Parameters
* `a`: first value 

* `b`: value doubled and subtracted from a 

### Returns
difference sat(a - sat(2*b)) with signed saturation
"""
function av_sat_dsub32_c(a::Integer, b::Integer)
    ccall((:av_sat_dsub32_c, libavutil), Cint, (Cint, Cint), a, b)
end

"""
    av_sat_add64_c(a::Int64, b::Int64)

Add two signed 64-bit values with saturation.

### Parameters
* `a`: one value 

* `b`: another value 

### Returns
sum with signed saturation
"""
function av_sat_add64_c(a::Int64, b::Int64)
    ccall((:av_sat_add64_c, libavutil), Int64, (Int64, Int64), a, b)
end

"""
    av_sat_sub64_c(a::Int64, b::Int64)

Subtract two signed 64-bit values with saturation.

### Parameters
* `a`: one value 

* `b`: another value 

### Returns
difference with signed saturation
"""
function av_sat_sub64_c(a::Int64, b::Int64)
    ccall((:av_sat_sub64_c, libavutil), Int64, (Int64, Int64), a, b)
end

"""
    av_clipf_c(a::Cfloat, amin::Cfloat, amax::Cfloat)

Clip a float value into the amin-amax range. 

### Parameters
* `a`: value to clip 

* `amin`: minimum value of the clip range 

* `amax`: maximum value of the clip range 

### Returns
clipped value
"""
function av_clipf_c(a::Cfloat, amin::Cfloat, amax::Cfloat)
    ccall((:av_clipf_c, libavutil), Cfloat, (Cfloat, Cfloat, Cfloat), a, amin, amax)
end

"""
    av_clipd_c(a::Cdouble, amin::Cdouble, amax::Cdouble)

Clip a double value into the amin-amax range. 

### Parameters
* `a`: value to clip 

* `amin`: minimum value of the clip range 

* `amax`: maximum value of the clip range 

### Returns
clipped value
"""
function av_clipd_c(a::Cdouble, amin::Cdouble, amax::Cdouble)
    ccall((:av_clipd_c, libavutil), Cdouble, (Cdouble, Cdouble, Cdouble), a, amin, amax)
end

"""
    av_popcount_c(x::Integer)

Count number of bits set to one in x 

### Parameters
* `x`: value to count bits of 

### Returns
the number of bits set to one in x
"""
function av_popcount_c(x::Integer)
    ccall((:av_popcount_c, libavutil), Cint, (UInt32,), x)
end

"""
    av_popcount64_c(x::UInt64)

Count number of bits set to one in x 

### Parameters
* `x`: value to count bits of 

### Returns
the number of bits set to one in x
"""
function av_popcount64_c(x::UInt64)
    ccall((:av_popcount64_c, libavutil), Cint, (UInt64,), x)
end

function av_parity_c(v::Integer)
    ccall((:av_parity_c, libavutil), Cint, (UInt32,), v)
end

function av_log2(v::Integer)
    ccall((:av_log2, libavutil), Cint, (Cuint,), v)
end

function av_log2_16bit(v::Integer)
    ccall((:av_log2_16bit, libavutil), Cint, (Cuint,), v)
end

"""
    av_get_cpu_flags()

Return the flags which specify extensions supported by the CPU. The returned value is affected by [`av_force_cpu_flags`](@ref)() if that was used before. So [`av_get_cpu_flags`](@ref)() can easily be used in an application to detect the enabled cpu flags.
"""
function av_get_cpu_flags()
    ccall((:av_get_cpu_flags, libavutil), Cint, ())
end

"""
    av_force_cpu_flags(flags::Integer)

Disables cpu detection and forces the specified flags. -1 is a special case that disables forcing of specific flags.
"""
function av_force_cpu_flags(flags::Integer)
    ccall((:av_force_cpu_flags, libavutil), Cvoid, (Cint,), flags)
end

"""
    av_set_cpu_flags_mask(mask::Integer)

Set a mask on flags returned by [`av_get_cpu_flags`](@ref)(). This function is mainly useful for testing. Please use [`av_force_cpu_flags`](@ref)() and [`av_get_cpu_flags`](@ref)() instead which are more flexible
"""
function av_set_cpu_flags_mask(mask::Integer)
    ccall((:av_set_cpu_flags_mask, libavutil), Cvoid, (Cint,), mask)
end

"""
    av_parse_cpu_flags(s)

Parse CPU flags from a string.

The returned flags contain the specified flags as well as related unspecified flags.

This function exists only for compatibility with libav. Please use [`av_parse_cpu_caps`](@ref)() when possible. 

### Returns
a combination of AV\\_CPU\\_* flags, negative on error.
"""
function av_parse_cpu_flags(s)
    ccall((:av_parse_cpu_flags, libavutil), Cint, (Cstring,), s)
end

"""
    av_parse_cpu_caps(flags, s)

Parse CPU caps from a string and update the given AV\\_CPU\\_* flags based on that.

### Returns
negative on error.
"""
function av_parse_cpu_caps(flags, s)
    ccall((:av_parse_cpu_caps, libavutil), Cint, (Ptr{Cuint}, Cstring), flags, s)
end

"""
    av_cpu_count()

### Returns
the number of logical CPU cores present.
"""
function av_cpu_count()
    ccall((:av_cpu_count, libavutil), Cint, ())
end

"""
    av_cpu_max_align()

Get the maximum data alignment that may be required by FFmpeg.

Note that this is affected by the build configuration and the CPU flags mask, so e.g. if the CPU supports AVX, but libavutil has been built with --disable-avx or the [`AV_CPU_FLAG_AVX`](@ref) flag has been disabled through [`av_set_cpu_flags_mask`](@ref)(), then this function will behave as if AVX is not present.
"""
function av_cpu_max_align()
    ccall((:av_cpu_max_align, libavutil), Csize_t, ())
end

"""
` lavu_crc32 CRC`

` lavu_hash`

CRC (Cyclic Redundancy Check) hash function implementation.

This module supports numerous CRC polynomials, in addition to the most widely used CRC-32-IEEE. See AVCRCId for a list of available polynomials.

@{
"""
const AVCRC = UInt32

const AVCRCId = UInt32
const AV_CRC_8_ATM = 0 % UInt32
const AV_CRC_16_ANSI = 1 % UInt32
const AV_CRC_16_CCITT = 2 % UInt32
const AV_CRC_32_IEEE = 3 % UInt32
const AV_CRC_32_IEEE_LE = 4 % UInt32
const AV_CRC_16_ANSI_LE = 5 % UInt32
const AV_CRC_24_IEEE = 6 % UInt32
const AV_CRC_8_EBU = 7 % UInt32
const AV_CRC_MAX = 8 % UInt32

"""
    av_crc_init(ctx, le::Integer, bits::Integer, poly::Integer, ctx_size::Integer)

Initialize a CRC table. 

### Parameters
* `ctx`: must be an array of size sizeof([`AVCRC`](@ref))*257 or sizeof([`AVCRC`](@ref))*1024 

* `le`: If 1, the lowest bit represents the coefficient for the highest exponent of the corresponding polynomial (both for poly and actual CRC). If 0, you must swap the CRC parameter and the result of [`av_crc`](@ref) if you need the standard representation (can be simplified in most cases to e.g. bswap16): [`av_bswap32`](@ref)(crc << (32-bits)) 

* `bits`: number of bits for the CRC 

* `poly`: generator polynomial without the x**bits coefficient, in the representation as specified by le 

* `ctx_size`: size of ctx in bytes 

### Returns
<0 on failure
"""
function av_crc_init(ctx, le::Integer, bits::Integer, poly::Integer, ctx_size::Integer)
    ccall((:av_crc_init, libavutil), Cint, (Ptr{AVCRC}, Cint, Cint, UInt32, Cint), ctx, le, bits, poly, ctx_size)
end

"""
    av_crc_get_table(crc_id::AVCRCId)

Get an initialized standard CRC table. 

### Parameters
* `crc_id`: ID of a standard CRC 

### Returns
a pointer to the CRC table or NULL on failure
"""
function av_crc_get_table(crc_id::AVCRCId)
    ccall((:av_crc_get_table, libavutil), Ptr{AVCRC}, (AVCRCId,), crc_id)
end

"""
    av_crc(ctx, crc::Integer, buffer, length::Csize_t)

Calculate the CRC of a block. 

### Parameters
* `crc`: CRC of previous blocks if any or initial value for CRC 

### Returns
CRC updated with the data from the given block

### See also
[`av_crc_init`](@ref)() "le" parameter
"""
function av_crc(ctx, crc::Integer, buffer, length::Csize_t)
    ccall((:av_crc, libavutil), UInt32, (Ptr{AVCRC}, UInt32, Ptr{UInt8}, Csize_t), ctx, crc, buffer, length)
end

"""
    AVDES

` lavu_des DES`

` lavu_crypto`

@{
"""
struct AVDES
    round_keys::NTuple{3, NTuple{16, UInt64}}
    triple_des::Cint
end

"""
    av_des_alloc()

Allocate an [`AVDES`](@ref) context.
"""
function av_des_alloc()
    ccall((:av_des_alloc, libavutil), Ptr{AVDES}, ())
end

"""
    av_des_init(d, key, key_bits::Integer, decrypt::Integer)

Initializes an [`AVDES`](@ref) context.

### Parameters
* `key_bits`: must be 64 or 192 

* `decrypt`: 0 for encryption/CBC-MAC, 1 for decryption 

### Returns
zero on success, negative value otherwise
"""
function av_des_init(d, key, key_bits::Integer, decrypt::Integer)
    ccall((:av_des_init, libavutil), Cint, (Ptr{AVDES}, Ptr{UInt8}, Cint, Cint), d, key, key_bits, decrypt)
end

"""
    av_des_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)

Encrypts / decrypts using the DES algorithm.

### Parameters
* `count`: number of 8 byte blocks 

* `dst`: destination array, can be equal to src, must be 8-byte aligned 

* `src`: source array, can be equal to dst, must be 8-byte aligned, may be NULL 

* `iv`: initialization vector for CBC mode, if NULL then ECB will be used, must be 8-byte aligned 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_des_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_des_crypt, libavutil), Cvoid, (Ptr{AVDES}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), d, dst, src, count, iv, decrypt)
end

"""
    av_des_mac(d, dst, src, count::Integer)

Calculates CBC-MAC using the DES algorithm.

### Parameters
* `count`: number of 8 byte blocks 

* `dst`: destination array, can be equal to src, must be 8-byte aligned 

* `src`: source array, can be equal to dst, must be 8-byte aligned, may be NULL
"""
function av_des_mac(d, dst, src, count::Integer)
    ccall((:av_des_mac, libavutil), Cvoid, (Ptr{AVDES}, Ptr{UInt8}, Ptr{UInt8}, Cint), d, dst, src, count)
end

struct AVDictionaryEntry
    key::Cstring
    value::Cstring
end

"""
    av_dict_get(m, key, prev, flags::Integer)

Get a dictionary entry with matching key.

The returned entry key or value must not be changed, or it will cause undefined behavior.

To iterate through all the dictionary entries, you can set the matching key to the null string "" and set the [`AV_DICT_IGNORE_SUFFIX`](@ref) flag.

### Parameters
* `prev`: Set to the previous matching element to find the next. If set to NULL the first matching element is returned. 

* `key`: matching key 

* `flags`: a collection of AV\\_DICT\\_* flags controlling how the entry is retrieved 

### Returns
found entry or NULL in case no matching entry was found in the dictionary
"""
function av_dict_get(m, key, prev, flags::Integer)
    ccall((:av_dict_get, libavutil), Ptr{AVDictionaryEntry}, (Ptr{AVDictionary}, Cstring, Ptr{AVDictionaryEntry}, Cint), m, key, prev, flags)
end

"""
    av_dict_count(m)

Get number of entries in dictionary.

### Parameters
* `m`: dictionary 

### Returns
number of entries in dictionary
"""
function av_dict_count(m)
    ccall((:av_dict_count, libavutil), Cint, (Ptr{AVDictionary},), m)
end

"""
    av_dict_set(pm, key, value, flags::Integer)

Set the given entry in *pm, overwriting an existing entry.

Note: If [`AV_DICT_DONT_STRDUP_KEY`](@ref) or [`AV_DICT_DONT_STRDUP_VAL`](@ref) is set, these arguments will be freed on error.

Warning: Adding a new entry to a dictionary invalidates all existing entries previously returned with [`av_dict_get`](@ref).

### Parameters
* `pm`: pointer to a pointer to a dictionary struct. If *pm is NULL a dictionary struct is allocated and put in *pm. 

* `key`: entry key to add to *pm (will either be av\\_strduped or added as a new key depending on flags) 

* `value`: entry value to add to *pm (will be av\\_strduped or added as a new key depending on flags). Passing a NULL value will cause an existing entry to be deleted. 

### Returns
>= 0 on success otherwise an error code <0
"""
function av_dict_set(pm, key, value, flags::Integer)
    ccall((:av_dict_set, libavutil), Cint, (Ptr{Ptr{AVDictionary}}, Cstring, Cstring, Cint), pm, key, value, flags)
end

"""
    av_dict_set_int(pm, key, value::Int64, flags::Integer)

Convenience wrapper for [`av_dict_set`](@ref) that converts the value to a string and stores it.

Note: If [`AV_DICT_DONT_STRDUP_KEY`](@ref) is set, key will be freed on error.
"""
function av_dict_set_int(pm, key, value::Int64, flags::Integer)
    ccall((:av_dict_set_int, libavutil), Cint, (Ptr{Ptr{AVDictionary}}, Cstring, Int64, Cint), pm, key, value, flags)
end

"""
    av_dict_parse_string(pm, str, key_val_sep, pairs_sep, flags::Integer)

Parse the key/value pairs list and add the parsed entries to a dictionary.

In case of failure, all the successfully set entries are stored in *pm. You may need to manually free the created dictionary.

### Parameters
* `key_val_sep`: a 0-terminated list of characters used to separate key from value 

* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other 

* `flags`: flags to use when adding to dictionary. [`AV_DICT_DONT_STRDUP_KEY`](@ref) and [`AV_DICT_DONT_STRDUP_VAL`](@ref) are ignored since the key/value tokens will always be duplicated. 

### Returns
0 on success, negative [`AVERROR`](@ref) code on failure
"""
function av_dict_parse_string(pm, str, key_val_sep, pairs_sep, flags::Integer)
    ccall((:av_dict_parse_string, libavutil), Cint, (Ptr{Ptr{AVDictionary}}, Cstring, Cstring, Cstring, Cint), pm, str, key_val_sep, pairs_sep, flags)
end

"""
    av_dict_copy(dst, src, flags::Integer)

Copy entries from one [`AVDictionary`](@ref) struct into another. 

!!! note

    metadata is read using the [`AV_DICT_IGNORE_SUFFIX`](@ref) flag 

### Parameters
* `dst`: pointer to a pointer to a [`AVDictionary`](@ref) struct. If *dst is NULL, this function will allocate a struct for you and put it in *dst 

* `src`: pointer to source [`AVDictionary`](@ref) struct 

* `flags`: flags to use when setting entries in *dst 

### Returns
0 on success, negative [`AVERROR`](@ref) code on failure. If dst was allocated by this function, callers should free the associated memory.
"""
function av_dict_copy(dst, src, flags::Integer)
    ccall((:av_dict_copy, libavutil), Cint, (Ptr{Ptr{AVDictionary}}, Ptr{AVDictionary}, Cint), dst, src, flags)
end

"""
    av_dict_free(m)

Free all the memory allocated for an [`AVDictionary`](@ref) struct and all keys and values.
"""
function av_dict_free(m)
    ccall((:av_dict_free, libavutil), Cvoid, (Ptr{Ptr{AVDictionary}},), m)
end

"""
    av_dict_get_string(m, buffer, key_val_sep::Cchar, pairs_sep::Cchar)

Get dictionary entries as a string.

Create a string containing dictionary's entries. Such string may be passed back to [`av_dict_parse_string`](@ref)(). 

!!! note

    String is escaped with backslashes ('\\').

!!! warning

    Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.

### Parameters
* `m`:\\[in\\] dictionary 

* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg entries. Buffer must be freed by the caller when is no longer needed. 

* `key_val_sep`:\\[in\\] character used to separate key from value 

* `pairs_sep`:\\[in\\] character used to separate two pairs from each other 

### Returns
>= 0 on success, negative on error 
"""
function av_dict_get_string(m, buffer, key_val_sep::Cchar, pairs_sep::Cchar)
    ccall((:av_dict_get_string, libavutil), Cint, (Ptr{AVDictionary}, Ptr{Cstring}, Cchar, Cchar), m, buffer, key_val_sep, pairs_sep)
end

"""
    av_display_rotation_get(matrix)

Extract the rotation component of the transformation matrix.

!!! note

    floating point numbers are inherently inexact, so callers are recommended to round the return value to nearest integer before use.

### Parameters
* `matrix`: the transformation matrix 

### Returns
the angle (in degrees) by which the transformation rotates the frame counterclockwise. The angle will be in range [-180.0, 180.0], or NaN if the matrix is singular.
"""
function av_display_rotation_get(matrix)
    ccall((:av_display_rotation_get, libavutil), Cdouble, (Ptr{Int32},), matrix)
end

"""
    av_display_rotation_set(matrix, angle::Cdouble)

Initialize a transformation matrix describing a pure counterclockwise rotation by the specified angle (in degrees).

### Parameters
* `matrix`: an allocated transformation matrix (will be fully overwritten by this function) 

* `angle`: rotation angle in degrees.
"""
function av_display_rotation_set(matrix, angle::Cdouble)
    ccall((:av_display_rotation_set, libavutil), Cvoid, (Ptr{Int32}, Cdouble), matrix, angle)
end

"""
    av_display_matrix_flip(matrix, hflip::Integer, vflip::Integer)

Flip the input matrix horizontally and/or vertically.

### Parameters
* `matrix`: an allocated transformation matrix 

* `hflip`: whether the matrix should be flipped horizontally 

* `vflip`: whether the matrix should be flipped vertically
"""
function av_display_matrix_flip(matrix, hflip::Integer, vflip::Integer)
    ccall((:av_display_matrix_flip, libavutil), Cvoid, (Ptr{Int32}, Cint, Cint), matrix, hflip, vflip)
end

struct AVDOVIDecoderConfigurationRecord
    dv_version_major::UInt8
    dv_version_minor::UInt8
    dv_profile::UInt8
    dv_level::UInt8
    rpu_present_flag::UInt8
    el_present_flag::UInt8
    bl_present_flag::UInt8
    dv_bl_signal_compatibility_id::UInt8
end

"""
    av_dovi_alloc(size)

Allocate a [`AVDOVIDecoderConfigurationRecord`](@ref) structure and initialize its fields to default values.

### Returns
the newly allocated struct or NULL on failure
"""
function av_dovi_alloc(size)
    ccall((:av_dovi_alloc, libavutil), Ptr{AVDOVIDecoderConfigurationRecord}, (Ptr{Csize_t},), size)
end

"""
    AVDownmixType

Possible downmix types.
"""
const AVDownmixType = UInt32
const AV_DOWNMIX_TYPE_UNKNOWN = 0 % UInt32
const AV_DOWNMIX_TYPE_LORO = 1 % UInt32
const AV_DOWNMIX_TYPE_LTRT = 2 % UInt32
const AV_DOWNMIX_TYPE_DPLII = 3 % UInt32
const AV_DOWNMIX_TYPE_NB = 4 % UInt32

"""
    AVDownmixInfo

This structure describes optional metadata relevant to a downmix procedure.

All fields are set by the decoder to the value indicated in the audio bitstream (if present), or to a "sane" default otherwise.
"""
struct AVDownmixInfo
    preferred_downmix_type::AVDownmixType
    center_mix_level::Cdouble
    center_mix_level_ltrt::Cdouble
    surround_mix_level::Cdouble
    surround_mix_level_ltrt::Cdouble
    lfe_mix_level::Cdouble
end

"""
    av_downmix_info_update_side_data(frame)

Get a frame's AV\\_FRAME\\_DATA\\_DOWNMIX\\_INFO side data for editing.

If the side data is absent, it is created and added to the frame.

### Parameters
* `frame`: the frame for which the side data is to be obtained or created

### Returns
the [`AVDownmixInfo`](@ref) structure to be edited by the caller, or NULL if the structure cannot be allocated.
"""
function av_downmix_info_update_side_data(frame)
    ccall((:av_downmix_info_update_side_data, libavutil), Ptr{AVDownmixInfo}, (Ptr{AVFrame},), frame)
end

struct AVSubsampleEncryptionInfo
    bytes_of_clear_data::Cuint
    bytes_of_protected_data::Cuint
end

"""
    AVEncryptionInfo

This describes encryption info for a packet. This contains frame-specific info for how to decrypt the packet before passing it to the decoder.

The size of this struct is not part of the public ABI.
"""
struct AVEncryptionInfo
    scheme::UInt32
    crypt_byte_block::UInt32
    skip_byte_block::UInt32
    key_id::Ptr{UInt8}
    key_id_size::UInt32
    iv::Ptr{UInt8}
    iv_size::UInt32
    subsamples::Ptr{AVSubsampleEncryptionInfo}
    subsample_count::UInt32
end

"""
    AVEncryptionInitInfo

This describes info used to initialize an encryption key system.

The size of this struct is not part of the public ABI.
"""
struct AVEncryptionInitInfo
    system_id::Ptr{Cvoid} # system_id::Ptr{UInt8}
    system_id_size::UInt32
    key_ids::Ptr{Ptr{Cvoid}} # key_ids::Ptr{Ptr{UInt8}}
    num_key_ids::UInt32
    key_id_size::UInt32
    data::Ptr{Cvoid} # data::Ptr{UInt8}
    data_size::UInt32
    next::Ptr{AVEncryptionInitInfo}
end

function Base.getproperty(x::AVEncryptionInitInfo, f::Symbol)
    f === :system_id && return Ptr{UInt8}(getfield(x, f))
    f === :key_ids && return Ptr{Ptr{UInt8}}(getfield(x, f))
    f === :data && return Ptr{UInt8}(getfield(x, f))
    return getfield(x, f)
end

"""
    av_encryption_info_alloc(subsample_count::Integer, key_id_size::Integer, iv_size::Integer)

Allocates an [`AVEncryptionInfo`](@ref) structure and sub-pointers to hold the given number of subsamples. This will allocate pointers for the key ID, IV, and subsample entries, set the size members, and zero-initialize the rest.

### Parameters
* `subsample_count`: The number of subsamples. 

* `key_id_size`: The number of bytes in the key ID, should be 16. 

* `iv_size`: The number of bytes in the IV, should be 16.

### Returns
The new [`AVEncryptionInfo`](@ref) structure, or NULL on error.
"""
function av_encryption_info_alloc(subsample_count::Integer, key_id_size::Integer, iv_size::Integer)
    ccall((:av_encryption_info_alloc, libavutil), Ptr{AVEncryptionInfo}, (UInt32, UInt32, UInt32), subsample_count, key_id_size, iv_size)
end

"""
    av_encryption_info_clone(info)

Allocates an [`AVEncryptionInfo`](@ref) structure with a copy of the given data. 

### Returns
The new [`AVEncryptionInfo`](@ref) structure, or NULL on error.
"""
function av_encryption_info_clone(info)
    ccall((:av_encryption_info_clone, libavutil), Ptr{AVEncryptionInfo}, (Ptr{AVEncryptionInfo},), info)
end

"""
    av_encryption_info_free(info)

Frees the given encryption info object. This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods.
"""
function av_encryption_info_free(info)
    ccall((:av_encryption_info_free, libavutil), Cvoid, (Ptr{AVEncryptionInfo},), info)
end

"""
    av_encryption_info_get_side_data(side_data, side_data_size::Csize_t)

Creates a copy of the [`AVEncryptionInfo`](@ref) that is contained in the given side data. The resulting object should be passed to [`av_encryption_info_free`](@ref)() when done.

### Returns
The new [`AVEncryptionInfo`](@ref) structure, or NULL on error.
"""
function av_encryption_info_get_side_data(side_data, side_data_size::Csize_t)
    ccall((:av_encryption_info_get_side_data, libavutil), Ptr{AVEncryptionInfo}, (Ptr{UInt8}, Csize_t), side_data, side_data_size)
end

"""
    av_encryption_info_add_side_data(info, side_data_size)

Allocates and initializes side data that holds a copy of the given encryption info. The resulting pointer should be either freed using [`av_free`](@ref) or given to [`av_packet_add_side_data`](@ref)().

### Returns
The new side-data pointer, or NULL.
"""
function av_encryption_info_add_side_data(info, side_data_size)
    ccall((:av_encryption_info_add_side_data, libavutil), Ptr{UInt8}, (Ptr{AVEncryptionInfo}, Ptr{Csize_t}), info, side_data_size)
end

"""
    av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)

Allocates an [`AVEncryptionInitInfo`](@ref) structure and sub-pointers to hold the given sizes. This will allocate pointers and set all the fields.

### Returns
The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
"""
function av_encryption_init_info_alloc(system_id_size::Integer, num_key_ids::Integer, key_id_size::Integer, data_size::Integer)
    ccall((:av_encryption_init_info_alloc, libavutil), Ptr{AVEncryptionInitInfo}, (UInt32, UInt32, UInt32, UInt32), system_id_size, num_key_ids, key_id_size, data_size)
end

"""
    av_encryption_init_info_free(info)

Frees the given encryption init info object. This MUST NOT be used to free the side-data data pointer, that should use normal side-data methods.
"""
function av_encryption_init_info_free(info)
    ccall((:av_encryption_init_info_free, libavutil), Cvoid, (Ptr{AVEncryptionInitInfo},), info)
end

"""
    av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)

Creates a copy of the [`AVEncryptionInitInfo`](@ref) that is contained in the given side data. The resulting object should be passed to [`av_encryption_init_info_free`](@ref)() when done.

### Returns
The new [`AVEncryptionInitInfo`](@ref) structure, or NULL on error.
"""
function av_encryption_init_info_get_side_data(side_data, side_data_size::Csize_t)
    ccall((:av_encryption_init_info_get_side_data, libavutil), Ptr{AVEncryptionInitInfo}, (Ptr{UInt8}, Csize_t), side_data, side_data_size)
end

"""
    av_encryption_init_info_add_side_data(info, side_data_size)

Allocates and initializes side data that holds a copy of the given encryption init info. The resulting pointer should be either freed using [`av_free`](@ref) or given to [`av_packet_add_side_data`](@ref)().

### Returns
The new side-data pointer, or NULL.
"""
function av_encryption_init_info_add_side_data(info, side_data_size)
    ccall((:av_encryption_init_info_add_side_data, libavutil), Ptr{UInt8}, (Ptr{AVEncryptionInitInfo}, Ptr{Csize_t}), info, side_data_size)
end

"""
    av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)

Fill the provided buffer with a string containing an error string corresponding to the [`AVERROR`](@ref) code errnum.

### Parameters
* `errbuf`: a buffer 

* `errbuf_size`: size in bytes of errbuf 

* `errnum`: error code to describe 

### Returns
the buffer in input, filled with the error description 

### See also
[`av_strerror`](@ref)()
"""
function av_make_error_string(errbuf, errbuf_size::Csize_t, errnum::Integer)
    ccall((:av_make_error_string, libavutil), Cstring, (Cstring, Csize_t, Cint), errbuf, errbuf_size, errnum)
end

"""
    av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)

Put a description of the [`AVERROR`](@ref) code errnum in errbuf. In case of failure the global variable errno is set to indicate the error. Even in case of failure [`av_strerror`](@ref)() will print a generic error message indicating the errnum provided to errbuf.

### Parameters
* `errnum`: error code to describe 

* `errbuf`: buffer to which description is written 

* `errbuf_size`: the size in bytes of errbuf 

### Returns
0 on success, a negative value if a description for errnum cannot be found
"""
function av_strerror(errnum::Integer, errbuf, errbuf_size::Csize_t)
    ccall((:av_strerror, libavutil), Cint, (Cint, Cstring, Csize_t), errnum, errbuf, errbuf_size)
end

mutable struct AVExpr end

"""
    av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)

Parse and evaluate an expression. Note, this is significantly slower than [`av_expr_eval`](@ref)().

### Parameters
* `res`: a pointer to a double where is put the result value of the expression, or NAN in case of error 

* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)" 

* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0} 

* `const_values`: a zero terminated array of values for the identifiers from const\\_names 

* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers 

* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument 

* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers 

* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments 

* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2 

* `log_ctx`: parent logging context 

### Returns
>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
"""
function av_expr_parse_and_eval(res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset::Integer, log_ctx)
    ccall((:av_expr_parse_and_eval, libavutil), Cint, (Ptr{Cdouble}, Cstring, Ptr{Cstring}, Ptr{Cdouble}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), res, s, const_names, const_values, func1_names, funcs1, func2_names, funcs2, opaque, log_offset, log_ctx)
end

"""
    av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)

Parse an expression.

### Parameters
* `expr`: a pointer where is put an [`AVExpr`](@ref) containing the parsed value in case of successful parsing, or NULL otherwise. The pointed to [`AVExpr`](@ref) must be freed with [`av_expr_free`](@ref)() by the user when it is not needed anymore. 

* `s`: expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)" 

* `const_names`: NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0} 

* `func1_names`: NULL terminated array of zero terminated strings of funcs1 identifiers 

* `funcs1`: NULL terminated array of function pointers for functions which take 1 argument 

* `func2_names`: NULL terminated array of zero terminated strings of funcs2 identifiers 

* `funcs2`: NULL terminated array of function pointers for functions which take 2 arguments 

* `log_ctx`: parent logging context 

### Returns
>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
"""
function av_expr_parse(expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset::Integer, log_ctx)
    ccall((:av_expr_parse, libavutil), Cint, (Ptr{Ptr{AVExpr}}, Cstring, Ptr{Cstring}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Ptr{Cstring}, Ptr{Ptr{Cvoid}}, Cint, Ptr{Cvoid}), expr, s, const_names, func1_names, funcs1, func2_names, funcs2, log_offset, log_ctx)
end

"""
    av_expr_eval(e, const_values, opaque)

Evaluate a previously parsed expression.

### Parameters
* `const_values`: a zero terminated array of values for the identifiers from [`av_expr_parse`](@ref)() const\\_names 

* `opaque`: a pointer which will be passed to all functions from funcs1 and funcs2 

### Returns
the value of the expression
"""
function av_expr_eval(e, const_values, opaque)
    ccall((:av_expr_eval, libavutil), Cdouble, (Ptr{AVExpr}, Ptr{Cdouble}, Ptr{Cvoid}), e, const_values, opaque)
end

"""
    av_expr_count_vars(e, counter, size::Integer)

Track the presence of variables and their number of occurrences in a parsed expression

### Parameters
* `counter`: a zero-initialized array where the count of each variable will be stored 

* `size`: size of array 

### Returns
0 on success, a negative value indicates that no expression or array was passed or size was zero
"""
function av_expr_count_vars(e, counter, size::Integer)
    ccall((:av_expr_count_vars, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint), e, counter, size)
end

"""
    av_expr_count_func(e, counter, size::Integer, arg::Integer)

Track the presence of user provided functions and their number of occurrences in a parsed expression.

### Parameters
* `counter`: a zero-initialized array where the count of each function will be stored if you passed 5 functions with 2 arguments to [`av_expr_parse`](@ref)() then for arg=2 this will use upto 5 entries. 

* `size`: size of array 

* `arg`: number of arguments the counted functions have 

### Returns
0 on success, a negative value indicates that no expression or array was passed or size was zero
"""
function av_expr_count_func(e, counter, size::Integer, arg::Integer)
    ccall((:av_expr_count_func, libavutil), Cint, (Ptr{AVExpr}, Ptr{Cuint}, Cint, Cint), e, counter, size, arg)
end

"""
    av_expr_free(e)

Free a parsed expression previously created with [`av_expr_parse`](@ref)().
"""
function av_expr_free(e)
    ccall((:av_expr_free, libavutil), Cvoid, (Ptr{AVExpr},), e)
end

"""
    av_strtod(numstr, tail)

Parse the string in numstr and return its value as a double. If the string is empty, contains only whitespaces, or does not contain an initial substring that has the expected syntax for a floating-point number, no conversion is performed. In this case, returns a value of zero and the value returned in tail is the value of numstr.

### Parameters
* `numstr`: a string representing a number, may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value by 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix. 

* `tail`: if non-NULL puts here the pointer to the char next after the last parsed character
"""
function av_strtod(numstr, tail)
    ccall((:av_strtod, libavutil), Cdouble, (Cstring, Ptr{Cstring}), numstr, tail)
end

struct AVFifoBuffer
    buffer::Ptr{UInt8}
    rptr::Ptr{UInt8}
    wptr::Ptr{UInt8}
    _end::Ptr{UInt8}
    rndx::UInt32
    wndx::UInt32
end

"""
    av_fifo_alloc(size::Integer)

Initialize an [`AVFifoBuffer`](@ref). 

### Parameters
* `size`: of FIFO 

### Returns
[`AVFifoBuffer`](@ref) or NULL in case of memory allocation failure
"""
function av_fifo_alloc(size::Integer)
    ccall((:av_fifo_alloc, libavutil), Ptr{AVFifoBuffer}, (Cuint,), size)
end

"""
    av_fifo_alloc_array(nmemb::Csize_t, size::Csize_t)

Initialize an [`AVFifoBuffer`](@ref). 

### Parameters
* `nmemb`: number of elements 

* `size`: size of the single element 

### Returns
[`AVFifoBuffer`](@ref) or NULL in case of memory allocation failure
"""
function av_fifo_alloc_array(nmemb::Csize_t, size::Csize_t)
    ccall((:av_fifo_alloc_array, libavutil), Ptr{AVFifoBuffer}, (Csize_t, Csize_t), nmemb, size)
end

"""
    av_fifo_free(f)

Free an [`AVFifoBuffer`](@ref). 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to free
"""
function av_fifo_free(f)
    ccall((:av_fifo_free, libavutil), Cvoid, (Ptr{AVFifoBuffer},), f)
end

"""
    av_fifo_freep(f)

Free an [`AVFifoBuffer`](@ref) and reset pointer to NULL. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to free
"""
function av_fifo_freep(f)
    ccall((:av_fifo_freep, libavutil), Cvoid, (Ptr{Ptr{AVFifoBuffer}},), f)
end

"""
    av_fifo_reset(f)

Reset the [`AVFifoBuffer`](@ref) to the state right after [`av_fifo_alloc`](@ref), in particular it is emptied. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to reset
"""
function av_fifo_reset(f)
    ccall((:av_fifo_reset, libavutil), Cvoid, (Ptr{AVFifoBuffer},), f)
end

"""
    av_fifo_size(f)

Return the amount of data in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can read from it. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to read from 

### Returns
size
"""
function av_fifo_size(f)
    ccall((:av_fifo_size, libavutil), Cint, (Ptr{AVFifoBuffer},), f)
end

"""
    av_fifo_space(f)

Return the amount of space in bytes in the [`AVFifoBuffer`](@ref), that is the amount of data you can write into it. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to write into 

### Returns
size
"""
function av_fifo_space(f)
    ccall((:av_fifo_space, libavutil), Cint, (Ptr{AVFifoBuffer},), f)
end

"""
    av_fifo_generic_peek_at(f, dest, offset::Integer, buf_size::Integer, func)

Feed data at specific position from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to read from 

* `offset`: offset from current read position 

* `buf_size`: number of bytes to read 

* `func`: generic read function 

* `dest`: data destination
"""
function av_fifo_generic_peek_at(f, dest, offset::Integer, buf_size::Integer, func)
    ccall((:av_fifo_generic_peek_at, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Cint, Ptr{Cvoid}), f, dest, offset, buf_size, func)
end

"""
    av_fifo_generic_peek(f, dest, buf_size::Integer, func)

Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback. Similar as av\\_fifo\\_gereric\\_read but without discarding data. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to read from 

* `buf_size`: number of bytes to read 

* `func`: generic read function 

* `dest`: data destination
"""
function av_fifo_generic_peek(f, dest, buf_size::Integer, func)
    ccall((:av_fifo_generic_peek, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, dest, buf_size, func)
end

"""
    av_fifo_generic_read(f, dest, buf_size::Integer, func)

Feed data from an [`AVFifoBuffer`](@ref) to a user-supplied callback. 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to read from 

* `buf_size`: number of bytes to read 

* `func`: generic read function 

* `dest`: data destination
"""
function av_fifo_generic_read(f, dest, buf_size::Integer, func)
    ccall((:av_fifo_generic_read, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, dest, buf_size, func)
end

"""
    av_fifo_generic_write(f, src, size::Integer, func)

Feed data from a user-supplied callback to an [`AVFifoBuffer`](@ref). 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to write to 

* `src`: data source; non-const since it may be used as a modifiable context by the function defined in func 

* `size`: number of bytes to write 

* `func`: generic write function; the first parameter is src, the second is dest\\_buf, the third is dest\\_buf\\_size. func must return the number of bytes written to dest\\_buf, or <= 0 to indicate no more data available to write. If func is NULL, src is interpreted as a simple byte array for source data. 

### Returns
the number of bytes written to the FIFO
"""
function av_fifo_generic_write(f, src, size::Integer, func)
    ccall((:av_fifo_generic_write, libavutil), Cint, (Ptr{AVFifoBuffer}, Ptr{Cvoid}, Cint, Ptr{Cvoid}), f, src, size, func)
end

"""
    av_fifo_realloc2(f, size::Integer)

Resize an [`AVFifoBuffer`](@ref). In case of reallocation failure, the old FIFO is kept unchanged.

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to resize 

* `size`: new [`AVFifoBuffer`](@ref) size in bytes 

### Returns
<0 for failure, >=0 otherwise
"""
function av_fifo_realloc2(f, size::Integer)
    ccall((:av_fifo_realloc2, libavutil), Cint, (Ptr{AVFifoBuffer}, Cuint), f, size)
end

"""
    av_fifo_grow(f, additional_space::Integer)

Enlarge an [`AVFifoBuffer`](@ref). In case of reallocation failure, the old FIFO is kept unchanged. The new fifo size may be larger than the requested size.

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to resize 

* `additional_space`: the amount of space in bytes to allocate in addition to [`av_fifo_size`](@ref)() 

### Returns
<0 for failure, >=0 otherwise
"""
function av_fifo_grow(f, additional_space::Integer)
    ccall((:av_fifo_grow, libavutil), Cint, (Ptr{AVFifoBuffer}, Cuint), f, additional_space)
end

"""
    av_fifo_drain(f, size::Integer)

Read and discard the specified amount of data from an [`AVFifoBuffer`](@ref). 

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to read from 

* `size`: amount of data to read in bytes
"""
function av_fifo_drain(f, size::Integer)
    ccall((:av_fifo_drain, libavutil), Cvoid, (Ptr{AVFifoBuffer}, Cint), f, size)
end

"""
    av_fifo_peek2(f, offs::Integer)

Return a pointer to the data stored in a FIFO buffer at a certain offset. The FIFO buffer is not modified.

### Parameters
* `f`: [`AVFifoBuffer`](@ref) to peek at, f must be non-NULL 

* `offs`: an offset in bytes, its absolute value must be less than the used buffer size or the returned pointer will point outside to the buffer data. The used buffer size can be checked with [`av_fifo_size`](@ref)().
"""
function av_fifo_peek2(f, offs::Integer)
    ccall((:av_fifo_peek2, libavutil), Ptr{UInt8}, (Ptr{AVFifoBuffer}, Cint), f, offs)
end

"""
    av_file_map(filename, bufptr, size, log_offset::Integer, log_ctx)

Read the file with name filename, and put its content in a newly allocated buffer or map it with mmap() when available. In case of success set *bufptr to the read or mmapped buffer, and *size to the size in bytes of the buffer in *bufptr. Unlike mmap this function succeeds with zero sized files, in this case *bufptr will be set to NULL and *size will be set to 0. The returned buffer must be released with [`av_file_unmap`](@ref)().

### Parameters
* `log_offset`: loglevel offset used for logging 

* `log_ctx`: context used for logging 

### Returns
a non negative number in case of success, a negative value corresponding to an [`AVERROR`](@ref) error code in case of failure
"""
function av_file_map(filename, bufptr, size, log_offset::Integer, log_ctx)
    ccall((:av_file_map, libavutil), Cint, (Cstring, Ptr{Ptr{UInt8}}, Ptr{Csize_t}, Cint, Ptr{Cvoid}), filename, bufptr, size, log_offset, log_ctx)
end

"""
    av_file_unmap(bufptr, size::Csize_t)

Unmap or free the buffer bufptr created by [`av_file_map`](@ref)().

### Parameters
* `size`: size in bytes of bufptr, must be the same as returned by [`av_file_map`](@ref)()
"""
function av_file_unmap(bufptr, size::Csize_t)
    ccall((:av_file_unmap, libavutil), Cvoid, (Ptr{UInt8}, Csize_t), bufptr, size)
end

"""
    av_tempfile(prefix, filename, log_offset::Integer, log_ctx)

Wrapper to work around the lack of mkstemp() on mingw. Also, tries to create file in /tmp first, if possible. *prefix can be a character constant; *filename will be allocated internally. 

!!! note

    On very old libcs it is necessary to set a secure umask before calling this, [`av_tempfile`](@ref)() can't call umask itself as it is used in libraries and could interfere with the calling application. 

\\deprecated as fd numbers cannot be passed saftely between libs on some platforms

### Returns
file descriptor of opened file (or negative value corresponding to an [`AVERROR`](@ref) code on error) and opened file name in **filename. 
"""
function av_tempfile(prefix, filename, log_offset::Integer, log_ctx)
    ccall((:av_tempfile, libavutil), Cint, (Cstring, Ptr{Cstring}, Cint, Ptr{Cvoid}), prefix, filename, log_offset, log_ctx)
end

const AVFilmGrainParamsType = UInt32
const AV_FILM_GRAIN_PARAMS_NONE = 0 % UInt32
const AV_FILM_GRAIN_PARAMS_AV1 = 1 % UInt32

"""
    AVFilmGrainAOMParams

This structure describes how to handle film grain synthesis for AOM codecs.

!!! note

    The struct must be allocated as part of [`AVFilmGrainParams`](@ref) using [`av_film_grain_params_alloc`](@ref)(). Its size is not a part of the public ABI.
"""
struct AVFilmGrainAOMParams
    num_y_points::Cint
    y_points::NTuple{14, NTuple{2, UInt8}}
    chroma_scaling_from_luma::Cint
    num_uv_points::NTuple{2, Cint}
    uv_points::NTuple{2, NTuple{10, NTuple{2, UInt8}}}
    scaling_shift::Cint
    ar_coeff_lag::Cint
    ar_coeffs_y::NTuple{24, Int8}
    ar_coeffs_uv::NTuple{2, NTuple{25, Int8}}
    ar_coeff_shift::Cint
    grain_scale_shift::Cint
    uv_mult::NTuple{2, Cint}
    uv_mult_luma::NTuple{2, Cint}
    uv_offset::NTuple{2, Cint}
    overlap_flag::Cint
    limit_output_range::Cint
end

"""
    __JL_Ctag_1123

Additional fields may be added both here and in any structure included. If a codec's film grain structure differs slightly over another codec's, fields within may change meaning depending on the type.
"""
struct __JL_Ctag_1123
    data::NTuple{208, UInt8}
end

function Base.getproperty(x::Ptr{__JL_Ctag_1123}, f::Symbol)
    f === :aom && return Ptr{AVFilmGrainAOMParams}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::__JL_Ctag_1123, f::Symbol)
    r = Ref{__JL_Ctag_1123}(x)
    ptr = Base.unsafe_convert(Ptr{__JL_Ctag_1123}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{__JL_Ctag_1123}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVFilmGrainParams

This structure describes how to handle film grain synthesis in video for specific codecs. Must be present on every frame where film grain is meant to be synthesised for correct presentation.

!!! note

    The struct must be allocated with [`av_film_grain_params_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVFilmGrainParams
    data::NTuple{224, UInt8}
end

function Base.getproperty(x::Ptr{AVFilmGrainParams}, f::Symbol)
    f === :type && return Ptr{AVFilmGrainParamsType}(x + 0)
    f === :seed && return Ptr{UInt64}(x + 8)
    f === :codec && return Ptr{__JL_Ctag_1123}(x + 16)
    return getfield(x, f)
end

function Base.getproperty(x::AVFilmGrainParams, f::Symbol)
    r = Ref{AVFilmGrainParams}(x)
    ptr = Base.unsafe_convert(Ptr{AVFilmGrainParams}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVFilmGrainParams}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    av_film_grain_params_alloc(size)

Allocate an [`AVFilmGrainParams`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)(). If size is not NULL it will be set to the number of bytes allocated.

### Returns
An [`AVFilmGrainParams`](@ref) filled with default values or NULL on failure.
"""
function av_film_grain_params_alloc(size)
    ccall((:av_film_grain_params_alloc, libavutil), Ptr{AVFilmGrainParams}, (Ptr{Csize_t},), size)
end

"""
    av_film_grain_params_create_side_data(frame)

Allocate a complete [`AVFilmGrainParams`](@ref) and add it to the frame.

### Parameters
* `frame`: The frame which side data is added to.

### Returns
The [`AVFilmGrainParams`](@ref) structure to be filled by caller.
"""
function av_film_grain_params_create_side_data(frame)
    ccall((:av_film_grain_params_create_side_data, libavutil), Ptr{AVFilmGrainParams}, (Ptr{AVFrame},), frame)
end

const AVActiveFormatDescription = UInt32
const AV_AFD_SAME = 8 % UInt32
const AV_AFD_4_3 = 9 % UInt32
const AV_AFD_16_9 = 10 % UInt32
const AV_AFD_14_9 = 11 % UInt32
const AV_AFD_4_3_SP_14_9 = 13 % UInt32
const AV_AFD_16_9_SP_14_9 = 14 % UInt32
const AV_AFD_SP_4_3 = 15 % UInt32

"""
    AVRegionOfInterest

Structure describing a single Region Of Interest.

When multiple regions are defined in a single side-data block, they should be ordered from most to least important - some encoders are only capable of supporting a limited number of distinct regions, so will have to truncate the list.

When overlapping regions are defined, the first region containing a given area of the frame applies.
"""
struct AVRegionOfInterest
    self_size::UInt32
    top::Cint
    bottom::Cint
    left::Cint
    right::Cint
    qoffset::AVRational
end

"""
    av_frame_get_best_effort_timestamp(frame)

Accessors for some [`AVFrame`](@ref) fields. These used to be provided for ABI compatibility, and do not need to be used anymore.
"""
function av_frame_get_best_effort_timestamp(frame)
    ccall((:av_frame_get_best_effort_timestamp, libavutil), Int64, (Ptr{AVFrame},), frame)
end

function av_frame_set_best_effort_timestamp(frame, val::Int64)
    ccall((:av_frame_set_best_effort_timestamp, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
end

function av_frame_get_pkt_duration(frame)
    ccall((:av_frame_get_pkt_duration, libavutil), Int64, (Ptr{AVFrame},), frame)
end

function av_frame_set_pkt_duration(frame, val::Int64)
    ccall((:av_frame_set_pkt_duration, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
end

function av_frame_get_pkt_pos(frame)
    ccall((:av_frame_get_pkt_pos, libavutil), Int64, (Ptr{AVFrame},), frame)
end

function av_frame_set_pkt_pos(frame, val::Int64)
    ccall((:av_frame_set_pkt_pos, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
end

function av_frame_get_channel_layout(frame)
    ccall((:av_frame_get_channel_layout, libavutil), Int64, (Ptr{AVFrame},), frame)
end

function av_frame_set_channel_layout(frame, val::Int64)
    ccall((:av_frame_set_channel_layout, libavutil), Cvoid, (Ptr{AVFrame}, Int64), frame, val)
end

function av_frame_get_channels(frame)
    ccall((:av_frame_get_channels, libavutil), Cint, (Ptr{AVFrame},), frame)
end

function av_frame_set_channels(frame, val::Integer)
    ccall((:av_frame_set_channels, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
end

function av_frame_get_sample_rate(frame)
    ccall((:av_frame_get_sample_rate, libavutil), Cint, (Ptr{AVFrame},), frame)
end

function av_frame_set_sample_rate(frame, val::Integer)
    ccall((:av_frame_set_sample_rate, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
end

function av_frame_get_metadata(frame)
    ccall((:av_frame_get_metadata, libavutil), Ptr{AVDictionary}, (Ptr{AVFrame},), frame)
end

function av_frame_set_metadata(frame, val)
    ccall((:av_frame_set_metadata, libavutil), Cvoid, (Ptr{AVFrame}, Ptr{AVDictionary}), frame, val)
end

function av_frame_get_decode_error_flags(frame)
    ccall((:av_frame_get_decode_error_flags, libavutil), Cint, (Ptr{AVFrame},), frame)
end

function av_frame_set_decode_error_flags(frame, val::Integer)
    ccall((:av_frame_set_decode_error_flags, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
end

function av_frame_get_pkt_size(frame)
    ccall((:av_frame_get_pkt_size, libavutil), Cint, (Ptr{AVFrame},), frame)
end

function av_frame_set_pkt_size(frame, val::Integer)
    ccall((:av_frame_set_pkt_size, libavutil), Cvoid, (Ptr{AVFrame}, Cint), frame, val)
end

function av_frame_get_qp_table(f, stride, type)
    ccall((:av_frame_get_qp_table, libavutil), Ptr{Int8}, (Ptr{AVFrame}, Ptr{Cint}, Ptr{Cint}), f, stride, type)
end

function av_frame_set_qp_table(f, buf, stride::Integer, type::Integer)
    ccall((:av_frame_set_qp_table, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVBufferRef}, Cint, Cint), f, buf, stride, type)
end

function av_frame_get_colorspace(frame)
    ccall((:av_frame_get_colorspace, libavutil), AVColorSpace, (Ptr{AVFrame},), frame)
end

function av_frame_set_colorspace(frame, val::AVColorSpace)
    ccall((:av_frame_set_colorspace, libavutil), Cvoid, (Ptr{AVFrame}, AVColorSpace), frame, val)
end

function av_frame_get_color_range(frame)
    ccall((:av_frame_get_color_range, libavutil), AVColorRange, (Ptr{AVFrame},), frame)
end

function av_frame_set_color_range(frame, val::AVColorRange)
    ccall((:av_frame_set_color_range, libavutil), Cvoid, (Ptr{AVFrame}, AVColorRange), frame, val)
end

"""
    av_get_colorspace_name(val::AVColorSpace)

Get the name of a colorspace. 

### Returns
a static string identifying the colorspace; can be NULL.
"""
function av_get_colorspace_name(val::AVColorSpace)
    ccall((:av_get_colorspace_name, libavutil), Cstring, (AVColorSpace,), val)
end

"""
    av_frame_alloc()

Allocate an [`AVFrame`](@ref) and set its fields to default values. The resulting struct must be freed using [`av_frame_free`](@ref)().

!!! note

    this only allocates the [`AVFrame`](@ref) itself, not the data buffers. Those must be allocated through other means, e.g. with [`av_frame_get_buffer`](@ref)() or manually.

### Returns
An [`AVFrame`](@ref) filled with default values or NULL on failure.
"""
function av_frame_alloc()
    ccall((:av_frame_alloc, libavutil), Ptr{AVFrame}, ())
end

"""
    av_frame_free(frame)

Free the frame and any dynamically allocated objects in it, e.g. extended\\_data. If the frame is reference counted, it will be unreferenced first.

### Parameters
* `frame`: frame to be freed. The pointer will be set to NULL.
"""
function av_frame_free(frame)
    ccall((:av_frame_free, libavutil), Cvoid, (Ptr{Ptr{AVFrame}},), frame)
end

"""
    av_frame_ref(dst, src)

Set up a new reference to the data described by the source frame.

Copy frame properties from src to dst and create a new reference for each [`AVBufferRef`](@ref) from src.

If src is not reference counted, new buffers are allocated and the data is copied.

!!! warning

    : dst MUST have been either unreferenced with [`av_frame_unref`](@ref)(dst), or newly allocated with [`av_frame_alloc`](@ref)() before calling this function, or undefined behavior will occur.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error
"""
function av_frame_ref(dst, src)
    ccall((:av_frame_ref, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
end

"""
    av_frame_clone(src)

Create a new frame that references the same data as src.

This is a shortcut for [`av_frame_alloc`](@ref)()+[`av_frame_ref`](@ref)().

### Returns
newly created [`AVFrame`](@ref) on success, NULL on error.
"""
function av_frame_clone(src)
    ccall((:av_frame_clone, libavutil), Ptr{AVFrame}, (Ptr{AVFrame},), src)
end

"""
    av_frame_unref(frame)

Unreference all the buffers referenced by frame and reset the frame fields.
"""
function av_frame_unref(frame)
    ccall((:av_frame_unref, libavutil), Cvoid, (Ptr{AVFrame},), frame)
end

"""
    av_frame_move_ref(dst, src)

Move everything contained in src to dst and reset src.

!!! warning

    : dst is not unreferenced, but directly overwritten without reading or deallocating its contents. Call [`av_frame_unref`](@ref)(dst) manually before calling this function to ensure that no memory is leaked.
"""
function av_frame_move_ref(dst, src)
    ccall((:av_frame_move_ref, libavutil), Cvoid, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
end

"""
    av_frame_get_buffer(frame, align::Integer)

Allocate new buffer(s) for audio or video data.

The following fields must be set on frame before calling this function: - format (pixel format for video, sample format for audio) - width and height for video - nb\\_samples and channel\\_layout for audio

This function will fill [`AVFrame`](@ref).data and [`AVFrame`](@ref).buf arrays and, if necessary, allocate and fill [`AVFrame`](@ref).extended\\_data and [`AVFrame`](@ref).extended\\_buf. For planar formats, one buffer will be allocated for each plane.

!!! warning

    : if frame already has been allocated, calling this function will leak memory. In addition, undefined behavior can occur in certain cases.

### Parameters
* `frame`: frame in which to store the new buffers. 

* `align`: Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error.
"""
function av_frame_get_buffer(frame, align::Integer)
    ccall((:av_frame_get_buffer, libavutil), Cint, (Ptr{AVFrame}, Cint), frame, align)
end

"""
    av_frame_is_writable(frame)

Check if the frame data is writable.

If 1 is returned the answer is valid until [`av_buffer_ref`](@ref)() is called on any of the underlying AVBufferRefs (e.g. through [`av_frame_ref`](@ref)() or directly).

### Returns
A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.

### See also
[`av_frame_make_writable`](@ref)(), [`av_buffer_is_writable`](@ref)()
"""
function av_frame_is_writable(frame)
    ccall((:av_frame_is_writable, libavutil), Cint, (Ptr{AVFrame},), frame)
end

"""
    av_frame_make_writable(frame)

Ensure that the frame data is writable, avoiding data copy if possible.

Do nothing if the frame is writable, allocate new buffers and copy the data if it is not.

### Returns
0 on success, a negative [`AVERROR`](@ref) on error.

### See also
[`av_frame_is_writable`](@ref)(), [`av_buffer_is_writable`](@ref)(), [`av_buffer_make_writable`](@ref)()
"""
function av_frame_make_writable(frame)
    ccall((:av_frame_make_writable, libavutil), Cint, (Ptr{AVFrame},), frame)
end

"""
    av_frame_copy(dst, src)

Copy the frame data from src to dst.

This function does not allocate anything, dst must be already initialized and allocated with the same parameters as src.

This function only copies the frame data (i.e. the contents of the data / extended data arrays), not any other properties.

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) on error.
"""
function av_frame_copy(dst, src)
    ccall((:av_frame_copy, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
end

"""
    av_frame_copy_props(dst, src)

Copy only "metadata" fields from src to dst.

Metadata for the purpose of this function are those fields that do not affect the data layout in the buffers. E.g. pts, sample rate (for audio) or sample aspect ratio (for video), but not width/height or channel layout. Side data is also copied.
"""
function av_frame_copy_props(dst, src)
    ccall((:av_frame_copy_props, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}), dst, src)
end

"""
    av_frame_get_plane_buffer(frame, plane::Integer)

Get the buffer reference a given data plane is stored in.

### Parameters
* `plane`: index of the data plane of interest in frame->extended\\_data.

### Returns
the buffer reference that contains the plane or NULL if the input frame is not valid.
"""
function av_frame_get_plane_buffer(frame, plane::Integer)
    ccall((:av_frame_get_plane_buffer, libavutil), Ptr{AVBufferRef}, (Ptr{AVFrame}, Cint), frame, plane)
end

"""
    av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Integer)

Add a new side data to a frame.

### Parameters
* `frame`: a frame to which the side data should be added 

* `type`: type of the added side data 

* `size`: size of the side data

### Returns
newly added side data on success, NULL on error
"""
function av_frame_new_side_data(frame, type::AVFrameSideDataType, size::Integer)
    ccall((:av_frame_new_side_data, libavutil), Ptr{AVFrameSideData}, (Ptr{AVFrame}, AVFrameSideDataType, Cint), frame, type, size)
end

"""
    av_frame_new_side_data_from_buf(frame, type::AVFrameSideDataType, buf)

Add a new side data to a frame from an existing [`AVBufferRef`](@ref)

### Parameters
* `frame`: a frame to which the side data should be added 

* `type`: the type of the added side data 

* `buf`: an [`AVBufferRef`](@ref) to add as side data. The ownership of the reference is transferred to the frame.

### Returns
newly added side data on success, NULL on error. On failure the frame is unchanged and the [`AVBufferRef`](@ref) remains owned by the caller.
"""
function av_frame_new_side_data_from_buf(frame, type::AVFrameSideDataType, buf)
    ccall((:av_frame_new_side_data_from_buf, libavutil), Ptr{AVFrameSideData}, (Ptr{AVFrame}, AVFrameSideDataType, Ptr{AVBufferRef}), frame, type, buf)
end

"""
    av_frame_get_side_data(frame, type::AVFrameSideDataType)

### Returns
a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame.
"""
function av_frame_get_side_data(frame, type::AVFrameSideDataType)
    ccall((:av_frame_get_side_data, libavutil), Ptr{AVFrameSideData}, (Ptr{AVFrame}, AVFrameSideDataType), frame, type)
end

"""
    av_frame_remove_side_data(frame, type::AVFrameSideDataType)

Remove and free all side data instances of the given type.
"""
function av_frame_remove_side_data(frame, type::AVFrameSideDataType)
    ccall((:av_frame_remove_side_data, libavutil), Cvoid, (Ptr{AVFrame}, AVFrameSideDataType), frame, type)
end

"""
    __JL_Ctag_731

Flags for frame cropping.
"""
const __JL_Ctag_731 = UInt32
const AV_FRAME_CROP_UNALIGNED = 1 % UInt32

"""
    av_frame_apply_cropping(frame, flags::Integer)

Crop the given video [`AVFrame`](@ref) according to its crop\\_left/crop\\_top/crop\\_right/ crop\\_bottom fields. If cropping is successful, the function will adjust the data pointers and the width/height fields, and set the crop fields to 0.

In all cases, the cropping boundaries will be rounded to the inherent alignment of the pixel format. In some cases, such as for opaque hwaccel formats, the left/top cropping is ignored. The crop fields are set to 0 even if the cropping was rounded or ignored.

### Parameters
* `frame`: the frame which should be cropped 

* `flags`: Some combination of AV\\_FRAME\\_CROP\\_* flags, or 0.

### Returns
>= 0 on success, a negative [`AVERROR`](@ref) on error. If the cropping fields were invalid, [`AVERROR`](@ref)(ERANGE) is returned, and nothing is changed.
"""
function av_frame_apply_cropping(frame, flags::Integer)
    ccall((:av_frame_apply_cropping, libavutil), Cint, (Ptr{AVFrame}, Cint), frame, flags)
end

"""
    av_frame_side_data_name(type::AVFrameSideDataType)

### Returns
a string identifying the side data type
"""
function av_frame_side_data_name(type::AVFrameSideDataType)
    ccall((:av_frame_side_data_name, libavutil), Cstring, (AVFrameSideDataType,), type)
end

"""
ffhash.c This example is a simple command line application that takes one or more arguments. It demonstrates a typical use of the hashing API with allocation, initialization, updating, and finalizing.
"""
mutable struct AVHashContext end

"""
    av_hash_alloc(ctx, name)

Allocate a hash context for the algorithm specified by name.

!!! note

    The context is not initialized after a call to this function; you must call [`av_hash_init`](@ref)() to do so.

### Returns
>= 0 for success, a negative error code for failure
"""
function av_hash_alloc(ctx, name)
    ccall((:av_hash_alloc, libavutil), Cint, (Ptr{Ptr{AVHashContext}}, Cstring), ctx, name)
end

"""
    av_hash_names(i::Integer)

Get the names of available hash algorithms.

This function can be used to enumerate the algorithms.

### Parameters
* `i`:\\[in\\] Index of the hash algorithm, starting from 0 

### Returns
Pointer to a static string or `NULL` if `i` is out of range
"""
function av_hash_names(i::Integer)
    ccall((:av_hash_names, libavutil), Cstring, (Cint,), i)
end

"""
    av_hash_get_name(ctx)

Get the name of the algorithm corresponding to the given hash context.
"""
function av_hash_get_name(ctx)
    ccall((:av_hash_get_name, libavutil), Cstring, (Ptr{AVHashContext},), ctx)
end

"""
    av_hash_get_size(ctx)

Get the size of the resulting hash value in bytes.

The maximum value this function will currently return is available as macro #[`AV_HASH_MAX_SIZE`](@ref).

### Parameters
* `ctx`:\\[in\\] Hash context 

### Returns
Size of the hash value in bytes
"""
function av_hash_get_size(ctx)
    ccall((:av_hash_get_size, libavutil), Cint, (Ptr{AVHashContext},), ctx)
end

"""
    av_hash_init(ctx)

Initialize or reset a hash context.

### Parameters
* `ctx`:\\[in,out\\] Hash context
"""
function av_hash_init(ctx)
    ccall((:av_hash_init, libavutil), Cvoid, (Ptr{AVHashContext},), ctx)
end

function av_hash_update(ctx, src, len::Integer)
    ccall((:av_hash_update, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Cint), ctx, src, len)
end

"""
    av_hash_final(ctx, dst)

Finalize a hash context and compute the actual hash value.

The minimum size of `dst` buffer is given by [`av_hash_get_size`](@ref)() or #[`AV_HASH_MAX_SIZE`](@ref). The use of the latter macro is discouraged.

It is not safe to update or finalize a hash context again, if it has already been finalized.

### Parameters
* `ctx`:\\[in,out\\] Hash context 

* `dst`:\\[out\\] Where the final hash value will be stored

### See also
[`av_hash_final_bin`](@ref)() provides an alternative API
"""
function av_hash_final(ctx, dst)
    ccall((:av_hash_final, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}), ctx, dst)
end

"""
    av_hash_final_bin(ctx, dst, size::Integer)

Finalize a hash context and store the actual hash value in a buffer.

It is not safe to update or finalize a hash context again, if it has already been finalized.

If `size` is smaller than the hash size (given by [`av_hash_get_size`](@ref)()), the hash is truncated; if size is larger, the buffer is padded with 0.

### Parameters
* `ctx`:\\[in,out\\] Hash context 

* `dst`:\\[out\\] Where the final hash value will be stored 

* `size`:\\[in\\] Number of bytes to write to `dst`
"""
function av_hash_final_bin(ctx, dst, size::Integer)
    ccall((:av_hash_final_bin, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Cint), ctx, dst, size)
end

"""
    av_hash_final_hex(ctx, dst, size::Integer)

Finalize a hash context and store the hexadecimal representation of the actual hash value as a string.

It is not safe to update or finalize a hash context again, if it has already been finalized.

The string is always 0-terminated.

If `size` is smaller than `2 * hash\\_size + 1`, where `hash_size` is the value returned by [`av_hash_get_size`](@ref)(), the string will be truncated.

### Parameters
* `ctx`:\\[in,out\\] Hash context 

* `dst`:\\[out\\] Where the string will be stored 

* `size`:\\[in\\] Maximum number of bytes to write to `dst`
"""
function av_hash_final_hex(ctx, dst, size::Integer)
    ccall((:av_hash_final_hex, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Cint), ctx, dst, size)
end

"""
    av_hash_final_b64(ctx, dst, size::Integer)

Finalize a hash context and store the Base64 representation of the actual hash value as a string.

It is not safe to update or finalize a hash context again, if it has already been finalized.

The string is always 0-terminated.

If `size` is smaller than [`AV_BASE64_SIZE`](@ref)(hash\\_size), where `hash_size` is the value returned by [`av_hash_get_size`](@ref)(), the string will be truncated.

### Parameters
* `ctx`:\\[in,out\\] Hash context 

* `dst`:\\[out\\] Where the final hash value will be stored 

* `size`:\\[in\\] Maximum number of bytes to write to `dst`
"""
function av_hash_final_b64(ctx, dst, size::Integer)
    ccall((:av_hash_final_b64, libavutil), Cvoid, (Ptr{AVHashContext}, Ptr{UInt8}, Cint), ctx, dst, size)
end

"""
    av_hash_freep(ctx)

Free hash context and set hash context pointer to `NULL`.

### Parameters
* `ctx`:\\[in,out\\] Pointer to hash context
"""
function av_hash_freep(ctx)
    ccall((:av_hash_freep, libavutil), Cvoid, (Ptr{Ptr{AVHashContext}},), ctx)
end

"""
    AVHDRPlusOverlapProcessOption

Option for overlapping elliptical pixel selectors in an image.
"""
const AVHDRPlusOverlapProcessOption = UInt32
const AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING = 0 % UInt32
const AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING = 1 % UInt32

"""
    AVHDRPlusPercentile

Represents the percentile at a specific percentage in a distribution.
"""
struct AVHDRPlusPercentile
    percentage::UInt8
    percentile::AVRational
end

"""
    AVHDRPlusColorTransformParams

Color transform parameters at a processing window in a dynamic metadata for SMPTE 2094-40.
"""
struct AVHDRPlusColorTransformParams
    window_upper_left_corner_x::AVRational
    window_upper_left_corner_y::AVRational
    window_lower_right_corner_x::AVRational
    window_lower_right_corner_y::AVRational
    center_of_ellipse_x::UInt16
    center_of_ellipse_y::UInt16
    rotation_angle::UInt8
    semimajor_axis_internal_ellipse::UInt16
    semimajor_axis_external_ellipse::UInt16
    semiminor_axis_external_ellipse::UInt16
    overlap_process_option::AVHDRPlusOverlapProcessOption
    maxscl::NTuple{3, AVRational}
    average_maxrgb::AVRational
    num_distribution_maxrgb_percentiles::UInt8
    distribution_maxrgb::NTuple{15, AVHDRPlusPercentile}
    fraction_bright_pixels::AVRational
    tone_mapping_flag::UInt8
    knee_point_x::AVRational
    knee_point_y::AVRational
    num_bezier_curve_anchors::UInt8
    bezier_curve_anchors::NTuple{15, AVRational}
    color_saturation_mapping_flag::UInt8
    color_saturation_weight::AVRational
end

"""
    AVDynamicHDRPlus

This struct represents dynamic metadata for color volume transform - application 4 of SMPTE 2094-40:2016 standard.

To be used as payload of a [`AVFrameSideData`](@ref) or [`AVPacketSideData`](@ref) with the appropriate type.

!!! note

    The struct should be allocated with [`av_dynamic_hdr_plus_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVDynamicHDRPlus
    itu_t_t35_country_code::UInt8
    application_version::UInt8
    num_windows::UInt8
    params::NTuple{3, AVHDRPlusColorTransformParams}
    targeted_system_display_maximum_luminance::AVRational
    targeted_system_display_actual_peak_luminance_flag::UInt8
    num_rows_targeted_system_display_actual_peak_luminance::UInt8
    num_cols_targeted_system_display_actual_peak_luminance::UInt8
    targeted_system_display_actual_peak_luminance::NTuple{25, NTuple{25, AVRational}}
    mastering_display_actual_peak_luminance_flag::UInt8
    num_rows_mastering_display_actual_peak_luminance::UInt8
    num_cols_mastering_display_actual_peak_luminance::UInt8
    mastering_display_actual_peak_luminance::NTuple{25, NTuple{25, AVRational}}
end

"""
    av_dynamic_hdr_plus_alloc(size)

Allocate an [`AVDynamicHDRPlus`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)().

### Returns
An [`AVDynamicHDRPlus`](@ref) filled with default values or NULL on failure.
"""
function av_dynamic_hdr_plus_alloc(size)
    ccall((:av_dynamic_hdr_plus_alloc, libavutil), Ptr{AVDynamicHDRPlus}, (Ptr{Csize_t},), size)
end

"""
    av_dynamic_hdr_plus_create_side_data(frame)

Allocate a complete [`AVDynamicHDRPlus`](@ref) and add it to the frame. 

### Parameters
* `frame`: The frame which side data is added to.

### Returns
The [`AVDynamicHDRPlus`](@ref) structure to be filled by caller or NULL on failure.
"""
function av_dynamic_hdr_plus_create_side_data(frame)
    ccall((:av_dynamic_hdr_plus_create_side_data, libavutil), Ptr{AVDynamicHDRPlus}, (Ptr{AVFrame},), frame)
end

"""
    AVHMACType

` lavu_hmac HMAC`

` lavu_crypto`

@{
"""
const AVHMACType = UInt32
const AV_HMAC_MD5 = 0 % UInt32
const AV_HMAC_SHA1 = 1 % UInt32
const AV_HMAC_SHA224 = 2 % UInt32
const AV_HMAC_SHA256 = 3 % UInt32
const AV_HMAC_SHA384 = 4 % UInt32
const AV_HMAC_SHA512 = 5 % UInt32

mutable struct AVHMAC end

"""
    av_hmac_alloc(type::AVHMACType)

Allocate an [`AVHMAC`](@ref) context. 

### Parameters
* `type`: The hash function used for the HMAC.
"""
function av_hmac_alloc(type::AVHMACType)
    ccall((:av_hmac_alloc, libavutil), Ptr{AVHMAC}, (AVHMACType,), type)
end

"""
    av_hmac_free(ctx)

Free an [`AVHMAC`](@ref) context. 

### Parameters
* `ctx`: The context to free, may be NULL
"""
function av_hmac_free(ctx)
    ccall((:av_hmac_free, libavutil), Cvoid, (Ptr{AVHMAC},), ctx)
end

"""
    av_hmac_init(ctx, key, keylen::Integer)

Initialize an [`AVHMAC`](@ref) context with an authentication key. 

### Parameters
* `ctx`: The HMAC context 

* `key`: The authentication key 

* `keylen`: The length of the key, in bytes
"""
function av_hmac_init(ctx, key, keylen::Integer)
    ccall((:av_hmac_init, libavutil), Cvoid, (Ptr{AVHMAC}, Ptr{UInt8}, Cuint), ctx, key, keylen)
end

"""
    av_hmac_update(ctx, data, len::Integer)

Hash data with the HMAC. 

### Parameters
* `ctx`: The HMAC context 

* `data`: The data to hash 

* `len`: The length of the data, in bytes
"""
function av_hmac_update(ctx, data, len::Integer)
    ccall((:av_hmac_update, libavutil), Cvoid, (Ptr{AVHMAC}, Ptr{UInt8}, Cuint), ctx, data, len)
end

"""
    av_hmac_final(ctx, out, outlen::Integer)

Finish hashing and output the HMAC digest. 

### Parameters
* `ctx`: The HMAC context 

* `out`: The output buffer to write the digest into 

* `outlen`: The length of the out buffer, in bytes 

### Returns
The number of bytes written to out, or a negative error code.
"""
function av_hmac_final(ctx, out, outlen::Integer)
    ccall((:av_hmac_final, libavutil), Cint, (Ptr{AVHMAC}, Ptr{UInt8}, Cuint), ctx, out, outlen)
end

"""
    av_hmac_calc(ctx, data, len::Integer, key, keylen::Integer, out, outlen::Integer)

Hash an array of data with a key. 

### Parameters
* `ctx`: The HMAC context 

* `data`: The data to hash 

* `len`: The length of the data, in bytes 

* `key`: The authentication key 

* `keylen`: The length of the key, in bytes 

* `out`: The output buffer to write the digest into 

* `outlen`: The length of the out buffer, in bytes 

### Returns
The number of bytes written to out, or a negative error code.
"""
function av_hmac_calc(ctx, data, len::Integer, key, keylen::Integer, out, outlen::Integer)
    ccall((:av_hmac_calc, libavutil), Cint, (Ptr{AVHMAC}, Ptr{UInt8}, Cuint, Ptr{UInt8}, Cuint, Ptr{UInt8}, Cuint), ctx, data, len, key, keylen, out, outlen)
end

mutable struct AVHWDeviceInternal end

"""
    AVHWDeviceContext

This struct aggregates all the (hardware/vendor-specific) "high-level" state, i.e. state that is not tied to a concrete processing configuration. E.g., in an API that supports hardware-accelerated encoding and decoding, this struct will (if possible) wrap the state that is common to both encoding and decoding and from which specific instances of encoders or decoders can be derived.

This struct is reference-counted with the [`AVBuffer`](@ref) mechanism. The [`av_hwdevice_ctx_alloc`](@ref)() constructor yields a reference, whose data field points to the actual [`AVHWDeviceContext`](@ref). Further objects derived from [`AVHWDeviceContext`](@ref) (such as [`AVHWFramesContext`](@ref), describing a frame pool with specific properties) will hold an internal reference to it. After all the references are released, the [`AVHWDeviceContext`](@ref) itself will be freed, optionally invoking a user-specified callback for uninitializing the hardware state.
"""
struct AVHWDeviceContext
    av_class::Ptr{AVClass}
    internal::Ptr{AVHWDeviceInternal}
    type::AVHWDeviceType
    hwctx::Ptr{Cvoid}
    free::Ptr{Cvoid}
    user_opaque::Ptr{Cvoid}
end

mutable struct AVHWFramesInternal end

"""
    AVHWFramesContext

This struct describes a set or pool of "hardware" frames (i.e. those with data not located in normal system memory). All the frames in the pool are assumed to be allocated in the same way and interchangeable.

This struct is reference-counted with the [`AVBuffer`](@ref) mechanism and tied to a given [`AVHWDeviceContext`](@ref) instance. The [`av_hwframe_ctx_alloc`](@ref)() constructor yields a reference, whose data field points to the actual [`AVHWFramesContext`](@ref) struct.
"""
struct AVHWFramesContext
    av_class::Ptr{AVClass}
    internal::Ptr{AVHWFramesInternal}
    device_ref::Ptr{AVBufferRef}
    device_ctx::Ptr{AVHWDeviceContext}
    hwctx::Ptr{Cvoid}
    free::Ptr{Cvoid}
    user_opaque::Ptr{Cvoid}
    pool::Ptr{AVBufferPool}
    initial_pool_size::Cint
    format::AVPixelFormat
    sw_format::AVPixelFormat
    width::Cint
    height::Cint
end

"""
    av_hwdevice_find_type_by_name(name)

Look up an [`AVHWDeviceType`](@ref) by name.

### Parameters
* `name`: String name of the device type (case-insensitive). 

### Returns
The type from enum [`AVHWDeviceType`](@ref), or AV\\_HWDEVICE\\_TYPE\\_NONE if not found.
"""
function av_hwdevice_find_type_by_name(name)
    ccall((:av_hwdevice_find_type_by_name, libavutil), AVHWDeviceType, (Cstring,), name)
end

"""
    av_hwdevice_get_type_name(type::AVHWDeviceType)

Get the string name of an [`AVHWDeviceType`](@ref).

### Parameters
* `type`: Type from enum [`AVHWDeviceType`](@ref). 

### Returns
Pointer to a static string containing the name, or NULL if the type is not valid.
"""
function av_hwdevice_get_type_name(type::AVHWDeviceType)
    ccall((:av_hwdevice_get_type_name, libavutil), Cstring, (AVHWDeviceType,), type)
end

"""
    av_hwdevice_iterate_types(prev::AVHWDeviceType)

Iterate over supported device types.

### Parameters
* `type`: AV\\_HWDEVICE\\_TYPE\\_NONE initially, then the previous type returned by this function in subsequent iterations. 

### Returns
The next usable device type from enum [`AVHWDeviceType`](@ref), or AV\\_HWDEVICE\\_TYPE\\_NONE if there are no more.
"""
function av_hwdevice_iterate_types(prev::AVHWDeviceType)
    ccall((:av_hwdevice_iterate_types, libavutil), AVHWDeviceType, (AVHWDeviceType,), prev)
end

"""
    av_hwdevice_ctx_alloc(type::AVHWDeviceType)

Allocate an [`AVHWDeviceContext`](@ref) for a given hardware type.

### Parameters
* `type`: the type of the hardware device to allocate. 

### Returns
a reference to the newly created [`AVHWDeviceContext`](@ref) on success or NULL on failure.
"""
function av_hwdevice_ctx_alloc(type::AVHWDeviceType)
    ccall((:av_hwdevice_ctx_alloc, libavutil), Ptr{AVBufferRef}, (AVHWDeviceType,), type)
end

"""
    av_hwdevice_ctx_init(ref)

Finalize the device context before use. This function must be called after the context is filled with all the required information and before it is used in any way.

### Parameters
* `ref`: a reference to the [`AVHWDeviceContext`](@ref) 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_hwdevice_ctx_init(ref)
    ccall((:av_hwdevice_ctx_init, libavutil), Cint, (Ptr{AVBufferRef},), ref)
end

"""
    av_hwdevice_ctx_create(device_ctx, type::AVHWDeviceType, device, opts, flags::Integer)

Open a device of the specified type and create an [`AVHWDeviceContext`](@ref) for it.

This is a convenience function intended to cover the simple cases. Callers who need to fine-tune device creation/management should open the device manually and then wrap it in an [`AVHWDeviceContext`](@ref) using [`av_hwdevice_ctx_alloc`](@ref)()/[`av_hwdevice_ctx_init`](@ref)().

The returned context is already initialized and ready for use, the caller should not call [`av_hwdevice_ctx_init`](@ref)() on it. The user\\_opaque/free fields of the created [`AVHWDeviceContext`](@ref) are set by this function and should not be touched by the caller.

### Parameters
* `device_ctx`: On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released with [`av_buffer_unref`](@ref)() when no longer needed. On failure, NULL will be written to this pointer. 

* `type`: The type of the device to create. 

* `device`: A type-specific string identifying the device to open. 

* `opts`: A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller. 

* `flags`: currently unused

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_hwdevice_ctx_create(device_ctx, type::AVHWDeviceType, device, opts, flags::Integer)
    ccall((:av_hwdevice_ctx_create, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, AVHWDeviceType, Cstring, Ptr{AVDictionary}, Cint), device_ctx, type, device, opts, flags)
end

"""
    av_hwdevice_ctx_create_derived(dst_ctx, type::AVHWDeviceType, src_ctx, flags::Integer)

Create a new device of the specified type from an existing device.

If the source device is a device of the target type or was originally derived from such a device (possibly through one or more intermediate devices of other types), then this will return a reference to the existing device of the same type as is requested.

Otherwise, it will attempt to derive a new device from the given source device. If direct derivation to the new type is not implemented, it will attempt the same derivation from each ancestor of the source device in turn looking for an implemented derivation method.

### Parameters
* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref). 

* `type`: The type of the new device to create. 

* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device. 

* `flags`: Currently unused; should be set to zero. 

### Returns
Zero on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_hwdevice_ctx_create_derived(dst_ctx, type::AVHWDeviceType, src_ctx, flags::Integer)
    ccall((:av_hwdevice_ctx_create_derived, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, AVHWDeviceType, Ptr{AVBufferRef}, Cint), dst_ctx, type, src_ctx, flags)
end

"""
    av_hwdevice_ctx_create_derived_opts(dst_ctx, type::AVHWDeviceType, src_ctx, options, flags::Integer)

Create a new device of the specified type from an existing device.

This function performs the same action as [`av_hwdevice_ctx_create_derived`](@ref), however, it is able to set options for the new device to be derived.

### Parameters
* `dst_ctx`: On success, a reference to the newly-created [`AVHWDeviceContext`](@ref). 

* `type`: The type of the new device to create. 

* `src_ctx`: A reference to an existing [`AVHWDeviceContext`](@ref) which will be used to create the new device. 

* `options`: Options for the new device to create, same format as in [`av_hwdevice_ctx_create`](@ref). 

* `flags`: Currently unused; should be set to zero. 

### Returns
Zero on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_hwdevice_ctx_create_derived_opts(dst_ctx, type::AVHWDeviceType, src_ctx, options, flags::Integer)
    ccall((:av_hwdevice_ctx_create_derived_opts, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, AVHWDeviceType, Ptr{AVBufferRef}, Ptr{AVDictionary}, Cint), dst_ctx, type, src_ctx, options, flags)
end

"""
    av_hwframe_ctx_alloc(device_ctx)

Allocate an [`AVHWFramesContext`](@ref) tied to a given device context.

### Parameters
* `device_ctx`: a reference to a [`AVHWDeviceContext`](@ref). This function will make a new reference for internal use, the one passed to the function remains owned by the caller. 

### Returns
a reference to the newly created [`AVHWFramesContext`](@ref) on success or NULL on failure.
"""
function av_hwframe_ctx_alloc(device_ctx)
    ccall((:av_hwframe_ctx_alloc, libavutil), Ptr{AVBufferRef}, (Ptr{AVBufferRef},), device_ctx)
end

"""
    av_hwframe_ctx_init(ref)

Finalize the context before use. This function must be called after the context is filled with all the required information and before it is attached to any frames.

### Parameters
* `ref`: a reference to the [`AVHWFramesContext`](@ref) 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_hwframe_ctx_init(ref)
    ccall((:av_hwframe_ctx_init, libavutil), Cint, (Ptr{AVBufferRef},), ref)
end

"""
    av_hwframe_get_buffer(hwframe_ctx, frame, flags::Integer)

Allocate a new frame attached to the given [`AVHWFramesContext`](@ref).

### Parameters
* `hwframe_ctx`: a reference to an [`AVHWFramesContext`](@ref) 

* `frame`: an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers. 

* `flags`: currently unused, should be set to zero 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure
"""
function av_hwframe_get_buffer(hwframe_ctx, frame, flags::Integer)
    ccall((:av_hwframe_get_buffer, libavutil), Cint, (Ptr{AVBufferRef}, Ptr{AVFrame}, Cint), hwframe_ctx, frame, flags)
end

"""
    av_hwframe_transfer_data(dst, src, flags::Integer)

Copy data to or from a hw surface. At least one of dst/src must have an [`AVHWFramesContext`](@ref) attached.

If src has an [`AVHWFramesContext`](@ref) attached, then the format of dst (if set) must use one of the formats returned by [`av_hwframe_transfer_get_formats`](@ref)(src, AV\\_HWFRAME\\_TRANSFER\\_DIRECTION\\_FROM). If dst has an [`AVHWFramesContext`](@ref) attached, then the format of src must use one of the formats returned by [`av_hwframe_transfer_get_formats`](@ref)(dst, AV\\_HWFRAME\\_TRANSFER\\_DIRECTION\\_TO)

dst may be "clean" (i.e. with data/buf pointers unset), in which case the data buffers will be allocated by this function using [`av_frame_get_buffer`](@ref)(). If dst->format is set, then this format will be used, otherwise (when dst->format is AV\\_PIX\\_FMT\\_NONE) the first acceptable format will be chosen.

The two frames must have matching allocated dimensions (i.e. equal to [`AVHWFramesContext`](@ref).width/height), since not all device types support transferring a sub-rectangle of the whole surface. The display dimensions (i.e. [`AVFrame`](@ref).width/height) may be smaller than the allocated dimensions, but also have to be equal for both frames. When the display dimensions are smaller than the allocated dimensions, the content of the padding in the destination frame is unspecified.

### Parameters
* `dst`: the destination frame. dst is not touched on failure. 

* `src`: the source frame. 

* `flags`: currently unused, should be set to zero 

### Returns
0 on success, a negative [`AVERROR`](@ref) error code on failure.
"""
function av_hwframe_transfer_data(dst, src, flags::Integer)
    ccall((:av_hwframe_transfer_data, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}, Cint), dst, src, flags)
end

const AVHWFrameTransferDirection = UInt32
const AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0 % UInt32
const AV_HWFRAME_TRANSFER_DIRECTION_TO = 1 % UInt32

"""
    av_hwframe_transfer_get_formats(hwframe_ctx, dir::AVHWFrameTransferDirection, formats, flags::Integer)

Get a list of possible source or target formats usable in [`av_hwframe_transfer_data`](@ref)().

### Parameters
* `hwframe_ctx`: the frame context to obtain the information for 

* `dir`: the direction of the transfer 

* `formats`: the pointer to the output format list will be written here. The list is terminated with AV\\_PIX\\_FMT\\_NONE and must be freed by the caller when no longer needed using [`av_free`](@ref)(). If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified. 

* `flags`: currently unused, should be set to zero 

### Returns
0 on success, a negative [`AVERROR`](@ref) code on failure.
"""
function av_hwframe_transfer_get_formats(hwframe_ctx, dir::AVHWFrameTransferDirection, formats, flags::Integer)
    ccall((:av_hwframe_transfer_get_formats, libavutil), Cint, (Ptr{AVBufferRef}, AVHWFrameTransferDirection, Ptr{Ptr{AVPixelFormat}}, Cint), hwframe_ctx, dir, formats, flags)
end

"""
    AVHWFramesConstraints

This struct describes the constraints on hardware frames attached to a given device with a hardware-specific configuration. This is returned by [`av_hwdevice_get_hwframe_constraints`](@ref)() and must be freed by [`av_hwframe_constraints_free`](@ref)() after use.
"""
struct AVHWFramesConstraints
    valid_hw_formats::Ptr{AVPixelFormat}
    valid_sw_formats::Ptr{AVPixelFormat}
    min_width::Cint
    min_height::Cint
    max_width::Cint
    max_height::Cint
end

"""
    av_hwdevice_hwconfig_alloc(device_ctx)

Allocate a HW-specific configuration structure for a given HW device. After use, the user must free all members as required by the specific hardware structure being used, then free the structure itself with [`av_free`](@ref)().

### Parameters
* `device_ctx`: a reference to the associated [`AVHWDeviceContext`](@ref). 

### Returns
The newly created HW-specific configuration structure on success or NULL on failure.
"""
function av_hwdevice_hwconfig_alloc(device_ctx)
    ccall((:av_hwdevice_hwconfig_alloc, libavutil), Ptr{Cvoid}, (Ptr{AVBufferRef},), device_ctx)
end

"""
    av_hwdevice_get_hwframe_constraints(ref, hwconfig)

Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device. If no HW-specific configuration is provided, returns the maximum possible capabilities of the device.

### Parameters
* `ref`: a reference to the associated [`AVHWDeviceContext`](@ref). 

* `hwconfig`: a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device. 

### Returns
[`AVHWFramesConstraints`](@ref) structure describing the constraints on the device, or NULL if not available.
"""
function av_hwdevice_get_hwframe_constraints(ref, hwconfig)
    ccall((:av_hwdevice_get_hwframe_constraints, libavutil), Ptr{AVHWFramesConstraints}, (Ptr{AVBufferRef}, Ptr{Cvoid}), ref, hwconfig)
end

"""
    av_hwframe_constraints_free(constraints)

Free an AVHWFrameConstraints structure.

### Parameters
* `constraints`: The (filled or unfilled) AVHWFrameConstraints structure.
"""
function av_hwframe_constraints_free(constraints)
    ccall((:av_hwframe_constraints_free, libavutil), Cvoid, (Ptr{Ptr{AVHWFramesConstraints}},), constraints)
end

"""
    __JL_Ctag_779

Flags to apply to frame mappings.
"""
const __JL_Ctag_779 = UInt32
const AV_HWFRAME_MAP_READ = 1 % UInt32
const AV_HWFRAME_MAP_WRITE = 2 % UInt32
const AV_HWFRAME_MAP_OVERWRITE = 4 % UInt32
const AV_HWFRAME_MAP_DIRECT = 8 % UInt32

"""
    av_hwframe_map(dst, src, flags::Integer)

Map a hardware frame.

This has a number of different possible effects, depending on the format and origin of the src and dst frames. On input, src should be a usable frame with valid buffers and dst should be blank (typically as just created by [`av_frame_alloc`](@ref)()). src should have an associated hwframe context, and dst may optionally have a format and associated hwframe context.

If src was created by mapping a frame from the hwframe context of dst, then this function undoes the mapping - dst is replaced by a reference to the frame that src was originally mapped from.

If both src and dst have an associated hwframe context, then this function attempts to map the src frame from its hardware context to that of dst and then fill dst with appropriate data to be usable there. This will only be possible if the hwframe contexts and associated devices are compatible - given compatible devices, [`av_hwframe_ctx_create_derived`](@ref)() can be used to create a hwframe context for dst in which mapping should be possible.

If src has a hwframe context but dst does not, then the src frame is mapped to normal memory and should thereafter be usable as a normal frame. If the format is set on dst, then the mapping will attempt to create dst with that format and fail if it is not possible. If format is unset (is AV\\_PIX\\_FMT\\_NONE) then dst will be mapped with whatever the most appropriate format to use is (probably the sw\\_format of the src hwframe context).

A return value of [`AVERROR`](@ref)(ENOSYS) indicates that the mapping is not possible with the given arguments and hwframe setup, while other return values indicate that it failed somehow.

### Parameters
* `dst`: Destination frame, to contain the mapping. 

* `src`: Source frame, to be mapped. 

* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags. 

### Returns
Zero on success, negative [`AVERROR`](@ref) code on failure.
"""
function av_hwframe_map(dst, src, flags::Integer)
    ccall((:av_hwframe_map, libavutil), Cint, (Ptr{AVFrame}, Ptr{AVFrame}, Cint), dst, src, flags)
end

"""
    av_hwframe_ctx_create_derived(derived_frame_ctx, format::AVPixelFormat, derived_device_ctx, source_frame_ctx, flags::Integer)

Create and initialise an [`AVHWFramesContext`](@ref) as a mapping of another existing [`AVHWFramesContext`](@ref) on a different device.

[`av_hwframe_ctx_init`](@ref)() should not be called after this.

### Parameters
* `derived_frame_ctx`: On success, a reference to the newly created [`AVHWFramesContext`](@ref). 

* `derived_device_ctx`: A reference to the device to create the new [`AVHWFramesContext`](@ref) on. 

* `source_frame_ctx`: A reference to an existing [`AVHWFramesContext`](@ref) which will be mapped to the derived context. 

* `flags`: Some combination of AV\\_HWFRAME\\_MAP\\_* flags, defining the mapping parameters to apply to frames which are allocated in the derived device. 

### Returns
Zero on success, negative [`AVERROR`](@ref) code on failure.
"""
function av_hwframe_ctx_create_derived(derived_frame_ctx, format::AVPixelFormat, derived_device_ctx, source_frame_ctx, flags::Integer)
    ccall((:av_hwframe_ctx_create_derived, libavutil), Cint, (Ptr{Ptr{AVBufferRef}}, AVPixelFormat, Ptr{AVBufferRef}, Ptr{AVBufferRef}, Cint), derived_frame_ctx, format, derived_device_ctx, source_frame_ctx, flags)
end

mutable struct AVCUDADeviceContextInternal end

struct AVCUDADeviceContext
    cuda_ctx::Cint
    stream::Cint
    internal::Ptr{AVCUDADeviceContextInternal}
end

struct AVD3D11VADeviceContext
    device::Ptr{Cint}
    device_context::Ptr{Cint}
    video_device::Ptr{Cint}
    video_context::Ptr{Cint}
    lock::Ptr{Cvoid}
    unlock::Ptr{Cvoid}
    lock_ctx::Ptr{Cvoid}
end

struct AVD3D11FrameDescriptor
    texture::Ptr{Cint}
    index::intptr_t
end

struct AVD3D11VAFramesContext
    texture::Ptr{Cint}
    BindFlags::Cint
    MiscFlags::Cint
end

"""
    __JL_Ctag_781

API-specific header for AV\\_HWDEVICE\\_TYPE\\_DRM.

Internal frame allocation is not currently supported - all frames must be allocated by the user. Thus [`AVHWFramesContext`](@ref) is always NULL, though this may change if support for frame allocation is added in future.
"""
const __JL_Ctag_781 = UInt32
const AV_DRM_MAX_PLANES = 4 % UInt32

"""
    AVDRMObjectDescriptor

DRM object descriptor.

Describes a single DRM object, addressing it as a PRIME file descriptor.
"""
struct AVDRMObjectDescriptor
    fd::Cint
    size::Csize_t
    format_modifier::UInt64
end

"""
    AVDRMPlaneDescriptor

DRM plane descriptor.

Describes a single plane of a layer, which is contained within a single object.
"""
struct AVDRMPlaneDescriptor
    object_index::Cint
    offset::Cptrdiff_t
    pitch::Cptrdiff_t
end

"""
    AVDRMLayerDescriptor

DRM layer descriptor.

Describes a single layer within a frame. This has the structure defined by its format, and will contain one or more planes.
"""
struct AVDRMLayerDescriptor
    format::UInt32
    nb_planes::Cint
    planes::NTuple{4, AVDRMPlaneDescriptor}
end

"""
    AVDRMFrameDescriptor

DRM frame descriptor.

This is used as the data pointer for AV\\_PIX\\_FMT\\_DRM\\_PRIME frames. It is also used by user-allocated frame pools - allocating in [`AVHWFramesContext`](@ref).pool must return AVBufferRefs which contain an object of this type.

The fields of this structure should be set such it can be imported directly by EGL using the EGL\\_EXT\\_image\\_dma\\_buf\\_import and EGL\\_EXT\\_image\\_dma\\_buf\\_import\\_modifiers extensions. (Note that the exact layout of a particular format may vary between platforms - we only specify that the same platform should be able to import it.)

The total number of planes must not exceed AV\\_DRM\\_MAX\\_PLANES, and the order of the planes by increasing layer index followed by increasing plane index must be the same as the order which would be used for the data pointers in the equivalent software format.
"""
struct AVDRMFrameDescriptor
    nb_objects::Cint
    objects::NTuple{4, AVDRMObjectDescriptor}
    nb_layers::Cint
    layers::NTuple{4, AVDRMLayerDescriptor}
end

"""
    AVDRMDeviceContext

DRM device.

Allocated as [`AVHWDeviceContext`](@ref).hwctx.
"""
struct AVDRMDeviceContext
    fd::Cint
end

struct AVDXVA2DeviceContext
    devmgr::Ptr{Cint}
end

struct AVDXVA2FramesContext
    surface_type::Cint
    surfaces::Ptr{Ptr{Cint}}
    nb_surfaces::Cint
    decoder_to_release::Ptr{Cint}
end

"""
    AVMediaCodecDeviceContext

MediaCodec details.

Allocated as [`AVHWDeviceContext`](@ref).hwctx
"""
struct AVMediaCodecDeviceContext
    surface::Ptr{Cvoid}
end

struct AVOpenCLFrameDescriptor
    nb_planes::Cint
    planes::NTuple{8, Cint}
end

struct AVOpenCLDeviceContext
    device_id::Cint
    context::Cint
    command_queue::Cint
end

struct AVOpenCLFramesContext
    command_queue::Cint
end

struct AVQSVDeviceContext
    session::Cint
end

struct AVQSVFramesContext
    surfaces::Ptr{Cint}
    nb_surfaces::Cint
    frame_type::Cint
end

"""
    __JL_Ctag_805

API-specific header for AV\\_HWDEVICE\\_TYPE\\_VAAPI.

Dynamic frame pools are supported, but note that any pool used as a render target is required to be of fixed size in order to be be usable as an argument to vaCreateContext().

For user-allocated pools, [`AVHWFramesContext`](@ref).pool must return AVBufferRefs with the data pointer set to a VASurfaceID.
"""
const __JL_Ctag_805 = UInt32
const AV_VAAPI_DRIVER_QUIRK_USER_SET = 1 % UInt32
const AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS = 2 % UInt32
const AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE = 4 % UInt32
const AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES = 8 % UInt32

struct AVVAAPIDeviceContext
    display::Cint
    driver_quirks::Cuint
end

struct AVVAAPIFramesContext
    attributes::Ptr{Cint}
    nb_attributes::Cint
    surface_ids::Ptr{Cint}
    nb_surfaces::Cint
end

struct AVVAAPIHWConfig
    config_id::Cint
end

"""
    AVVDPAUDeviceContext

This struct is allocated as [`AVHWDeviceContext`](@ref).hwctx
"""
struct AVVDPAUDeviceContext
    device::VdpDevice
    get_proc_address::Ptr{Cvoid}
end

"""
    av_map_videotoolbox_format_to_pixfmt(cv_fmt::Integer)

Convert a VideoToolbox (actually CoreVideo) format to [`AVPixelFormat`](@ref). Returns AV\\_PIX\\_FMT\\_NONE if no known equivalent was found.
"""
function av_map_videotoolbox_format_to_pixfmt(cv_fmt::Integer)
    ccall((:av_map_videotoolbox_format_to_pixfmt, libavutil), AVPixelFormat, (UInt32,), cv_fmt)
end

"""
    av_map_videotoolbox_format_from_pixfmt(pix_fmt::AVPixelFormat)

Convert an [`AVPixelFormat`](@ref) to a VideoToolbox (actually CoreVideo) format. Returns 0 if no known equivalent was found.
"""
function av_map_videotoolbox_format_from_pixfmt(pix_fmt::AVPixelFormat)
    ccall((:av_map_videotoolbox_format_from_pixfmt, libavutil), UInt32, (AVPixelFormat,), pix_fmt)
end

function av_map_videotoolbox_format_from_pixfmt2(pix_fmt::AVPixelFormat, full_range::Integer)
    ccall((:av_map_videotoolbox_format_from_pixfmt2, libavutil), UInt32, (AVPixelFormat, Cint), pix_fmt, full_range)
end

"""
    AVVulkanDeviceContext

Main Vulkan context, allocated as [`AVHWDeviceContext`](@ref).hwctx. All of these can be set before init to change what the context uses
"""
struct AVVulkanDeviceContext
    alloc::Ptr{VkAllocationCallbacks}
    inst::VkInstance
    phys_dev::VkPhysicalDevice
    act_dev::VkDevice
    queue_family_index::Cint
    nb_graphics_queues::Cint
    queue_family_tx_index::Cint
    nb_tx_queues::Cint
    queue_family_comp_index::Cint
    nb_comp_queues::Cint
    enabled_inst_extensions::Ptr{Cstring}
    nb_enabled_inst_extensions::Cint
    enabled_dev_extensions::Ptr{Cstring}
    nb_enabled_dev_extensions::Cint
    device_features::VkPhysicalDeviceFeatures2
end

"""
    AVVulkanFramesContext

Allocated as [`AVHWFramesContext`](@ref).hwctx, used to set pool-specific options
"""
struct AVVulkanFramesContext
    tiling::VkImageTiling
    usage::VkImageUsageFlagBits
    create_pnext::Ptr{Cvoid}
    alloc_pnext::NTuple{8, Ptr{Cvoid}}
end

mutable struct AVVkFrameInternal end

struct AVVkFrame
    img::NTuple{8, VkImage}
    tiling::VkImageTiling
    mem::NTuple{8, VkDeviceMemory}
    size::NTuple{8, Csize_t}
    flags::VkMemoryPropertyFlagBits
    access::NTuple{8, VkAccessFlagBits}
    layout::NTuple{8, VkImageLayout}
    sem::NTuple{8, VkSemaphore}
    internal::Ptr{AVVkFrameInternal}
end

"""
    av_vk_frame_alloc()

Allocates a single [`AVVkFrame`](@ref) and initializes everything as 0. 

!!! note

    Must be freed via [`av_free`](@ref)()
"""
function av_vk_frame_alloc()
    ccall((:av_vk_frame_alloc, libavutil), Ptr{AVVkFrame}, ())
end

"""
    av_vkfmt_from_pixfmt(p::AVPixelFormat)

Returns the format of each image up to the number of planes for a given sw\\_format. Returns NULL on unsupported formats.
"""
function av_vkfmt_from_pixfmt(p::AVPixelFormat)
    ccall((:av_vkfmt_from_pixfmt, libavutil), Ptr{VkFormat}, (AVPixelFormat,), p)
end

struct AVComponentDescriptor
    data::NTuple{32, UInt8}
end

function Base.getproperty(x::Ptr{AVComponentDescriptor}, f::Symbol)
    f === :plane && return Ptr{Cint}(x + 0)
    f === :step && return Ptr{Cint}(x + 4)
    f === :offset && return Ptr{Cint}(x + 8)
    f === :shift && return Ptr{Cint}(x + 12)
    f === :depth && return Ptr{Cint}(x + 16)
    f === :step_minus1 && return Ptr{Cint}(x + 20)
    f === :depth_minus1 && return Ptr{Cint}(x + 24)
    f === :offset_plus1 && return Ptr{Cint}(x + 28)
    return getfield(x, f)
end

function Base.getproperty(x::AVComponentDescriptor, f::Symbol)
    r = Ref{AVComponentDescriptor}(x)
    ptr = Base.unsafe_convert(Ptr{AVComponentDescriptor}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{AVComponentDescriptor}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVPixFmtDescriptor

Descriptor that unambiguously describes how the bits of a pixel are stored in the up to 4 data planes of an image. It also stores the subsampling factors and number of components.

!!! note

    This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV and all the YUV variants) [`AVPixFmtDescriptor`](@ref) just stores how values are stored not what these values represent.
"""
struct AVPixFmtDescriptor
    name::Cstring
    nb_components::UInt8
    log2_chroma_w::UInt8
    log2_chroma_h::UInt8
    flags::UInt64
    comp::NTuple{4, AVComponentDescriptor}
    alias::Cstring
end

"""
    av_image_fill_max_pixsteps(max_pixsteps, max_pixstep_comps, pixdesc)

Compute the max pixel step for each plane of an image with a format described by pixdesc.

The pixel step is the distance in bytes between the first byte of the group of bytes which describe a pixel component and the first byte of the successive group in the same plane for the same component.

### Parameters
* `max_pixsteps`: an array which is filled with the max pixel step for each plane. Since a plane may contain different pixel components, the computed max\\_pixsteps[plane] is relative to the component in the plane with the max pixel step. 

* `max_pixstep_comps`: an array which is filled with the component for each plane which has the max pixel step. May be NULL.
"""
function av_image_fill_max_pixsteps(max_pixsteps, max_pixstep_comps, pixdesc)
    ccall((:av_image_fill_max_pixsteps, libavutil), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}), max_pixsteps, max_pixstep_comps, pixdesc)
end

"""
    av_image_get_linesize(pix_fmt::AVPixelFormat, width::Integer, plane::Integer)

Compute the size of an image line with format pix\\_fmt and width width for the plane plane.

### Returns
the computed size in bytes
"""
function av_image_get_linesize(pix_fmt::AVPixelFormat, width::Integer, plane::Integer)
    ccall((:av_image_get_linesize, libavutil), Cint, (AVPixelFormat, Cint, Cint), pix_fmt, width, plane)
end

"""
    av_image_fill_linesizes(linesizes, pix_fmt::AVPixelFormat, width::Integer)

Fill plane linesizes for an image with pixel format pix\\_fmt and width width.

### Parameters
* `linesizes`: array to be filled with the linesize for each plane 

### Returns
>= 0 in case of success, a negative error code otherwise
"""
function av_image_fill_linesizes(linesizes, pix_fmt::AVPixelFormat, width::Integer)
    ccall((:av_image_fill_linesizes, libavutil), Cint, (Ptr{Cint}, AVPixelFormat, Cint), linesizes, pix_fmt, width)
end

"""
    av_image_fill_plane_sizes(size, pix_fmt::AVPixelFormat, height::Integer, linesizes)

Fill plane sizes for an image with pixel format pix\\_fmt and height height.

!!! note

    The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_fill_linesizes`](@ref)().

### Parameters
* `size`: the array to be filled with the size of each image plane 

* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)() 

### Returns
>= 0 in case of success, a negative error code otherwise
"""
function av_image_fill_plane_sizes(size, pix_fmt::AVPixelFormat, height::Integer, linesizes)
    ccall((:av_image_fill_plane_sizes, libavutil), Cint, (Ptr{Csize_t}, AVPixelFormat, Cint, Ptr{Cptrdiff_t}), size, pix_fmt, height, linesizes)
end

"""
    av_image_fill_pointers(data, pix_fmt::AVPixelFormat, height::Integer, ptr, linesizes)

Fill plane data pointers for an image with pixel format pix\\_fmt and height height.

### Parameters
* `data`: pointers array to be filled with the pointer for each image plane 

* `ptr`: the pointer to a buffer which will contain the image 

* `linesizes`: the array containing the linesize for each plane, should be filled by [`av_image_fill_linesizes`](@ref)() 

### Returns
the size in bytes required for the image buffer, a negative error code in case of failure
"""
function av_image_fill_pointers(data, pix_fmt::AVPixelFormat, height::Integer, ptr, linesizes)
    ccall((:av_image_fill_pointers, libavutil), Cint, (Ptr{Ptr{UInt8}}, AVPixelFormat, Cint, Ptr{UInt8}, Ptr{Cint}), data, pix_fmt, height, ptr, linesizes)
end

"""
    av_image_alloc(pointers, linesizes, w::Integer, h::Integer, pix_fmt::AVPixelFormat, align::Integer)

Allocate an image with size w and h and pixel format pix\\_fmt, and fill pointers and linesizes accordingly. The allocated image buffer has to be freed by using [`av_freep`](@ref)(&pointers[0]).

### Parameters
* `align`: the value to use for buffer size alignment 

### Returns
the size in bytes required for the image buffer, a negative error code in case of failure
"""
function av_image_alloc(pointers, linesizes, w::Integer, h::Integer, pix_fmt::AVPixelFormat, align::Integer)
    ccall((:av_image_alloc, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Cint, Cint, AVPixelFormat, Cint), pointers, linesizes, w, h, pix_fmt, align)
end

"""
    av_image_copy_plane(dst, dst_linesize::Integer, src, src_linesize::Integer, bytewidth::Integer, height::Integer)

Copy image plane from src to dst. That is, copy "height" number of lines of "bytewidth" bytes each. The first byte of each successive line is separated by *\\_linesize bytes.

bytewidth must be contained by both absolute values of dst\\_linesize and src\\_linesize, otherwise the function behavior is undefined.

### Parameters
* `dst_linesize`: linesize for the image plane in dst 

* `src_linesize`: linesize for the image plane in src
"""
function av_image_copy_plane(dst, dst_linesize::Integer, src, src_linesize::Integer, bytewidth::Integer, height::Integer)
    ccall((:av_image_copy_plane, libavutil), Cvoid, (Ptr{UInt8}, Cint, Ptr{UInt8}, Cint, Cint, Cint), dst, dst_linesize, src, src_linesize, bytewidth, height)
end

"""
    av_image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)

Copy image in src\\_data to dst\\_data.

### Parameters
* `dst_linesizes`: linesizes for the image in dst\\_data 

* `src_linesizes`: linesizes for the image in src\\_data
"""
function av_image_copy(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:av_image_copy, libavutil), Cvoid, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{Ptr{UInt8}}, Ptr{Cint}, AVPixelFormat, Cint, Cint), dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height)
end

"""
    av_image_copy_uc_from(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)

Copy image data located in uncacheable (e.g. GPU mapped) memory. Where available, this function will use special functionality for reading from such memory, which may result in greatly improved performance compared to plain [`av_image_copy`](@ref)().

The data pointers and the linesizes must be aligned to the maximum required by the CPU architecture.

!!! note

    The linesize parameters have the type ptrdiff\\_t here, while they are int for [`av_image_copy`](@ref)(). 

!!! note

    On x86, the linesizes currently need to be aligned to the cacheline size (i.e. 64) to get improved performance.
"""
function av_image_copy_uc_from(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt::AVPixelFormat, width::Integer, height::Integer)
    ccall((:av_image_copy_uc_from, libavutil), Cvoid, (Ptr{Ptr{UInt8}}, Ptr{Cptrdiff_t}, Ptr{Ptr{UInt8}}, Ptr{Cptrdiff_t}, AVPixelFormat, Cint, Cint), dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height)
end

"""
    av_image_fill_arrays(dst_data, dst_linesize, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)

Setup the data pointers and linesizes based on the specified image parameters and the provided array.

The fields of the given image are filled in by using the src address which points to the image data buffer. Depending on the specified pixel format, one or multiple image data pointers and line sizes will be set. If a planar format is specified, several pointers will be set pointing to the different picture planes and the line sizes of the different planes will be stored in the lines\\_sizes array. Call with src == NULL to get the required size for the src buffer.

To allocate the buffer and fill in the dst\\_data and dst\\_linesize in one call, use [`av_image_alloc`](@ref)().

### Parameters
* `dst_data`: data pointers to be filled in 

* `dst_linesize`: linesizes for the image in dst\\_data to be filled in 

* `src`: buffer which will contain or contains the actual image data, can be NULL 

* `pix_fmt`: the pixel format of the image 

* `width`: the width of the image in pixels 

* `height`: the height of the image in pixels 

* `align`: the value used in src for linesize alignment 

### Returns
the size in bytes required for src, a negative error code in case of failure
"""
function av_image_fill_arrays(dst_data, dst_linesize, src, pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)
    ccall((:av_image_fill_arrays, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, AVPixelFormat, Cint, Cint, Cint), dst_data, dst_linesize, src, pix_fmt, width, height, align)
end

"""
    av_image_get_buffer_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)

Return the size in bytes of the amount of data required to store an image with the given parameters.

### Parameters
* `pix_fmt`: the pixel format of the image 

* `width`: the width of the image in pixels 

* `height`: the height of the image in pixels 

* `align`: the assumed linesize alignment 

### Returns
the buffer size in bytes, a negative error code in case of failure
"""
function av_image_get_buffer_size(pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)
    ccall((:av_image_get_buffer_size, libavutil), Cint, (AVPixelFormat, Cint, Cint, Cint), pix_fmt, width, height, align)
end

"""
    av_image_copy_to_buffer(dst, dst_size::Integer, src_data, src_linesize, pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)

Copy image data from an image into a buffer.

[`av_image_get_buffer_size`](@ref)() can be used to compute the required size for the buffer to fill.

### Parameters
* `dst`: a buffer into which picture data will be copied 

* `dst_size`: the size in bytes of dst 

* `src_data`: pointers containing the source image data 

* `src_linesize`: linesizes for the image in src\\_data 

* `pix_fmt`: the pixel format of the source image 

* `width`: the width of the source image in pixels 

* `height`: the height of the source image in pixels 

* `align`: the assumed linesize alignment for dst 

### Returns
the number of bytes written to dst, or a negative value (error code) on error
"""
function av_image_copy_to_buffer(dst, dst_size::Integer, src_data, src_linesize, pix_fmt::AVPixelFormat, width::Integer, height::Integer, align::Integer)
    ccall((:av_image_copy_to_buffer, libavutil), Cint, (Ptr{UInt8}, Cint, Ptr{Ptr{UInt8}}, Ptr{Cint}, AVPixelFormat, Cint, Cint, Cint), dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align)
end

"""
    av_image_check_size(w::Integer, h::Integer, log_offset::Integer, log_ctx)

Check if the given dimension of an image is valid, meaning that all bytes of the image can be addressed with a signed int.

### Parameters
* `w`: the width of the picture 

* `h`: the height of the picture 

* `log_offset`: the offset to sum to the log level for logging with log\\_ctx 

* `log_ctx`: the parent logging context, it may be NULL 

### Returns
>= 0 if valid, a negative error code otherwise
"""
function av_image_check_size(w::Integer, h::Integer, log_offset::Integer, log_ctx)
    ccall((:av_image_check_size, libavutil), Cint, (Cuint, Cuint, Cint, Ptr{Cvoid}), w, h, log_offset, log_ctx)
end

"""
    av_image_check_size2(w::Integer, h::Integer, max_pixels::Int64, pix_fmt::AVPixelFormat, log_offset::Integer, log_ctx)

Check if the given dimension of an image is valid, meaning that all bytes of a plane of an image with the specified pix\\_fmt can be addressed with a signed int.

### Parameters
* `w`: the width of the picture 

* `h`: the height of the picture 

* `max_pixels`: the maximum number of pixels the user wants to accept 

* `pix_fmt`: the pixel format, can be AV\\_PIX\\_FMT\\_NONE if unknown. 

* `log_offset`: the offset to sum to the log level for logging with log\\_ctx 

* `log_ctx`: the parent logging context, it may be NULL 

### Returns
>= 0 if valid, a negative error code otherwise
"""
function av_image_check_size2(w::Integer, h::Integer, max_pixels::Int64, pix_fmt::AVPixelFormat, log_offset::Integer, log_ctx)
    ccall((:av_image_check_size2, libavutil), Cint, (Cuint, Cuint, Int64, AVPixelFormat, Cint, Ptr{Cvoid}), w, h, max_pixels, pix_fmt, log_offset, log_ctx)
end

"""
    av_image_check_sar(w::Integer, h::Integer, sar::AVRational)

Check if the given sample aspect ratio of an image is valid.

It is considered invalid if the denominator is 0 or if applying the ratio to the image size would make the smaller dimension less than 1. If the sar numerator is 0, it is considered unknown and will return as valid.

### Parameters
* `w`: width of the image 

* `h`: height of the image 

* `sar`: sample aspect ratio of the image 

### Returns
0 if valid, a negative [`AVERROR`](@ref) code otherwise
"""
function av_image_check_sar(w::Integer, h::Integer, sar::AVRational)
    ccall((:av_image_check_sar, libavutil), Cint, (Cuint, Cuint, AVRational), w, h, sar)
end

"""
    av_image_fill_black(dst_data, dst_linesize, pix_fmt::AVPixelFormat, range::AVColorRange, width::Integer, height::Integer)

Overwrite the image data with black. This is suitable for filling a sub-rectangle of an image, meaning the padding between the right most pixel and the left most pixel on the next line will not be overwritten. For some formats, the image size might be rounded up due to inherent alignment.

If the pixel format has alpha, the alpha is cleared to opaque.

This can return an error if the pixel format is not supported. Normally, all non-hwaccel pixel formats should be supported.

Passing NULL for dst\\_data is allowed. Then the function returns whether the operation would have succeeded. (It can return an error if the pix\\_fmt is not supported.)

### Parameters
* `dst_data`: data pointers to destination image 

* `dst_linesize`: linesizes for the destination image 

* `pix_fmt`: the pixel format of the image 

* `range`: the color range of the image (important for colorspaces such as YUV) 

* `width`: the width of the image in pixels 

* `height`: the height of the image in pixels 

### Returns
0 if the image data was cleared, a negative [`AVERROR`](@ref) code otherwise
"""
function av_image_fill_black(dst_data, dst_linesize, pix_fmt::AVPixelFormat, range::AVColorRange, width::Integer, height::Integer)
    ccall((:av_image_fill_black, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Cptrdiff_t}, AVPixelFormat, AVColorRange, Cint, Cint), dst_data, dst_linesize, pix_fmt, range, width, height)
end

struct av_intfloat32
    data::NTuple{4, UInt8}
end

function Base.getproperty(x::Ptr{av_intfloat32}, f::Symbol)
    f === :i && return Ptr{UInt32}(x + 0)
    f === :f && return Ptr{Cfloat}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::av_intfloat32, f::Symbol)
    r = Ref{av_intfloat32}(x)
    ptr = Base.unsafe_convert(Ptr{av_intfloat32}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{av_intfloat32}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct av_intfloat64
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{av_intfloat64}, f::Symbol)
    f === :i && return Ptr{UInt64}(x + 0)
    f === :f && return Ptr{Cdouble}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::av_intfloat64, f::Symbol)
    r = Ref{av_intfloat64}(x)
    ptr = Base.unsafe_convert(Ptr{av_intfloat64}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{av_intfloat64}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    av_int2float(i::Integer)

Reinterpret a 32-bit integer as a float.
"""
function av_int2float(i::Integer)
    ccall((:av_int2float, libavutil), Cfloat, (UInt32,), i)
end

"""
    av_float2int(f::Cfloat)

Reinterpret a float as a 32-bit integer.
"""
function av_float2int(f::Cfloat)
    ccall((:av_float2int, libavutil), UInt32, (Cfloat,), f)
end

"""
    av_int2double(i::UInt64)

Reinterpret a 64-bit integer as a double.
"""
function av_int2double(i::UInt64)
    ccall((:av_int2double, libavutil), Cdouble, (UInt64,), i)
end

"""
    av_double2int(f::Cdouble)

Reinterpret a double as a 64-bit integer.
"""
function av_double2int(f::Cdouble)
    ccall((:av_double2int, libavutil), UInt64, (Cdouble,), f)
end

struct av_alias64
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{av_alias64}, f::Symbol)
    f === :u64 && return Ptr{UInt64}(x + 0)
    f === :u32 && return Ptr{NTuple{2, UInt32}}(x + 0)
    f === :u16 && return Ptr{NTuple{4, UInt16}}(x + 0)
    f === :u8 && return Ptr{NTuple{8, UInt8}}(x + 0)
    f === :f64 && return Ptr{Cdouble}(x + 0)
    f === :f32 && return Ptr{NTuple{2, Cfloat}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::av_alias64, f::Symbol)
    r = Ref{av_alias64}(x)
    ptr = Base.unsafe_convert(Ptr{av_alias64}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{av_alias64}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct av_alias32
    data::NTuple{4, UInt8}
end

function Base.getproperty(x::Ptr{av_alias32}, f::Symbol)
    f === :u32 && return Ptr{UInt32}(x + 0)
    f === :u16 && return Ptr{NTuple{2, UInt16}}(x + 0)
    f === :u8 && return Ptr{NTuple{4, UInt8}}(x + 0)
    f === :f32 && return Ptr{Cfloat}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::av_alias32, f::Symbol)
    r = Ref{av_alias32}(x)
    ptr = Base.unsafe_convert(Ptr{av_alias32}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{av_alias32}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct av_alias16
    data::NTuple{2, UInt8}
end

function Base.getproperty(x::Ptr{av_alias16}, f::Symbol)
    f === :u16 && return Ptr{UInt16}(x + 0)
    f === :u8 && return Ptr{NTuple{2, UInt8}}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::av_alias16, f::Symbol)
    r = Ref{av_alias16}(x)
    ptr = Base.unsafe_convert(Ptr{av_alias16}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{av_alias16}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct unaligned_64
    data::NTuple{8, UInt8}
end

function Base.getproperty(x::Ptr{unaligned_64}, f::Symbol)
    f === :l && return Ptr{UInt64}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::unaligned_64, f::Symbol)
    r = Ref{unaligned_64}(x)
    ptr = Base.unsafe_convert(Ptr{unaligned_64}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{unaligned_64}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct unaligned_32
    data::NTuple{4, UInt8}
end

function Base.getproperty(x::Ptr{unaligned_32}, f::Symbol)
    f === :l && return Ptr{UInt32}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::unaligned_32, f::Symbol)
    r = Ref{unaligned_32}(x)
    ptr = Base.unsafe_convert(Ptr{unaligned_32}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{unaligned_32}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

struct unaligned_16
    data::NTuple{2, UInt8}
end

function Base.getproperty(x::Ptr{unaligned_16}, f::Symbol)
    f === :l && return Ptr{UInt16}(x + 0)
    return getfield(x, f)
end

function Base.getproperty(x::unaligned_16, f::Symbol)
    r = Ref{unaligned_16}(x)
    ptr = Base.unsafe_convert(Ptr{unaligned_16}, r)
    fptr = getproperty(ptr, f)
    GC.@preserve r unsafe_load(fptr)
end

function Base.setproperty!(x::Ptr{unaligned_16}, f::Symbol, v)
    unsafe_store!(getproperty(x, f), v)
end

"""
    AVLFG

Context structure for the Lagged Fibonacci PRNG. The exact layout, types and content of this struct may change and should not be accessed directly. Only its sizeof() is guranteed to stay the same to allow easy instanciation.
"""
struct AVLFG
    state::NTuple{64, Cuint}
    index::Cint
end

function av_lfg_init(c, seed::Integer)
    ccall((:av_lfg_init, libavutil), Cvoid, (Ptr{AVLFG}, Cuint), c, seed)
end

"""
    av_lfg_init_from_data(c, data, length::Integer)

Seed the state of the ALFG using binary data.

Return value: 0 on success, negative value ([`AVERROR`](@ref)) on failure.
"""
function av_lfg_init_from_data(c, data, length::Integer)
    ccall((:av_lfg_init_from_data, libavutil), Cint, (Ptr{AVLFG}, Ptr{UInt8}, Cuint), c, data, length)
end

"""
    av_lfg_get(c)

Get the next random unsigned 32-bit number using an ALFG.

Please also consider a simple LCG like state= state*1664525+1013904223, it may be good enough and faster for your specific use case.
"""
function av_lfg_get(c)
    ccall((:av_lfg_get, libavutil), Cuint, (Ptr{AVLFG},), c)
end

"""
    av_mlfg_get(c)

Get the next random unsigned 32-bit number using a MLFG.

Please also consider [`av_lfg_get`](@ref)() above, it is faster.
"""
function av_mlfg_get(c)
    ccall((:av_mlfg_get, libavutil), Cuint, (Ptr{AVLFG},), c)
end

"""
    av_bmg_get(lfg, out)

Get the next two numbers generated by a Box-Muller Gaussian generator using the random numbers issued by lfg.

### Parameters
* `out`: array where the two generated numbers are placed
"""
function av_bmg_get(lfg, out)
    ccall((:av_bmg_get, libavutil), Cvoid, (Ptr{AVLFG}, Ptr{Cdouble}), lfg, out)
end

"""
    av_log_get_level()

Get the current log level

### Returns
Current log level

### See also
lavu\\_log\\_constants
"""
function av_log_get_level()
    ccall((:av_log_get_level, libavutil), Cint, ())
end

"""
    av_log_set_level(level::Integer)

Set the log level

### Parameters
* `level`: Logging level

### See also
lavu\\_log\\_constants
"""
function av_log_set_level(level::Integer)
    ccall((:av_log_set_level, libavutil), Cvoid, (Cint,), level)
end

"""
    av_log_set_callback(callback)

Set the logging callback

!!! note

    The callback must be thread safe, even if the application does not use threads itself as some codecs are multithreaded.

### Parameters
* `callback`: A logging function with a compatible signature.

### See also
[`av_log_default_callback`](@ref)
"""
function av_log_set_callback(callback)
    ccall((:av_log_set_callback, libavutil), Cvoid, (Ptr{Cvoid},), callback)
end

"""
    av_default_item_name(ctx)

Return the context name

### Parameters
* `ctx`: The [`AVClass`](@ref) context

### Returns
The [`AVClass`](@ref) class\\_name
"""
function av_default_item_name(ctx)
    ccall((:av_default_item_name, libavutil), Cstring, (Ptr{Cvoid},), ctx)
end

function av_default_get_category(ptr)
    ccall((:av_default_get_category, libavutil), AVClassCategory, (Ptr{Cvoid},), ptr)
end

function av_log_set_flags(arg::Integer)
    ccall((:av_log_set_flags, libavutil), Cvoid, (Cint,), arg)
end

function av_log_get_flags()
    ccall((:av_log_get_flags, libavutil), Cint, ())
end

"""
    av_lzo1x_decode(out, outlen, in, inlen)

Decodes LZO 1x compressed data. 

Make sure all buffers are appropriately padded, in must provide [`AV_LZO_INPUT_PADDING`](@ref), out must provide [`AV_LZO_OUTPUT_PADDING`](@ref) additional bytes.

### Parameters
* `out`: output buffer 

* `outlen`: size of output buffer, number of bytes left are returned here 

* `in`: input buffer 

* `inlen`: size of input buffer, number of bytes left are returned here 

### Returns
0 on success, otherwise a combination of the error flags above
"""
function av_lzo1x_decode(out, outlen, in, inlen)
    ccall((:av_lzo1x_decode, libavutil), Cint, (Ptr{Cvoid}, Ptr{Cint}, Ptr{Cvoid}, Ptr{Cint}), out, outlen, in, inlen)
end

"""
    AVMasteringDisplayMetadata

Mastering display metadata capable of representing the color volume of the display used to master the content (SMPTE 2086:2014).

To be used as payload of a [`AVFrameSideData`](@ref) or [`AVPacketSideData`](@ref) with the appropriate type.

!!! note

    The struct should be allocated with [`av_mastering_display_metadata_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVMasteringDisplayMetadata
    display_primaries::NTuple{3, NTuple{2, AVRational}}
    white_point::NTuple{2, AVRational}
    min_luminance::AVRational
    max_luminance::AVRational
    has_primaries::Cint
    has_luminance::Cint
end

"""
    av_mastering_display_metadata_alloc()

Allocate an [`AVMasteringDisplayMetadata`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)().

### Returns
An [`AVMasteringDisplayMetadata`](@ref) filled with default values or NULL on failure.
"""
function av_mastering_display_metadata_alloc()
    ccall((:av_mastering_display_metadata_alloc, libavutil), Ptr{AVMasteringDisplayMetadata}, ())
end

"""
    av_mastering_display_metadata_create_side_data(frame)

Allocate a complete [`AVMasteringDisplayMetadata`](@ref) and add it to the frame.

### Parameters
* `frame`: The frame which side data is added to.

### Returns
The [`AVMasteringDisplayMetadata`](@ref) structure to be filled by caller.
"""
function av_mastering_display_metadata_create_side_data(frame)
    ccall((:av_mastering_display_metadata_create_side_data, libavutil), Ptr{AVMasteringDisplayMetadata}, (Ptr{AVFrame},), frame)
end

"""
    AVContentLightMetadata

Content light level needed by to transmit HDR over HDMI (CTA-861.3).

To be used as payload of a [`AVFrameSideData`](@ref) or [`AVPacketSideData`](@ref) with the appropriate type.

!!! note

    The struct should be allocated with [`av_content_light_metadata_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVContentLightMetadata
    MaxCLL::Cuint
    MaxFALL::Cuint
end

"""
    av_content_light_metadata_alloc(size)

Allocate an [`AVContentLightMetadata`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)().

### Returns
An [`AVContentLightMetadata`](@ref) filled with default values or NULL on failure.
"""
function av_content_light_metadata_alloc(size)
    ccall((:av_content_light_metadata_alloc, libavutil), Ptr{AVContentLightMetadata}, (Ptr{Csize_t},), size)
end

"""
    av_content_light_metadata_create_side_data(frame)

Allocate a complete [`AVContentLightMetadata`](@ref) and add it to the frame.

### Parameters
* `frame`: The frame which side data is added to.

### Returns
The [`AVContentLightMetadata`](@ref) structure to be filled by caller.
"""
function av_content_light_metadata_create_side_data(frame)
    ccall((:av_content_light_metadata_create_side_data, libavutil), Ptr{AVContentLightMetadata}, (Ptr{AVFrame},), frame)
end

"""
    AVRounding

Rounding methods.
"""
const AVRounding = UInt32
const AV_ROUND_ZERO = 0 % UInt32
const AV_ROUND_INF = 1 % UInt32
const AV_ROUND_DOWN = 2 % UInt32
const AV_ROUND_UP = 3 % UInt32
const AV_ROUND_NEAR_INF = 5 % UInt32
const AV_ROUND_PASS_MINMAX = 8192 % UInt32

"""
    av_gcd(a::Int64, b::Int64)

Compute the greatest common divisor of two integer operands.

### Parameters
* `a,b`: Operands 

### Returns
GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0; if a == 0 and b == 0, returns 0.
"""
function av_gcd(a::Int64, b::Int64)
    ccall((:av_gcd, libavutil), Int64, (Int64, Int64), a, b)
end

"""
    av_rescale(a::Int64, b::Int64, c::Int64)

Rescale a 64-bit integer with rounding to nearest.

The operation is mathematically equivalent to `a * b / c`, but writing that directly can overflow.

This function is equivalent to [`av_rescale_rnd`](@ref)() with #AV\\_ROUND\\_NEAR\\_INF.

### See also
[`av_rescale_rnd`](@ref)(), [`av_rescale_q`](@ref)(), [`av_rescale_q_rnd`](@ref)()
"""
function av_rescale(a::Int64, b::Int64, c::Int64)
    ccall((:av_rescale, libavutil), Int64, (Int64, Int64, Int64), a, b, c)
end

"""
    av_rescale_rnd(a::Int64, b::Int64, c::Int64, rnd::AVRounding)

Rescale a 64-bit integer with specified rounding.

The operation is mathematically equivalent to `a * b / c`, but writing that directly can overflow, and does not support different rounding methods.

### See also
[`av_rescale`](@ref)(), [`av_rescale_q`](@ref)(), [`av_rescale_q_rnd`](@ref)()
"""
function av_rescale_rnd(a::Int64, b::Int64, c::Int64, rnd::AVRounding)
    ccall((:av_rescale_rnd, libavutil), Int64, (Int64, Int64, Int64, AVRounding), a, b, c, rnd)
end

"""
    av_rescale_q(a::Int64, bq::AVRational, cq::AVRational)

Rescale a 64-bit integer by 2 rational numbers.

The operation is mathematically equivalent to `a * bq / cq`.

This function is equivalent to [`av_rescale_q_rnd`](@ref)() with #AV\\_ROUND\\_NEAR\\_INF.

### See also
[`av_rescale`](@ref)(), [`av_rescale_rnd`](@ref)(), [`av_rescale_q_rnd`](@ref)()
"""
function av_rescale_q(a::Int64, bq::AVRational, cq::AVRational)
    ccall((:av_rescale_q, libavutil), Int64, (Int64, AVRational, AVRational), a, bq, cq)
end

"""
    av_rescale_q_rnd(a::Int64, bq::AVRational, cq::AVRational, rnd::AVRounding)

Rescale a 64-bit integer by 2 rational numbers with specified rounding.

The operation is mathematically equivalent to `a * bq / cq`.

### See also
[`av_rescale`](@ref)(), [`av_rescale_rnd`](@ref)(), [`av_rescale_q`](@ref)()
"""
function av_rescale_q_rnd(a::Int64, bq::AVRational, cq::AVRational, rnd::AVRounding)
    ccall((:av_rescale_q_rnd, libavutil), Int64, (Int64, AVRational, AVRational, AVRounding), a, bq, cq, rnd)
end

"""
    av_compare_ts(ts_a::Int64, tb_a::AVRational, ts_b::Int64, tb_b::AVRational)

Compare two timestamps each in its own time base.

!!! warning

    The result of the function is undefined if one of the timestamps is outside the `int64_t` range when represented in the other's timebase.

### Returns
One of the following values: - -1 if `ts_a` is before `ts_b` - 1 if `ts_a` is after `ts_b` - 0 if they represent the same position
"""
function av_compare_ts(ts_a::Int64, tb_a::AVRational, ts_b::Int64, tb_b::AVRational)
    ccall((:av_compare_ts, libavutil), Cint, (Int64, AVRational, Int64, AVRational), ts_a, tb_a, ts_b, tb_b)
end

"""
    av_compare_mod(a::UInt64, b::UInt64, mod::UInt64)

Compare the remainders of two integer operands divided by a common divisor.

In other words, compare the least significant `log2(mod)` bits of integers `a` and `b`.

```c++
{.c}
 av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
 av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
```

### Parameters
* `a,b`: Operands 

* `mod`: Divisor; must be a power of 2 

### Returns
- a negative value if `a % mod < b % mod` - a positive value if `a % mod > b % mod` - zero if `a % mod == b % mod`
"""
function av_compare_mod(a::UInt64, b::UInt64, mod::UInt64)
    ccall((:av_compare_mod, libavutil), Int64, (UInt64, UInt64, UInt64), a, b, mod)
end

"""
    av_rescale_delta(in_tb::AVRational, in_ts::Int64, fs_tb::AVRational, duration::Integer, last, out_tb::AVRational)

Rescale a timestamp while preserving known durations.

This function is designed to be called per audio packet to scale the input timestamp to a different time base. Compared to a simple [`av_rescale_q`](@ref)() call, this function is robust against possible inconsistent frame durations.

The `last` parameter is a state variable that must be preserved for all subsequent calls for the same stream. For the first call, `*last` should be initialized to #[`AV_NOPTS_VALUE`](@ref).

!!! note

    In the context of this function, "duration" is in term of samples, not seconds.

### Parameters
* `in_tb`:\\[in\\] Input time base 

* `in_ts`:\\[in\\] Input timestamp 

* `fs_tb`:\\[in\\] Duration time base; typically this is finer-grained (greater) than `in_tb` and `out_tb` 

* `duration`:\\[in\\] Duration till the next call to this function (i.e. duration of the current packet/frame) 

* `last`:\\[in,out\\] Pointer to a timestamp expressed in terms of `fs_tb`, acting as a state variable 

* `out_tb`:\\[in\\] Output timebase 

### Returns
Timestamp expressed in terms of `out_tb`
"""
function av_rescale_delta(in_tb::AVRational, in_ts::Int64, fs_tb::AVRational, duration::Integer, last, out_tb::AVRational)
    ccall((:av_rescale_delta, libavutil), Int64, (AVRational, Int64, AVRational, Cint, Ptr{Int64}, AVRational), in_tb, in_ts, fs_tb, duration, last, out_tb)
end

"""
    av_add_stable(ts_tb::AVRational, ts::Int64, inc_tb::AVRational, inc::Int64)

Add a value to a timestamp.

This function guarantees that when the same value is repeatly added that no accumulation of rounding errors occurs.

### Parameters
* `ts`:\\[in\\] Input timestamp 

* `ts_tb`:\\[in\\] Input timestamp time base 

* `inc`:\\[in\\] Value to be added 

* `inc_tb`:\\[in\\] Time base of `inc`
"""
function av_add_stable(ts_tb::AVRational, ts::Int64, inc_tb::AVRational, inc::Int64)
    ccall((:av_add_stable, libavutil), Int64, (AVRational, Int64, AVRational, Int64), ts_tb, ts, inc_tb, inc)
end

mutable struct AVMD5 end

"""
    av_md5_alloc()

Allocate an [`AVMD5`](@ref) context.
"""
function av_md5_alloc()
    ccall((:av_md5_alloc, libavutil), Ptr{AVMD5}, ())
end

"""
    av_md5_init(ctx)

Initialize MD5 hashing.

### Parameters
* `ctx`: pointer to the function context (of size av\\_md5\\_size)
"""
function av_md5_init(ctx)
    ccall((:av_md5_init, libavutil), Cvoid, (Ptr{AVMD5},), ctx)
end

function av_md5_update(ctx, src, len::Integer)
    ccall((:av_md5_update, libavutil), Cvoid, (Ptr{AVMD5}, Ptr{UInt8}, Cint), ctx, src, len)
end

"""
    av_md5_final(ctx, dst)

Finish hashing and output digest value.

### Parameters
* `ctx`: hash function context 

* `dst`: buffer where output digest value is stored
"""
function av_md5_final(ctx, dst)
    ccall((:av_md5_final, libavutil), Cvoid, (Ptr{AVMD5}, Ptr{UInt8}), ctx, dst)
end

function av_md5_sum(dst, src, len::Integer)
    ccall((:av_md5_sum, libavutil), Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Cint), dst, src, len)
end

"""
    av_malloc(size::Csize_t)

Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU).

### Parameters
* `size`: Size in bytes for the memory block to be allocated 

### Returns
Pointer to the allocated block, or `NULL` if the block cannot be allocated 

### See also
[`av_mallocz`](@ref)()
"""
function av_malloc(size::Csize_t)
    ccall((:av_malloc, libavutil), Ptr{Cvoid}, (Csize_t,), size)
end

"""
    av_mallocz(size::Csize_t)

Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block.

### Parameters
* `size`: Size in bytes for the memory block to be allocated 

### Returns
Pointer to the allocated block, or `NULL` if it cannot be allocated 

### See also
[`av_malloc`](@ref)()
"""
function av_mallocz(size::Csize_t)
    ccall((:av_mallocz, libavutil), Ptr{Cvoid}, (Csize_t,), size)
end

"""
    av_malloc_array(nmemb::Csize_t, size::Csize_t)

Allocate a memory block for an array with [`av_malloc`](@ref)().

The allocated memory will have size `size * nmemb` bytes.

### Parameters
* `nmemb`: Number of element 

* `size`: Size of a single element 

### Returns
Pointer to the allocated block, or `NULL` if the block cannot be allocated 

### See also
[`av_malloc`](@ref)()
"""
function av_malloc_array(nmemb::Csize_t, size::Csize_t)
    ccall((:av_malloc_array, libavutil), Ptr{Cvoid}, (Csize_t, Csize_t), nmemb, size)
end

"""
    av_mallocz_array(nmemb::Csize_t, size::Csize_t)

Allocate a memory block for an array with [`av_mallocz`](@ref)().

The allocated memory will have size `size * nmemb` bytes.

### Parameters
* `nmemb`: Number of elements 

* `size`: Size of the single element 

### Returns
Pointer to the allocated block, or `NULL` if the block cannot be allocated

### See also
[`av_mallocz`](@ref)(), [`av_malloc_array`](@ref)()
"""
function av_mallocz_array(nmemb::Csize_t, size::Csize_t)
    ccall((:av_mallocz_array, libavutil), Ptr{Cvoid}, (Csize_t, Csize_t), nmemb, size)
end

"""
    av_calloc(nmemb::Csize_t, size::Csize_t)

Non-inlined equivalent of [`av_mallocz_array`](@ref)().

Created for symmetry with the calloc() C function.
"""
function av_calloc(nmemb::Csize_t, size::Csize_t)
    ccall((:av_calloc, libavutil), Ptr{Cvoid}, (Csize_t, Csize_t), nmemb, size)
end

"""
    av_realloc(ptr, size::Csize_t)

Allocate, reallocate, or free a block of memory.

If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is zero, free the memory block pointed to by `ptr`. Otherwise, expand or shrink that block of memory according to `size`.

!!! warning

    Unlike [`av_malloc`](@ref)(), the returned pointer is not guaranteed to be correctly aligned. 

### Parameters
* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL` 

* `size`: Size in bytes of the memory block to be allocated or reallocated

### Returns
Pointer to a newly-reallocated block or `NULL` if the block cannot be reallocated or the function is used to free the memory block

### See also
[`av_fast_realloc`](@ref)(), [`av_reallocp`](@ref)()
"""
function av_realloc(ptr, size::Csize_t)
    ccall((:av_realloc, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Csize_t), ptr, size)
end

"""
    av_reallocp(ptr, size::Csize_t)

Allocate, reallocate, or free a block of memory through a pointer to a pointer.

If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is zero, free the memory block pointed to by `*ptr`. Otherwise, expand or shrink that block of memory according to `size`.

!!! warning

    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned.

### Parameters
* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure. 

* `size`:\\[in\\] Size in bytes for the memory block to be allocated or reallocated

### Returns
Zero on success, an [`AVERROR`](@ref) error code on failure
"""
function av_reallocp(ptr, size::Csize_t)
    ccall((:av_reallocp, libavutil), Cint, (Ptr{Cvoid}, Csize_t), ptr, size)
end

"""
    av_realloc_f(ptr, nelem::Csize_t, elsize::Csize_t)

Allocate, reallocate, or free a block of memory.

This function does the same thing as [`av_realloc`](@ref)(), except: - It takes two size arguments and allocates `nelem * elsize` bytes, after checking the result of the multiplication for integer overflow. - It frees the input block in case of failure, thus avoiding the memory leak with the classic 

```c++
{.c}
   buf = realloc(buf);
   if (!buf)
       return -1;
```

pattern.
"""
function av_realloc_f(ptr, nelem::Csize_t, elsize::Csize_t)
    ccall((:av_realloc_f, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Csize_t, Csize_t), ptr, nelem, elsize)
end

"""
    av_realloc_array(ptr, nmemb::Csize_t, size::Csize_t)

Allocate, reallocate, or free an array.

If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is zero, free the memory block pointed to by `ptr`.

!!! warning

    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned. 

### Parameters
* `ptr`: Pointer to a memory block already allocated with [`av_realloc`](@ref)() or `NULL` 

* `nmemb`: Number of elements in the array 

* `size`: Size of the single element of the array

### Returns
Pointer to a newly-reallocated block or NULL if the block cannot be reallocated or the function is used to free the memory block

### See also
[`av_reallocp_array`](@ref)()
"""
function av_realloc_array(ptr, nmemb::Csize_t, size::Csize_t)
    ccall((:av_realloc_array, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Csize_t, Csize_t), ptr, nmemb, size)
end

"""
    av_reallocp_array(ptr, nmemb::Csize_t, size::Csize_t)

Allocate, reallocate, or free an array through a pointer to a pointer.

If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is zero, free the memory block pointed to by `*ptr`.

!!! warning

    Unlike [`av_malloc`](@ref)(), the allocated memory is not guaranteed to be correctly aligned.

### Parameters
* `ptr`:\\[in,out\\] Pointer to a pointer to a memory block already allocated with [`av_realloc`](@ref)(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure. 

* `nmemb`:\\[in\\] Number of elements 

* `size`:\\[in\\] Size of the single element

### Returns
Zero on success, an [`AVERROR`](@ref) error code on failure
"""
function av_reallocp_array(ptr, nmemb::Csize_t, size::Csize_t)
    ccall((:av_reallocp_array, libavutil), Cint, (Ptr{Cvoid}, Csize_t, Csize_t), ptr, nmemb, size)
end

"""
    av_fast_realloc(ptr, size, min_size::Csize_t)

Reallocate the given buffer if it is not large enough, otherwise do nothing.

If the given buffer is `NULL`, then a new uninitialized buffer is allocated.

If the given buffer is not large enough, and reallocation fails, `NULL` is returned and `*size` is set to 0, but the original buffer is not changed or freed.

A typical use pattern follows:

```c++
{.c}
 uint8_t *buf = ...;
 uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
 if (!new_buf) {
     // Allocation failed; clean up original buffer
     av_freep(&buf);
     return AVERROR(ENOMEM);
 }
```

### Parameters
* `ptr`:\\[in,out\\] Already allocated buffer, or `NULL` 

* `size`:\\[in,out\\] Pointer to the size of buffer `ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 

* `min_size`:\\[in\\] Desired minimal size of buffer `ptr` 

### Returns
`ptr` if the buffer is large enough, a pointer to newly reallocated buffer if the buffer was not large enough, or `NULL` in case of error 

### See also
[`av_realloc`](@ref)(), [`av_fast_malloc`](@ref)()
"""
function av_fast_realloc(ptr, size, min_size::Csize_t)
    ccall((:av_fast_realloc, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
end

"""
    av_fast_malloc(ptr, size, min_size::Csize_t)

Allocate a buffer, reusing the given one if large enough.

Contrary to [`av_fast_realloc`](@ref)(), the current buffer contents might not be preserved and on error the old buffer is freed, thus no special handling to avoid memleaks is necessary.

`*ptr` is allowed to be `NULL`, in which case allocation always happens if `size_needed` is greater than 0.

```c++
{.c}
 uint8_t *buf = ...;
 av_fast_malloc(&buf, &current_size, size_needed);
 if (!buf) {
     // Allocation failed; buf already freed
     return AVERROR(ENOMEM);
 }
```

### Parameters
* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure 

* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 

* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr` 

### See also
[`av_realloc`](@ref)(), [`av_fast_mallocz`](@ref)()
"""
function av_fast_malloc(ptr, size, min_size::Csize_t)
    ccall((:av_fast_malloc, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
end

"""
    av_fast_mallocz(ptr, size, min_size::Csize_t)

Allocate and clear a buffer, reusing the given one if large enough.

Like [`av_fast_malloc`](@ref)(), but all newly allocated space is initially cleared. Reused buffer is not cleared.

`*ptr` is allowed to be `NULL`, in which case allocation always happens if `size_needed` is greater than 0.

### Parameters
* `ptr`:\\[in,out\\] Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure 

* `size`:\\[in,out\\] Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure. 

* `min_size`:\\[in\\] Desired minimal size of buffer `*ptr` 

### See also
[`av_fast_malloc`](@ref)()
"""
function av_fast_mallocz(ptr, size, min_size::Csize_t)
    ccall((:av_fast_mallocz, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{Cuint}, Csize_t), ptr, size, min_size)
end

"""
    av_free(ptr)

Free a memory block which has been allocated with a function of [`av_malloc`](@ref)() or [`av_realloc`](@ref)() family.

!!! note

    `ptr = NULL` is explicitly allowed. 

!!! note

    It is recommended that you use [`av_freep`](@ref)() instead, to prevent leaving behind dangling pointers. 

### Parameters
* `ptr`: Pointer to the memory block which should be freed.

### See also
[`av_freep`](@ref)()
"""
function av_free(ptr)
    ccall((:av_free, libavutil), Cvoid, (Ptr{Cvoid},), ptr)
end

"""
    av_freep(ptr)

Free a memory block which has been allocated with a function of [`av_malloc`](@ref)() or [`av_realloc`](@ref)() family, and set the pointer pointing to it to `NULL`.

```c++
{.c}
 uint8_t *buf = av_malloc(16);
 av_free(buf);
 // buf now contains a dangling pointer to freed memory, and accidental
 // dereference of buf will result in a use-after-free, which may be a
 // security risk.
 uint8_t *buf = av_malloc(16);
 av_freep(&buf);
 // buf is now NULL, and accidental dereference will only result in a
 // NULL-pointer dereference.
```

!!! note

    `*ptr = NULL` is safe and leads to no action. 

### Parameters
* `ptr`: Pointer to the pointer to the memory block which should be freed 

### See also
[`av_free`](@ref)()
"""
function av_freep(ptr)
    ccall((:av_freep, libavutil), Cvoid, (Ptr{Cvoid},), ptr)
end

"""
    av_strdup(s)

Duplicate a string.

### Parameters
* `s`: String to be duplicated 

### Returns
Pointer to a newly-allocated string containing a copy of `s` or `NULL` if the string cannot be allocated 

### See also
[`av_strndup`](@ref)()
"""
function av_strdup(s)
    ccall((:av_strdup, libavutil), Cstring, (Cstring,), s)
end

"""
    av_strndup(s, len::Csize_t)

Duplicate a substring of a string.

### Parameters
* `s`: String to be duplicated 

* `len`: Maximum length of the resulting string (not counting the terminating byte) 

### Returns
Pointer to a newly-allocated string containing a substring of `s` or `NULL` if the string cannot be allocated
"""
function av_strndup(s, len::Csize_t)
    ccall((:av_strndup, libavutil), Cstring, (Cstring, Csize_t), s, len)
end

"""
    av_memdup(p, size::Csize_t)

Duplicate a buffer with [`av_malloc`](@ref)().

### Parameters
* `p`: Buffer to be duplicated 

* `size`: Size in bytes of the buffer copied 

### Returns
Pointer to a newly allocated buffer containing a copy of `p` or `NULL` if the buffer cannot be allocated
"""
function av_memdup(p, size::Csize_t)
    ccall((:av_memdup, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Csize_t), p, size)
end

"""
    av_memcpy_backptr(dst, back::Integer, cnt::Integer)

Overlapping memcpy() implementation.

!!! note

    `cnt > back` is valid, this will copy the bytes we just copied, thus creating a repeating pattern with a period length of `back`.

### Parameters
* `dst`: Destination buffer 

* `back`: Number of bytes back to start copying (i.e. the initial size of the overlapping window); must be > 0 

* `cnt`: Number of bytes to copy; must be >= 0
"""
function av_memcpy_backptr(dst, back::Integer, cnt::Integer)
    ccall((:av_memcpy_backptr, libavutil), Cvoid, (Ptr{UInt8}, Cint, Cint), dst, back, cnt)
end

"""
    av_dynarray_add(tab_ptr, nb_ptr, elem)

Add the pointer to an element to a dynamic array.

The array to grow is supposed to be an array of pointers to structures, and the element to add must be a pointer to an already allocated structure.

The array is reallocated when its size reaches powers of 2. Therefore, the amortized cost of adding an element is constant.

In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by `nb_ptr` is incremented. In case of failure, the array is freed, `*tab\\_ptr` is set to `NULL` and `*nb\\_ptr` is set to 0.

### Parameters
* `tab_ptr`:\\[in,out\\] Pointer to the array to grow 

* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array 

* `elem`:\\[in\\] Element to add 

### See also
[`av_dynarray_add_nofree`](@ref)(), [`av_dynarray2_add`](@ref)()
"""
function av_dynarray_add(tab_ptr, nb_ptr, elem)
    ccall((:av_dynarray_add, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{Cint}, Ptr{Cvoid}), tab_ptr, nb_ptr, elem)
end

"""
    av_dynarray_add_nofree(tab_ptr, nb_ptr, elem)

Add an element to a dynamic array.

Function has the same functionality as [`av_dynarray_add`](@ref)(), but it doesn't free memory on fails. It returns error code instead and leave current buffer untouched.

### Returns
>=0 on success, negative otherwise 

### See also
[`av_dynarray_add`](@ref)(), [`av_dynarray2_add`](@ref)()
"""
function av_dynarray_add_nofree(tab_ptr, nb_ptr, elem)
    ccall((:av_dynarray_add_nofree, libavutil), Cint, (Ptr{Cvoid}, Ptr{Cint}, Ptr{Cvoid}), tab_ptr, nb_ptr, elem)
end

"""
    av_dynarray2_add(tab_ptr, nb_ptr, elem_size::Csize_t, elem_data)

Add an element of size `elem_size` to a dynamic array.

The array is reallocated when its number of elements reaches powers of 2. Therefore, the amortized cost of adding an element is constant.

In case of success, the pointer to the array is updated in order to point to the new grown array, and the number pointed to by `nb_ptr` is incremented. In case of failure, the array is freed, `*tab\\_ptr` is set to `NULL` and `*nb\\_ptr` is set to 0.

### Parameters
* `tab_ptr`:\\[in,out\\] Pointer to the array to grow 

* `nb_ptr`:\\[in,out\\] Pointer to the number of elements in the array 

* `elem_size`:\\[in\\] Size in bytes of an element in the array 

* `elem_data`:\\[in\\] Pointer to the data of the element to add. If `NULL`, the space of the newly added element is allocated but left uninitialized.

### Returns
Pointer to the data of the element to copy in the newly allocated space 

### See also
[`av_dynarray_add`](@ref)(), [`av_dynarray_add_nofree`](@ref)()
"""
function av_dynarray2_add(tab_ptr, nb_ptr, elem_size::Csize_t, elem_data)
    ccall((:av_dynarray2_add, libavutil), Ptr{Cvoid}, (Ptr{Ptr{Cvoid}}, Ptr{Cint}, Csize_t, Ptr{UInt8}), tab_ptr, nb_ptr, elem_size, elem_data)
end

"""
    av_size_mult(a::Csize_t, b::Csize_t, r)

Multiply two `size_t` values checking for overflow.

### Parameters
* `a,b`:\\[in\\] Operands of multiplication 

* `r`:\\[out\\] Pointer to the result of the operation 

### Returns
0 on success, [`AVERROR`](@ref)(EINVAL) on overflow
"""
function av_size_mult(a::Csize_t, b::Csize_t, r)
    ccall((:av_size_mult, libavutil), Cint, (Csize_t, Csize_t, Ptr{Csize_t}), a, b, r)
end

"""
    av_max_alloc(max::Csize_t)

Set the maximum size that may be allocated in one block.

The value specified with this function is effective for all libavutil's lavu_mem_funcs "heap management functions."

By default, the max value is defined as `INT_MAX`.

!!! warning

    Exercise extreme caution when using this function. Don't touch this if you do not understand the full consequence of doing so.

### Parameters
* `max`: Value to be set as the new maximum size
"""
function av_max_alloc(max::Csize_t)
    ccall((:av_max_alloc, libavutil), Cvoid, (Csize_t,), max)
end

struct AVMotionVector
    source::Int32
    w::UInt8
    h::UInt8
    src_x::Int16
    src_y::Int16
    dst_x::Int16
    dst_y::Int16
    flags::UInt64
    motion_x::Int32
    motion_y::Int32
    motion_scale::UInt16
end

mutable struct AVMurMur3 end

"""
    av_murmur3_alloc()

Allocate an [`AVMurMur3`](@ref) hash context.

### Returns
Uninitialized hash context or `NULL` in case of error
"""
function av_murmur3_alloc()
    ccall((:av_murmur3_alloc, libavutil), Ptr{AVMurMur3}, ())
end

"""
    av_murmur3_init_seeded(c, seed::UInt64)

Initialize or reinitialize an [`AVMurMur3`](@ref) hash context with a seed.

### Parameters
* `c`:\\[out\\] Hash context 

* `seed`:\\[in\\] Random seed

### See also
[`av_murmur3_init`](@ref)(), lavu_murmur3_seedinfo "Detailed description" on a discussion of seeds for MurmurHash3.
"""
function av_murmur3_init_seeded(c, seed::UInt64)
    ccall((:av_murmur3_init_seeded, libavutil), Cvoid, (Ptr{AVMurMur3}, UInt64), c, seed)
end

"""
    av_murmur3_init(c)

Initialize or reinitialize an [`AVMurMur3`](@ref) hash context.

Equivalent to [`av_murmur3_init_seeded`](@ref)() with a built-in seed.

### Parameters
* `c`:\\[out\\] Hash context

### See also
[`av_murmur3_init_seeded`](@ref)(), lavu_murmur3_seedinfo "Detailed description" on a discussion of seeds for MurmurHash3.
"""
function av_murmur3_init(c)
    ccall((:av_murmur3_init, libavutil), Cvoid, (Ptr{AVMurMur3},), c)
end

function av_murmur3_update(c, src, len::Integer)
    ccall((:av_murmur3_update, libavutil), Cvoid, (Ptr{AVMurMur3}, Ptr{UInt8}, Cint), c, src, len)
end

"""
    av_murmur3_final(c, dst)

Finish hashing and output digest value.

### Parameters
* `c`:\\[in,out\\] Hash context 

* `dst`:\\[out\\] Buffer where output digest value is stored
"""
function av_murmur3_final(c, dst)
    ccall((:av_murmur3_final, libavutil), Cvoid, (Ptr{AVMurMur3}, Ptr{UInt8}), c, dst)
end

function av_opt_set_bin(obj, name, val, size::Integer, search_flags::Integer)
    ccall((:av_opt_set_bin, libavutil), Cint, (Ptr{Cvoid}, Cstring, Ptr{UInt8}, Cint, Cint), obj, name, val, size, search_flags)
end

"""
    AVOptionRange

A single allowed range of values, or a single allowed value.
"""
struct AVOptionRange
    str::Cstring
    value_min::Cdouble
    value_max::Cdouble
    component_min::Cdouble
    component_max::Cdouble
    is_range::Cint
end

"""
    AVOptionRanges

List of [`AVOptionRange`](@ref) structs.
"""
struct AVOptionRanges
    range::Ptr{Ptr{AVOptionRange}}
    nb_ranges::Cint
    nb_components::Cint
end

"""
    av_opt_show2(obj, av_log_obj, req_flags::Integer, rej_flags::Integer)

Show the obj options.

### Parameters
* `req_flags`: requested flags for the options to show. Show only the options for which it is opt->flags & req\\_flags. 

* `rej_flags`: rejected flags for the options to show. Show only the options for which it is !(opt->flags & req\\_flags). 

* `av_log_obj`: log context to use for showing the options
"""
function av_opt_show2(obj, av_log_obj, req_flags::Integer, rej_flags::Integer)
    ccall((:av_opt_show2, libavutil), Cint, (Ptr{Cvoid}, Ptr{Cvoid}, Cint, Cint), obj, av_log_obj, req_flags, rej_flags)
end

"""
    av_opt_set_defaults(s)

Set the values of all [`AVOption`](@ref) fields to their default values.

### Parameters
* `s`: an [`AVOption`](@ref)-enabled struct (its first member must be a pointer to [`AVClass`](@ref))
"""
function av_opt_set_defaults(s)
    ccall((:av_opt_set_defaults, libavutil), Cvoid, (Ptr{Cvoid},), s)
end

"""
    av_opt_set_defaults2(s, mask::Integer, flags::Integer)

Set the values of all [`AVOption`](@ref) fields to their default values. Only these [`AVOption`](@ref) fields for which (opt->flags & mask) == flags will have their default applied to s.

### Parameters
* `s`: an [`AVOption`](@ref)-enabled struct (its first member must be a pointer to [`AVClass`](@ref)) 

* `mask`: combination of AV\\_OPT\\_FLAG\\_* 

* `flags`: combination of AV\\_OPT\\_FLAG\\_*
"""
function av_opt_set_defaults2(s, mask::Integer, flags::Integer)
    ccall((:av_opt_set_defaults2, libavutil), Cvoid, (Ptr{Cvoid}, Cint, Cint), s, mask, flags)
end

"""
    av_set_options_string(ctx, opts, key_val_sep, pairs_sep)

Parse the key/value pairs list in opts. For each key/value pair found, stores the value in the field in ctx that is named like the key. ctx must be an [`AVClass`](@ref) context, storing is done using AVOptions.

### Parameters
* `opts`: options string to parse, may be NULL 

* `key_val_sep`: a 0-terminated list of characters used to separate key from value 

* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other 

### Returns
the number of successfully set key/value pairs, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error: [`AVERROR`](@ref)(EINVAL) if opts cannot be parsed, the error code issued by [`av_opt_set`](@ref)() if a key/value pair cannot be set
"""
function av_set_options_string(ctx, opts, key_val_sep, pairs_sep)
    ccall((:av_set_options_string, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cstring, Cstring), ctx, opts, key_val_sep, pairs_sep)
end

"""
    av_opt_set_from_string(ctx, opts, shorthand, key_val_sep, pairs_sep)

Parse the key-value pairs list in opts. For each key=value pair found, set the value of the corresponding option in ctx.

Options names must use only the following characters: a-z A-Z 0-9 - . / \\_ Separators must use characters distinct from option names and from each other.

### Parameters
* `ctx`: the [`AVClass`](@ref) object to set options on 

* `opts`: the options string, key-value pairs separated by a delimiter 

* `shorthand`: a NULL-terminated array of options names for shorthand notation: if the first field in opts has no key part, the key is taken from the first element of shorthand; then again for the second, etc., until either opts is finished, shorthand is finished or a named option is found; after that, all options must be named 

* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '=' 

* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ',' 

### Returns
the number of successfully set key=value pairs, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error: [`AVERROR`](@ref)(EINVAL) if opts cannot be parsed, the error code issued by av\\_set\\_string3() if a key/value pair cannot be set
"""
function av_opt_set_from_string(ctx, opts, shorthand, key_val_sep, pairs_sep)
    ccall((:av_opt_set_from_string, libavutil), Cint, (Ptr{Cvoid}, Cstring, Ptr{Cstring}, Cstring, Cstring), ctx, opts, shorthand, key_val_sep, pairs_sep)
end

"""
    av_opt_free(obj)

Free all allocated objects in obj.
"""
function av_opt_free(obj)
    ccall((:av_opt_free, libavutil), Cvoid, (Ptr{Cvoid},), obj)
end

"""
    av_opt_flag_is_set(obj, field_name, flag_name)

Check whether a particular flag is set in a flags field.

### Parameters
* `field_name`: the name of the flag field option 

* `flag_name`: the name of the flag to check 

### Returns
non-zero if the flag is set, zero if the flag isn't set, isn't of the right type, or the flags field doesn't exist.
"""
function av_opt_flag_is_set(obj, field_name, flag_name)
    ccall((:av_opt_flag_is_set, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cstring), obj, field_name, flag_name)
end

"""
    av_opt_set_dict(obj, options)

Set all the options from a given dictionary on an object.

### Parameters
* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref) 

* `options`: options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with [`av_dict_free`](@ref)().

### Returns
0 on success, a negative [`AVERROR`](@ref) if some option was found in obj, but could not be set.

### See also
[`av_dict_copy`](@ref)()
"""
function av_opt_set_dict(obj, options)
    ccall((:av_opt_set_dict, libavutil), Cint, (Ptr{Cvoid}, Ptr{Ptr{AVDictionary}}), obj, options)
end

"""
    av_opt_set_dict2(obj, options, search_flags::Integer)

Set all the options from a given dictionary on an object.

### Parameters
* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref) 

* `options`: options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with [`av_dict_free`](@ref)(). 

* `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*.

### Returns
0 on success, a negative [`AVERROR`](@ref) if some option was found in obj, but could not be set.

### See also
[`av_dict_copy`](@ref)()
"""
function av_opt_set_dict2(obj, options, search_flags::Integer)
    ccall((:av_opt_set_dict2, libavutil), Cint, (Ptr{Cvoid}, Ptr{Ptr{AVDictionary}}, Cint), obj, options, search_flags)
end

"""
    av_opt_get_key_value(ropts, key_val_sep, pairs_sep, flags::Integer, rkey, rval)

Extract a key-value pair from the beginning of a string.

### Parameters
* `ropts`: pointer to the options string, will be updated to point to the rest of the string (one of the pairs\\_sep or the final NUL) 

* `key_val_sep`: a 0-terminated list of characters used to separate key from value, for example '=' 

* `pairs_sep`: a 0-terminated list of characters used to separate two pairs from each other, for example ':' or ',' 

* `flags`: flags; see the AV\\_OPT\\_FLAG\\_* values below 

* `rkey`: parsed key; must be freed using [`av_free`](@ref)() 

* `rval`: parsed value; must be freed using [`av_free`](@ref)()

### Returns
>=0 for success, or a negative value corresponding to an [`AVERROR`](@ref) code in case of error; in particular: [`AVERROR`](@ref)(EINVAL) if no key is present
"""
function av_opt_get_key_value(ropts, key_val_sep, pairs_sep, flags::Integer, rkey, rval)
    ccall((:av_opt_get_key_value, libavutil), Cint, (Ptr{Cstring}, Cstring, Cstring, Cuint, Ptr{Cstring}, Ptr{Cstring}), ropts, key_val_sep, pairs_sep, flags, rkey, rval)
end

const __JL_Ctag_975 = UInt32
const AV_OPT_FLAG_IMPLICIT_KEY = 1 % UInt32

"""
    av_opt_eval_flags(obj, o, val, flags_out)

` opt_eval_funcs Evaluating option strings`

@{ This group of functions can be used to evaluate option strings and get numbers out of them. They do the same thing as [`av_opt_set`](@ref)(), except the result is written into the caller-supplied pointer.

### Parameters
* `obj`: a struct whose first element is a pointer to [`AVClass`](@ref). 

* `o`: an option for which the string is to be evaluated. 

* `val`: string to be evaluated. 

* `*_out`: value of the string will be written here.

### Returns
0 on success, a negative number on failure.
"""
function av_opt_eval_flags(obj, o, val, flags_out)
    ccall((:av_opt_eval_flags, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{Cint}), obj, o, val, flags_out)
end

function av_opt_eval_int(obj, o, val, int_out)
    ccall((:av_opt_eval_int, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{Cint}), obj, o, val, int_out)
end

function av_opt_eval_int64(obj, o, val, int64_out)
    ccall((:av_opt_eval_int64, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{Int64}), obj, o, val, int64_out)
end

function av_opt_eval_float(obj, o, val, float_out)
    ccall((:av_opt_eval_float, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{Cfloat}), obj, o, val, float_out)
end

function av_opt_eval_double(obj, o, val, double_out)
    ccall((:av_opt_eval_double, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{Cdouble}), obj, o, val, double_out)
end

function av_opt_eval_q(obj, o, val, q_out)
    ccall((:av_opt_eval_q, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}, Cstring, Ptr{AVRational}), obj, o, val, q_out)
end

"""
    av_opt_find(obj, name, unit, opt_flags::Integer, search_flags::Integer)

Look for an option in an object. Consider only options which have all the specified flags set.

!!! note

    Options found with [`AV_OPT_SEARCH_CHILDREN`](@ref) flag may not be settable directly with [`av_opt_set`](@ref)(). Use special calls which take an options [`AVDictionary`](@ref) (e.g. [`avformat_open_input`](@ref)()) to set options found with this flag.

### Parameters
* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set. 

* `name`:\\[in\\] The name of the option to look for. 

* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to. 

* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG). 

* `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*.

### Returns
A pointer to the option found, or NULL if no option was found.
"""
function av_opt_find(obj, name, unit, opt_flags::Integer, search_flags::Integer)
    ccall((:av_opt_find, libavutil), Ptr{AVOption}, (Ptr{Cvoid}, Cstring, Cstring, Cint, Cint), obj, name, unit, opt_flags, search_flags)
end

"""
    av_opt_find2(obj, name, unit, opt_flags::Integer, search_flags::Integer, target_obj)

Look for an option in an object. Consider only options which have all the specified flags set.

### Parameters
* `obj`:\\[in\\] A pointer to a struct whose first element is a pointer to an [`AVClass`](@ref). Alternatively a double pointer to an [`AVClass`](@ref), if [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) search flag is set. 

* `name`:\\[in\\] The name of the option to look for. 

* `unit`:\\[in\\] When searching for named constants, name of the unit it belongs to. 

* `opt_flags`: Find only options with all the specified flags set (AV\\_OPT\\_FLAG). 

* `search_flags`: A combination of AV\\_OPT\\_SEARCH\\_*. 

* `target_obj`:\\[out\\] if non-NULL, an object to which the option belongs will be written here. It may be different from obj if [`AV_OPT_SEARCH_CHILDREN`](@ref) is present in search\\_flags. This parameter is ignored if search\\_flags contain [`AV_OPT_SEARCH_FAKE_OBJ`](@ref).

### Returns
A pointer to the option found, or NULL if no option was found.
"""
function av_opt_find2(obj, name, unit, opt_flags::Integer, search_flags::Integer, target_obj)
    ccall((:av_opt_find2, libavutil), Ptr{AVOption}, (Ptr{Cvoid}, Cstring, Cstring, Cint, Cint, Ptr{Ptr{Cvoid}}), obj, name, unit, opt_flags, search_flags, target_obj)
end

"""
    av_opt_next(obj, prev)

Iterate over all AVOptions belonging to obj.

### Parameters
* `obj`: an AVOptions-enabled struct or a double pointer to an [`AVClass`](@ref) describing it. 

* `prev`: result of the previous call to [`av_opt_next`](@ref)() on this object or NULL 

### Returns
next [`AVOption`](@ref) or NULL
"""
function av_opt_next(obj, prev)
    ccall((:av_opt_next, libavutil), Ptr{AVOption}, (Ptr{Cvoid}, Ptr{AVOption}), obj, prev)
end

"""
    av_opt_child_next(obj, prev)

Iterate over AVOptions-enabled children of obj.

### Parameters
* `prev`: result of a previous call to this function or NULL 

### Returns
next AVOptions-enabled child or NULL
"""
function av_opt_child_next(obj, prev)
    ccall((:av_opt_child_next, libavutil), Ptr{Cvoid}, (Ptr{Cvoid}, Ptr{Cvoid}), obj, prev)
end

"""
    av_opt_child_class_next(parent, prev)

Iterate over potential AVOptions-enabled children of parent.

\\deprecated use [`av_opt_child_class_iterate`](@ref)

### Parameters
* `prev`: result of a previous call to this function or NULL 

### Returns
[`AVClass`](@ref) corresponding to next potential child or NULL
"""
function av_opt_child_class_next(parent, prev)
    ccall((:av_opt_child_class_next, libavutil), Ptr{AVClass}, (Ptr{AVClass}, Ptr{AVClass}), parent, prev)
end

"""
    av_opt_child_class_iterate(parent, iter)

Iterate over potential AVOptions-enabled children of parent.

### Parameters
* `iter`: a pointer where iteration state is stored. 

### Returns
[`AVClass`](@ref) corresponding to next potential child or NULL
"""
function av_opt_child_class_iterate(parent, iter)
    ccall((:av_opt_child_class_iterate, libavutil), Ptr{AVClass}, (Ptr{AVClass}, Ptr{Ptr{Cvoid}}), parent, iter)
end

"""
    av_opt_set(obj, name, val, search_flags::Integer)

` opt_set_funcs Option setting functions`

@{ Those functions set the field of obj with the given name to value.

### Parameters
* `obj`:\\[in\\] A struct whose first element is a pointer to an [`AVClass`](@ref). 

* `name`:\\[in\\] the name of the field to set 

* `val`:\\[in\\] The value to set. In case of [`av_opt_set`](@ref)() if the field is not of a string type, then the given string is parsed. SI postfixes and some named scalars are supported. If the field is of a numeric type, it has to be a numeric or named scalar. Behavior with more than one scalar and +- infix operators is undefined. If the field is of a flags type, it has to be a sequence of numeric scalars or named flags separated by '+' or '-'. Prefixing a flag with '+' causes it to be set without affecting the other flags; similarly, '-' unsets a flag. If the field is of a dictionary type, it has to be a ':' separated list of key=value parameters. Values containing ':' special characters must be escaped. 

* `search_flags`: flags passed to [`av_opt_find2`](@ref). I.e. if [`AV_OPT_SEARCH_CHILDREN`](@ref) is passed here, then the option may be set on a child of obj.

### Returns
0 if the value has been set, or an [`AVERROR`](@ref) code in case of error: [`AVERROR_OPTION_NOT_FOUND`](@ref) if no matching option exists [`AVERROR`](@ref)(ERANGE) if the value is out of range [`AVERROR`](@ref)(EINVAL) if the value is not valid
"""
function av_opt_set(obj, name, val, search_flags::Integer)
    ccall((:av_opt_set, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cstring, Cint), obj, name, val, search_flags)
end

function av_opt_set_int(obj, name, val::Int64, search_flags::Integer)
    ccall((:av_opt_set_int, libavutil), Cint, (Ptr{Cvoid}, Cstring, Int64, Cint), obj, name, val, search_flags)
end

function av_opt_set_double(obj, name, val::Cdouble, search_flags::Integer)
    ccall((:av_opt_set_double, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cdouble, Cint), obj, name, val, search_flags)
end

function av_opt_set_q(obj, name, val::AVRational, search_flags::Integer)
    ccall((:av_opt_set_q, libavutil), Cint, (Ptr{Cvoid}, Cstring, AVRational, Cint), obj, name, val, search_flags)
end

function av_opt_set_image_size(obj, name, w::Integer, h::Integer, search_flags::Integer)
    ccall((:av_opt_set_image_size, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Cint, Cint), obj, name, w, h, search_flags)
end

function av_opt_set_pixel_fmt(obj, name, fmt::AVPixelFormat, search_flags::Integer)
    ccall((:av_opt_set_pixel_fmt, libavutil), Cint, (Ptr{Cvoid}, Cstring, AVPixelFormat, Cint), obj, name, fmt, search_flags)
end

function av_opt_set_sample_fmt(obj, name, fmt::AVSampleFormat, search_flags::Integer)
    ccall((:av_opt_set_sample_fmt, libavutil), Cint, (Ptr{Cvoid}, Cstring, AVSampleFormat, Cint), obj, name, fmt, search_flags)
end

function av_opt_set_video_rate(obj, name, val::AVRational, search_flags::Integer)
    ccall((:av_opt_set_video_rate, libavutil), Cint, (Ptr{Cvoid}, Cstring, AVRational, Cint), obj, name, val, search_flags)
end

function av_opt_set_channel_layout(obj, name, ch_layout::Int64, search_flags::Integer)
    ccall((:av_opt_set_channel_layout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Int64, Cint), obj, name, ch_layout, search_flags)
end

"""
    av_opt_set_dict_val(obj, name, val, search_flags::Integer)

!!! note

    Any old dictionary present is discarded and replaced with a copy of the new one. The caller still owns val is and responsible for freeing it.
"""
function av_opt_set_dict_val(obj, name, val, search_flags::Integer)
    ccall((:av_opt_set_dict_val, libavutil), Cint, (Ptr{Cvoid}, Cstring, Ptr{AVDictionary}, Cint), obj, name, val, search_flags)
end

"""
    av_opt_get(obj, name, search_flags::Integer, out_val)

` opt_get_funcs Option getting functions`

@{ Those functions get a value of the option with the given name from an object.

!!! note

    the returned string will be [`av_malloc`](@ref)()ed and must be [`av_free`](@ref)()ed by the caller

!!! note

    if [`AV_OPT_ALLOW_NULL`](@ref) is set in search\\_flags in [`av_opt_get`](@ref), and the option is of type AV\\_OPT\\_TYPE\\_STRING, AV\\_OPT\\_TYPE\\_BINARY or AV\\_OPT\\_TYPE\\_DICT and is set to NULL, *out\\_val will be set to NULL instead of an allocated empty string.

### Parameters
* `obj`:\\[in\\] a struct whose first element is a pointer to an [`AVClass`](@ref). 

* `name`:\\[in\\] name of the option to get. 

* `search_flags`:\\[in\\] flags passed to [`av_opt_find2`](@ref). I.e. if [`AV_OPT_SEARCH_CHILDREN`](@ref) is passed here, then the option may be found in a child of obj. 

* `out_val`:\\[out\\] value of the option will be written here 

### Returns
>=0 on success, a negative error code otherwise
"""
function av_opt_get(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Ptr{UInt8}}), obj, name, search_flags, out_val)
end

function av_opt_get_int(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get_int, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Int64}), obj, name, search_flags, out_val)
end

function av_opt_get_double(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get_double, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Cdouble}), obj, name, search_flags, out_val)
end

function av_opt_get_q(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get_q, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{AVRational}), obj, name, search_flags, out_val)
end

function av_opt_get_image_size(obj, name, search_flags::Integer, w_out, h_out)
    ccall((:av_opt_get_image_size, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Cint}, Ptr{Cint}), obj, name, search_flags, w_out, h_out)
end

function av_opt_get_pixel_fmt(obj, name, search_flags::Integer, out_fmt)
    ccall((:av_opt_get_pixel_fmt, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{AVPixelFormat}), obj, name, search_flags, out_fmt)
end

function av_opt_get_sample_fmt(obj, name, search_flags::Integer, out_fmt)
    ccall((:av_opt_get_sample_fmt, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{AVSampleFormat}), obj, name, search_flags, out_fmt)
end

function av_opt_get_video_rate(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get_video_rate, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{AVRational}), obj, name, search_flags, out_val)
end

function av_opt_get_channel_layout(obj, name, search_flags::Integer, ch_layout)
    ccall((:av_opt_get_channel_layout, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Int64}), obj, name, search_flags, ch_layout)
end

"""
    av_opt_get_dict_val(obj, name, search_flags::Integer, out_val)

### Parameters
* `out_val`:\\[out\\] The returned dictionary is a copy of the actual value and must be freed with [`av_dict_free`](@ref)() by the caller
"""
function av_opt_get_dict_val(obj, name, search_flags::Integer, out_val)
    ccall((:av_opt_get_dict_val, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint, Ptr{Ptr{AVDictionary}}), obj, name, search_flags, out_val)
end

"""
    av_opt_ptr(avclass, obj, name)

@}

Gets a pointer to the requested field in a struct. This function allows accessing a struct even when its fields are moved or renamed since the application making the access has been compiled,

### Returns
a pointer to the field, it can be cast to the correct type and read or written to.
"""
function av_opt_ptr(avclass, obj, name)
    ccall((:av_opt_ptr, libavutil), Ptr{Cvoid}, (Ptr{AVClass}, Ptr{Cvoid}, Cstring), avclass, obj, name)
end

"""
    av_opt_freep_ranges(ranges)

Free an [`AVOptionRanges`](@ref) struct and set it to NULL.
"""
function av_opt_freep_ranges(ranges)
    ccall((:av_opt_freep_ranges, libavutil), Cvoid, (Ptr{Ptr{AVOptionRanges}},), ranges)
end

"""
    av_opt_query_ranges(arg1, obj, key, flags::Integer)

Get a list of allowed ranges for the given option.

The returned list may depend on other fields in obj like for example profile.

The result must be freed with [`av_opt_freep_ranges`](@ref).

### Parameters
* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component, 

### Returns
number of compontents returned on success, a negative errro code otherwise

### See also
[`AVOptionRanges`](@ref)
"""
function av_opt_query_ranges(arg1, obj, key, flags::Integer)
    ccall((:av_opt_query_ranges, libavutil), Cint, (Ptr{Ptr{AVOptionRanges}}, Ptr{Cvoid}, Cstring, Cint), arg1, obj, key, flags)
end

"""
    av_opt_copy(dest, src)

Copy options from src object into dest object.

Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object. Original memory allocated for such options is freed unless both src and dest options points to the same memory.

### Parameters
* `dest`: Object to copy from 

* `src`: Object to copy into 

### Returns
0 on success, negative on error
"""
function av_opt_copy(dest, src)
    ccall((:av_opt_copy, libavutil), Cint, (Ptr{Cvoid}, Ptr{Cvoid}), dest, src)
end

"""
    av_opt_query_ranges_default(arg1, obj, key, flags::Integer)

Get a default list of allowed ranges for the given option.

This list is constructed without using the [`AVClass`](@ref).query\\_ranges() callback and can be used as fallback from within the callback.

The result must be freed with av\\_opt\\_free\\_ranges.

### Parameters
* `flags`: is a bitmask of flags, undefined flags should not be set and should be ignored [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) indicates that the obj is a double pointer to a [`AVClass`](@ref) instead of a full instance [`AV_OPT_MULTI_COMPONENT_RANGE`](@ref) indicates that function may return more than one component, 

### Returns
number of compontents returned on success, a negative errro code otherwise

### See also
[`AVOptionRanges`](@ref)
"""
function av_opt_query_ranges_default(arg1, obj, key, flags::Integer)
    ccall((:av_opt_query_ranges_default, libavutil), Cint, (Ptr{Ptr{AVOptionRanges}}, Ptr{Cvoid}, Cstring, Cint), arg1, obj, key, flags)
end

"""
    av_opt_is_set_to_default(obj, o)

Check if given option is set to its default value.

Options o must belong to the obj. This function must not be called to check child's options state. 

### Parameters
* `obj`: [`AVClass`](@ref) object to check option on 

* `o`: option to be checked 

### Returns
>0 when option is set to its default, 0 when option is not set its default, <0 on error

### See also
[`av_opt_is_set_to_default_by_name`](@ref)().
"""
function av_opt_is_set_to_default(obj, o)
    ccall((:av_opt_is_set_to_default, libavutil), Cint, (Ptr{Cvoid}, Ptr{AVOption}), obj, o)
end

"""
    av_opt_is_set_to_default_by_name(obj, name, search_flags::Integer)

Check if given option is set to its default value.

### Parameters
* `obj`: [`AVClass`](@ref) object to check option on 

* `name`: option name 

* `search_flags`: combination of AV\\_OPT\\_SEARCH\\_* 

### Returns
>0 when option is set to its default, 0 when option is not set its default, <0 on error
"""
function av_opt_is_set_to_default_by_name(obj, name, search_flags::Integer)
    ccall((:av_opt_is_set_to_default_by_name, libavutil), Cint, (Ptr{Cvoid}, Cstring, Cint), obj, name, search_flags)
end

"""
    av_opt_serialize(obj, opt_flags::Integer, flags::Integer, buffer, key_val_sep::Cchar, pairs_sep::Cchar)

Serialize object's options.

Create a string containing object's serialized options. Such string may be passed back to [`av_opt_set_from_string`](@ref)() in order to restore option values. A key/value or pairs separator occurring in the serialized value or name string are escaped through the [`av_escape`](@ref)() function.

!!! warning

    Separators cannot be neither '\\' nor '\\0'. They also cannot be the same.

### Parameters
* `obj`:\\[in\\] [`AVClass`](@ref) object to serialize 

* `opt_flags`:\\[in\\] serialize options with all the specified flags set (AV\\_OPT\\_FLAG) 

* `flags`:\\[in\\] combination of AV\\_OPT\\_SERIALIZE\\_* flags 

* `buffer`:\\[out\\] Pointer to buffer that will be allocated with string containg serialized options. Buffer must be freed by the caller when is no longer needed. 

* `key_val_sep`:\\[in\\] character used to separate key from value 

* `pairs_sep`:\\[in\\] character used to separate two pairs from each other 

### Returns
>= 0 on success, negative on error 
"""
function av_opt_serialize(obj, opt_flags::Integer, flags::Integer, buffer, key_val_sep::Cchar, pairs_sep::Cchar)
    ccall((:av_opt_serialize, libavutil), Cint, (Ptr{Cvoid}, Cint, Cint, Ptr{Cstring}, Cchar, Cchar), obj, opt_flags, flags, buffer, key_val_sep, pairs_sep)
end

"""
    av_parse_ratio(q, str, max::Integer, log_offset::Integer, log_ctx)

Parse str and store the parsed ratio in q.

Note that a ratio with infinite (1/0) or negative value is considered valid, so you should check on the returned value if you want to exclude those values.

The undefined value can be expressed using the "0:0" string.

### Parameters
* `q`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the ratio 

* `str`:\\[in\\] the string to parse: it has to be a string in the format num:den, a float number or an expression 

* `max`:\\[in\\] the maximum allowed numerator and denominator 

* `log_offset`:\\[in\\] log level offset which is applied to the log level of log\\_ctx 

* `log_ctx`:\\[in\\] parent logging context 

### Returns
>= 0 on success, a negative error code otherwise
"""
function av_parse_ratio(q, str, max::Integer, log_offset::Integer, log_ctx)
    ccall((:av_parse_ratio, libavutil), Cint, (Ptr{AVRational}, Cstring, Cint, Cint, Ptr{Cvoid}), q, str, max, log_offset, log_ctx)
end

"""
    av_parse_video_size(width_ptr, height_ptr, str)

Parse str and put in width\\_ptr and height\\_ptr the detected values.

### Parameters
* `width_ptr`:\\[in,out\\] pointer to the variable which will contain the detected width value 

* `height_ptr`:\\[in,out\\] pointer to the variable which will contain the detected height value 

* `str`:\\[in\\] the string to parse: it has to be a string in the format width x height or a valid video size abbreviation. 

### Returns
>= 0 on success, a negative error code otherwise
"""
function av_parse_video_size(width_ptr, height_ptr, str)
    ccall((:av_parse_video_size, libavutil), Cint, (Ptr{Cint}, Ptr{Cint}, Cstring), width_ptr, height_ptr, str)
end

"""
    av_parse_video_rate(rate, str)

Parse str and store the detected values in *rate.

### Parameters
* `rate`:\\[in,out\\] pointer to the [`AVRational`](@ref) which will contain the detected frame rate 

* `str`:\\[in\\] the string to parse: it has to be a string in the format rate\\_num / rate\\_den, a float number or a valid video rate abbreviation 

### Returns
>= 0 on success, a negative error code otherwise
"""
function av_parse_video_rate(rate, str)
    ccall((:av_parse_video_rate, libavutil), Cint, (Ptr{AVRational}, Cstring), rate, str)
end

"""
    av_parse_color(rgba_color, color_string, slen::Integer, log_ctx)

Put the RGBA values that correspond to color\\_string in rgba\\_color.

### Parameters
* `color_string`: a string specifying a color. It can be the name of a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence, possibly followed by "" and a string representing the alpha component. The alpha component may be a string composed by "0x" followed by an hexadecimal number or a decimal number between 0.0 and 1.0, which represents the opacity value (0x00/0.0 means completely transparent, 0xff/1.0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string "random" will result in a random color. 

* `slen`: length of the initial part of color\\_string containing the color. It can be set to -1 if color\\_string is a null terminated string containing nothing else than the color. 

### Returns
>= 0 in case of success, a negative value in case of failure (for example if color\\_string cannot be parsed).
"""
function av_parse_color(rgba_color, color_string, slen::Integer, log_ctx)
    ccall((:av_parse_color, libavutil), Cint, (Ptr{UInt8}, Cstring, Cint, Ptr{Cvoid}), rgba_color, color_string, slen, log_ctx)
end

"""
    av_get_known_color_name(color_idx::Integer, rgb)

Get the name of a color from the internal table of hard-coded named colors.

This function is meant to enumerate the color names recognized by [`av_parse_color`](@ref)().

### Parameters
* `color_idx`: index of the requested color, starting from 0 

* `rgbp`: if not NULL, will point to a 3-elements array with the color value in RGB 

### Returns
the color name string or NULL if color\\_idx is not in the array
"""
function av_get_known_color_name(color_idx::Integer, rgb)
    ccall((:av_get_known_color_name, libavutil), Cstring, (Cint, Ptr{Ptr{UInt8}}), color_idx, rgb)
end

"""
    av_parse_time(timeval, timestr, duration::Integer)

Parse timestr and return in *time a corresponding number of microseconds.

```c++
 [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]
 now
```

If the value is "now" it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as UTC. If the year-month-day part is not specified it takes the current year-month-day. - If a duration the syntax is: 

```c++
 [-][HH:]MM:SS[.m...]
 [-]S+[.m...]
```

### Parameters
* `timeval`: puts here the number of microseconds corresponding to the string in timestr. If the string represents a duration, it is the number of microseconds contained in the time interval. If the string is a date, is the number of microseconds since 1st of January, 1970 up to the time of the parsed date. If timestr cannot be successfully parsed, set *time to INT64\\_MIN.

* `timestr`: a string representing a date or a duration. - If a date the syntax is: 

* `duration`: flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date 

### Returns
>= 0 in case of success, a negative value corresponding to an [`AVERROR`](@ref) code otherwise
"""
function av_parse_time(timeval, timestr, duration::Integer)
    ccall((:av_parse_time, libavutil), Cint, (Ptr{Int64}, Cstring, Cint), timeval, timestr, duration)
end

"""
    av_find_info_tag(arg, arg_size::Integer, tag1, info)

Attempt to find a specific tag in a URL.

syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done. Return 1 if found.
"""
function av_find_info_tag(arg, arg_size::Integer, tag1, info)
    ccall((:av_find_info_tag, libavutil), Cint, (Cstring, Cint, Cstring, Cstring), arg, arg_size, tag1, info)
end

"""
    av_small_strptime(p, fmt, dt)

Simplified version of strptime

Parse the input string p according to the format string fmt and store its results in the structure dt. This implementation supports only a subset of the formats supported by the standard strptime().

The supported input field descriptors are listed below. - H: the hour as a decimal number, using a 24-hour clock, in the range '00' through '23' - J: hours as a decimal number, in the range '0' through INT\\_MAX - M: the minute as a decimal number, using a 24-hour clock, in the range '00' through '59' - S: the second as a decimal number, using a 24-hour clock, in the range '00' through '59' - Y: the year as a decimal number, using the Gregorian calendar - m: the month as a decimal number, in the range '1' through '12' - d: the day of the month as a decimal number, in the range '1' through '31' - T: alias for 'H:M:S' - %%: a literal '%'

### Returns
a pointer to the first character not processed in this function call. In case the input string contains more characters than required by the format string the return value points right after the last consumed input character. In case the whole input string is consumed the return value points to the null byte at the end of the string. On failure NULL is returned.
"""
function av_small_strptime(p, fmt, dt)
    ccall((:av_small_strptime, libavutil), Cstring, (Cstring, Cstring, Ptr{tm}), p, fmt, dt)
end

"""
    av_timegm(tm_)

Convert the decomposed UTC time in [`tm`](@ref) to a time\\_t value.
"""
function av_timegm(tm_)
    ccall((:av_timegm, libavutil), time_t, (Ptr{tm},), tm_)
end

"""
    av_get_bits_per_pixel(pixdesc)

Return the number of bits per pixel used by the pixel format described by pixdesc. Note that this is not the same as the number of bits per sample.

The returned number of bits refers to the number of bits actually used for storing the pixel information, that is padding bits are not counted.
"""
function av_get_bits_per_pixel(pixdesc)
    ccall((:av_get_bits_per_pixel, libavutil), Cint, (Ptr{AVPixFmtDescriptor},), pixdesc)
end

"""
    av_get_padded_bits_per_pixel(pixdesc)

Return the number of bits per pixel for the pixel format described by pixdesc, including any padding or unused bits.
"""
function av_get_padded_bits_per_pixel(pixdesc)
    ccall((:av_get_padded_bits_per_pixel, libavutil), Cint, (Ptr{AVPixFmtDescriptor},), pixdesc)
end

"""
    av_pix_fmt_desc_get(pix_fmt::AVPixelFormat)

### Returns
a pixel format descriptor for provided pixel format or NULL if this pixel format is unknown.
"""
function av_pix_fmt_desc_get(pix_fmt::AVPixelFormat)
    ccall((:av_pix_fmt_desc_get, libavutil), Ptr{AVPixFmtDescriptor}, (AVPixelFormat,), pix_fmt)
end

"""
    av_pix_fmt_desc_next(prev)

Iterate over all pixel format descriptors known to libavutil.

### Parameters
* `prev`: previous descriptor. NULL to get the first descriptor.

### Returns
next descriptor or NULL after the last descriptor
"""
function av_pix_fmt_desc_next(prev)
    ccall((:av_pix_fmt_desc_next, libavutil), Ptr{AVPixFmtDescriptor}, (Ptr{AVPixFmtDescriptor},), prev)
end

"""
    av_pix_fmt_desc_get_id(desc)

### Returns
an [`AVPixelFormat`](@ref) id described by desc, or AV\\_PIX\\_FMT\\_NONE if desc is not a valid pointer to a pixel format descriptor.
"""
function av_pix_fmt_desc_get_id(desc)
    ccall((:av_pix_fmt_desc_get_id, libavutil), AVPixelFormat, (Ptr{AVPixFmtDescriptor},), desc)
end

"""
    av_pix_fmt_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)

Utility function to access log2\\_chroma\\_w log2\\_chroma\\_h from the pixel format [`AVPixFmtDescriptor`](@ref).

### Parameters
* `pix_fmt`:\\[in\\] the pixel format 

* `h_shift`:\\[out\\] store log2\\_chroma\\_w (horizontal/width shift) 

* `v_shift`:\\[out\\] store log2\\_chroma\\_h (vertical/height shift)

### Returns
0 on success, [`AVERROR`](@ref)(ENOSYS) on invalid or unknown pixel format
"""
function av_pix_fmt_get_chroma_sub_sample(pix_fmt::AVPixelFormat, h_shift, v_shift)
    ccall((:av_pix_fmt_get_chroma_sub_sample, libavutil), Cint, (AVPixelFormat, Ptr{Cint}, Ptr{Cint}), pix_fmt, h_shift, v_shift)
end

"""
    av_pix_fmt_count_planes(pix_fmt::AVPixelFormat)

### Returns
number of planes in pix\\_fmt, a negative [`AVERROR`](@ref) if pix\\_fmt is not a valid pixel format.
"""
function av_pix_fmt_count_planes(pix_fmt::AVPixelFormat)
    ccall((:av_pix_fmt_count_planes, libavutil), Cint, (AVPixelFormat,), pix_fmt)
end

"""
    av_color_range_name(range::AVColorRange)

### Returns
the name for provided color range or NULL if unknown.
"""
function av_color_range_name(range::AVColorRange)
    ccall((:av_color_range_name, libavutil), Cstring, (AVColorRange,), range)
end

"""
    av_color_range_from_name(name)

### Returns
the [`AVColorRange`](@ref) value for name or an AVError if not found.
"""
function av_color_range_from_name(name)
    ccall((:av_color_range_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    av_color_primaries_name(primaries::AVColorPrimaries)

### Returns
the name for provided color primaries or NULL if unknown.
"""
function av_color_primaries_name(primaries::AVColorPrimaries)
    ccall((:av_color_primaries_name, libavutil), Cstring, (AVColorPrimaries,), primaries)
end

"""
    av_color_primaries_from_name(name)

### Returns
the [`AVColorPrimaries`](@ref) value for name or an AVError if not found.
"""
function av_color_primaries_from_name(name)
    ccall((:av_color_primaries_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    av_color_transfer_name(transfer::AVColorTransferCharacteristic)

### Returns
the name for provided color transfer or NULL if unknown.
"""
function av_color_transfer_name(transfer::AVColorTransferCharacteristic)
    ccall((:av_color_transfer_name, libavutil), Cstring, (AVColorTransferCharacteristic,), transfer)
end

"""
    av_color_transfer_from_name(name)

### Returns
the [`AVColorTransferCharacteristic`](@ref) value for name or an AVError if not found.
"""
function av_color_transfer_from_name(name)
    ccall((:av_color_transfer_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    av_color_space_name(space::AVColorSpace)

### Returns
the name for provided color space or NULL if unknown.
"""
function av_color_space_name(space::AVColorSpace)
    ccall((:av_color_space_name, libavutil), Cstring, (AVColorSpace,), space)
end

"""
    av_color_space_from_name(name)

### Returns
the [`AVColorSpace`](@ref) value for name or an AVError if not found.
"""
function av_color_space_from_name(name)
    ccall((:av_color_space_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    av_chroma_location_name(location::AVChromaLocation)

### Returns
the name for provided chroma location or NULL if unknown.
"""
function av_chroma_location_name(location::AVChromaLocation)
    ccall((:av_chroma_location_name, libavutil), Cstring, (AVChromaLocation,), location)
end

"""
    av_chroma_location_from_name(name)

### Returns
the [`AVChromaLocation`](@ref) value for name or an AVError if not found.
"""
function av_chroma_location_from_name(name)
    ccall((:av_chroma_location_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    av_get_pix_fmt(name)

Return the pixel format corresponding to name.

If there is no pixel format with name name, then looks for a pixel format with the name corresponding to the native endian format of name. For example in a little-endian system, first looks for "gray16", then for "gray16le".

Finally if no pixel format has been found, returns AV\\_PIX\\_FMT\\_NONE.
"""
function av_get_pix_fmt(name)
    ccall((:av_get_pix_fmt, libavutil), AVPixelFormat, (Cstring,), name)
end

"""
    av_get_pix_fmt_name(pix_fmt::AVPixelFormat)

Return the short name for a pixel format, NULL in case pix\\_fmt is unknown.

### See also
[`av_get_pix_fmt`](@ref)(), [`av_get_pix_fmt_string`](@ref)()
"""
function av_get_pix_fmt_name(pix_fmt::AVPixelFormat)
    ccall((:av_get_pix_fmt_name, libavutil), Cstring, (AVPixelFormat,), pix_fmt)
end

"""
    av_get_pix_fmt_string(buf, buf_size::Integer, pix_fmt::AVPixelFormat)

Print in buf the string corresponding to the pixel format with number pix\\_fmt, or a header if pix\\_fmt is negative.

### Parameters
* `buf`: the buffer where to write the string 

* `buf_size`: the size of buf 

* `pix_fmt`: the number of the pixel format to print the corresponding info string, or a negative value to print the corresponding header.
"""
function av_get_pix_fmt_string(buf, buf_size::Integer, pix_fmt::AVPixelFormat)
    ccall((:av_get_pix_fmt_string, libavutil), Cstring, (Cstring, Cint, AVPixelFormat), buf, buf_size, pix_fmt)
end

"""
    av_read_image_line2(dst, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, read_pal_component::Integer, dst_element_size::Integer)

Read a line from an image, and write the values of the pixel format component c to dst.

### Parameters
* `data`: the array containing the pointers to the planes of the image 

* `linesize`: the array containing the linesizes of the image 

* `desc`: the pixel format descriptor for the image 

* `x`: the horizontal coordinate of the first pixel to read 

* `y`: the vertical coordinate of the first pixel to read 

* `w`: the width of the line to read, that is the number of values to write to dst 

* `read_pal_component`: if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]. The behavior is undefined if the format is not paletted. 

* `dst_element_size`: size of elements in dst array (2 or 4 byte)
"""
function av_read_image_line2(dst, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, read_pal_component::Integer, dst_element_size::Integer)
    ccall((:av_read_image_line2, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}, Cint, Cint, Cint, Cint, Cint, Cint), dst, data, linesize, desc, x, y, c, w, read_pal_component, dst_element_size)
end

function av_read_image_line(dst, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, read_pal_component::Integer)
    ccall((:av_read_image_line, libavutil), Cvoid, (Ptr{UInt16}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}, Cint, Cint, Cint, Cint, Cint), dst, data, linesize, desc, x, y, c, w, read_pal_component)
end

"""
    av_write_image_line2(src, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, src_element_size::Integer)

Write the values from src to the pixel format component c of an image line.

### Parameters
* `src`: array containing the values to write 

* `data`: the array containing the pointers to the planes of the image to write into. It is supposed to be zeroed. 

* `linesize`: the array containing the linesizes of the image 

* `desc`: the pixel format descriptor for the image 

* `x`: the horizontal coordinate of the first pixel to write 

* `y`: the vertical coordinate of the first pixel to write 

* `w`: the width of the line to write, that is the number of values to write to the image line 

* `src_element_size`: size of elements in src array (2 or 4 byte)
"""
function av_write_image_line2(src, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer, src_element_size::Integer)
    ccall((:av_write_image_line2, libavutil), Cvoid, (Ptr{Cvoid}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}, Cint, Cint, Cint, Cint, Cint), src, data, linesize, desc, x, y, c, w, src_element_size)
end

function av_write_image_line(src, data, linesize, desc, x::Integer, y::Integer, c::Integer, w::Integer)
    ccall((:av_write_image_line, libavutil), Cvoid, (Ptr{UInt16}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{AVPixFmtDescriptor}, Cint, Cint, Cint, Cint), src, data, linesize, desc, x, y, c, w)
end

"""
    av_pix_fmt_swap_endianness(pix_fmt::AVPixelFormat)

Utility function to swap the endianness of a pixel format.

### Parameters
* `pix_fmt`:\\[in\\] the pixel format

### Returns
pixel format with swapped endianness if it exists, otherwise AV\\_PIX\\_FMT\\_NONE
"""
function av_pix_fmt_swap_endianness(pix_fmt::AVPixelFormat)
    ccall((:av_pix_fmt_swap_endianness, libavutil), AVPixelFormat, (AVPixelFormat,), pix_fmt)
end

"""
    av_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)

Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av\\_get\\_fix\\_fmt\\_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.

### Parameters
* `dst_pix_fmt`:\\[in\\] destination pixel format 

* `src_pix_fmt`:\\[in\\] source pixel format 

* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 

### Returns
Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst\\_pix\\_fmt).
"""
function av_get_pix_fmt_loss(dst_pix_fmt::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer)
    ccall((:av_get_pix_fmt_loss, libavutil), Cint, (AVPixelFormat, AVPixelFormat, Cint), dst_pix_fmt, src_pix_fmt, has_alpha)
end

"""
    av_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)

Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av\\_get\\_fix\\_fmt\\_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.

### Parameters
* `dst_pix_fmt`:\\[in\\] destination pixel format 

* `src_pix_fmt`:\\[in\\] source pixel format 

* `has_alpha`:\\[in\\] Whether the source pixel format alpha channel is used. 

### Returns
Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst\\_pix\\_fmt).
"""
function av_find_best_pix_fmt_of_2(dst_pix_fmt1::AVPixelFormat, dst_pix_fmt2::AVPixelFormat, src_pix_fmt::AVPixelFormat, has_alpha::Integer, loss_ptr)
    ccall((:av_find_best_pix_fmt_of_2, libavutil), AVPixelFormat, (AVPixelFormat, AVPixelFormat, AVPixelFormat, Cint, Ptr{Cint}), dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr)
end

# typedef int ( * av_pixelutils_sad_fn ) ( const uint8_t * src1 , ptrdiff_t stride1 , const uint8_t * src2 , ptrdiff_t stride2 )
"""
Sum of abs(src1[x] - src2[x])
"""
const av_pixelutils_sad_fn = Ptr{Cvoid}

"""
    av_pixelutils_get_sad_fn(w_bits::Integer, h_bits::Integer, aligned::Integer, log_ctx)

Get a potentially optimized pointer to a Sum-of-absolute-differences function (see the [`av_pixelutils_sad_fn`](@ref) prototype).

### Parameters
* `w_bits`: 1<<w\\_bits is the requested width of the block size 

* `h_bits`: 1<<h\\_bits is the requested height of the block size 

* `aligned`: If set to 2, the returned sad function will assume src1 and src2 addresses are aligned on the block size. If set to 1, the returned sad function will assume src1 is aligned on the block size. If set to 0, the returned sad function assume no particular alignment. 

* `log_ctx`: context used for logging, can be NULL

### Returns
a pointer to the SAD function or NULL in case of error (because of invalid parameters)
"""
function av_pixelutils_get_sad_fn(w_bits::Integer, h_bits::Integer, aligned::Integer, log_ctx)
    ccall((:av_pixelutils_get_sad_fn, libavutil), av_pixelutils_sad_fn, (Cint, Cint, Cint, Ptr{Cvoid}), w_bits, h_bits, aligned, log_ctx)
end

"""
    av_get_random_seed()

Get a seed to use in conjunction with random functions. This function tries to provide a good seed at a best effort bases. Its possible to call this function multiple times if more bits are needed. It can be quite slow, which is why it should only be used as seed for a faster PRNG. The quality of the seed depends on the platform.
"""
function av_get_random_seed()
    ccall((:av_get_random_seed, libavutil), UInt32, ())
end

"""
    av_make_q(num::Integer, den::Integer)

Create an [`AVRational`](@ref).

Useful for compilers that do not support compound literals.

!!! note

    The return value is not reduced. 

### See also
[`av_reduce`](@ref)()
"""
function av_make_q(num::Integer, den::Integer)
    ccall((:av_make_q, libavutil), AVRational, (Cint, Cint), num, den)
end

"""
    av_cmp_q(a::AVRational, b::AVRational)

Compare two rationals.

### Parameters
* `a`: First rational 

* `b`: Second rational

### Returns
One of the following values: - 0 if `a == b` - 1 if `a > b` - -1 if `a < b` - `INT_MIN` if one of the values is of the form `0 / 0`
"""
function av_cmp_q(a::AVRational, b::AVRational)
    ccall((:av_cmp_q, libavutil), Cint, (AVRational, AVRational), a, b)
end

"""
    av_q2d(a::AVRational)

Convert an [`AVRational`](@ref) to a `double`. 

### Parameters
* `a`: [`AVRational`](@ref) to convert 

### Returns
`a` in floating-point form 

### See also
[`av_d2q`](@ref)()
"""
function av_q2d(a::AVRational)
    ccall((:av_q2d, libavutil), Cdouble, (AVRational,), a)
end

"""
    av_reduce(dst_num, dst_den, num::Int64, den::Int64, max::Int64)

Reduce a fraction.

This is useful for framerate calculations.

### Parameters
* `dst_num`:\\[out\\] Destination numerator 

* `dst_den`:\\[out\\] Destination denominator 

* `num`:\\[in\\] Source numerator 

* `den`:\\[in\\] Source denominator 

* `max`:\\[in\\] Maximum allowed values for `dst_num` & `dst_den` 

### Returns
1 if the operation is exact, 0 otherwise
"""
function av_reduce(dst_num, dst_den, num::Int64, den::Int64, max::Int64)
    ccall((:av_reduce, libavutil), Cint, (Ptr{Cint}, Ptr{Cint}, Int64, Int64, Int64), dst_num, dst_den, num, den, max)
end

"""
    av_mul_q(b::AVRational, c::AVRational)

Multiply two rationals. 

### Parameters
* `b`: First rational 

* `c`: Second rational 

### Returns
b*c
"""
function av_mul_q(b::AVRational, c::AVRational)
    ccall((:av_mul_q, libavutil), AVRational, (AVRational, AVRational), b, c)
end

"""
    av_div_q(b::AVRational, c::AVRational)

Divide one rational by another. 

### Parameters
* `b`: First rational 

* `c`: Second rational 

### Returns
b/c
"""
function av_div_q(b::AVRational, c::AVRational)
    ccall((:av_div_q, libavutil), AVRational, (AVRational, AVRational), b, c)
end

"""
    av_add_q(b::AVRational, c::AVRational)

Add two rationals. 

### Parameters
* `b`: First rational 

* `c`: Second rational 

### Returns
b+c
"""
function av_add_q(b::AVRational, c::AVRational)
    ccall((:av_add_q, libavutil), AVRational, (AVRational, AVRational), b, c)
end

"""
    av_sub_q(b::AVRational, c::AVRational)

Subtract one rational from another. 

### Parameters
* `b`: First rational 

* `c`: Second rational 

### Returns
b-c
"""
function av_sub_q(b::AVRational, c::AVRational)
    ccall((:av_sub_q, libavutil), AVRational, (AVRational, AVRational), b, c)
end

"""
    av_inv_q(q::AVRational)

Invert a rational. 

### Parameters
* `q`: value 

### Returns
1 / q
"""
function av_inv_q(q::AVRational)
    ccall((:av_inv_q, libavutil), AVRational, (AVRational,), q)
end

"""
    av_d2q(d::Cdouble, max::Integer)

Convert a double precision floating point number to a rational.

In case of infinity, the returned value is expressed as `{1, 0}` or `{-1, 0}` depending on the sign.

### Parameters
* `d`: `double` to convert 

* `max`: Maximum allowed numerator and denominator 

### Returns
`d` in [`AVRational`](@ref) form 

### See also
[`av_q2d`](@ref)()
"""
function av_d2q(d::Cdouble, max::Integer)
    ccall((:av_d2q, libavutil), AVRational, (Cdouble, Cint), d, max)
end

"""
    av_nearer_q(q::AVRational, q1::AVRational, q2::AVRational)

Find which of the two rationals is closer to another rational.

### Parameters
* `q`: Rational to be compared against 

* `q1,q2`: Rationals to be tested 

### Returns
One of the following values: - 1 if `q1` is nearer to `q` than `q2` - -1 if `q2` is nearer to `q` than `q1` - 0 if they have the same distance
"""
function av_nearer_q(q::AVRational, q1::AVRational, q2::AVRational)
    ccall((:av_nearer_q, libavutil), Cint, (AVRational, AVRational, AVRational), q, q1, q2)
end

"""
    av_find_nearest_q_idx(q::AVRational, q_list)

Find the value in a list of rationals nearest a given reference rational.

### Parameters
* `q`: Reference rational 

* `q_list`: Array of rationals terminated by `{0, 0}` 

### Returns
Index of the nearest value found in the array
"""
function av_find_nearest_q_idx(q::AVRational, q_list)
    ccall((:av_find_nearest_q_idx, libavutil), Cint, (AVRational, Ptr{AVRational}), q, q_list)
end

"""
    av_q2intfloat(q::AVRational)

Convert an [`AVRational`](@ref) to a IEEE 32-bit `float` expressed in fixed-point format.

!!! note

    The returned value is platform-indepedant.

### Parameters
* `q`: Rational to be converted 

### Returns
Equivalent floating-point value, expressed as an unsigned 32-bit integer. 
"""
function av_q2intfloat(q::AVRational)
    ccall((:av_q2intfloat, libavutil), UInt32, (AVRational,), q)
end

"""
    av_gcd_q(a::AVRational, b::AVRational, max_den::Integer, def::AVRational)

Return the best rational so that a and b are multiple of it. If the resulting denominator is larger than max\\_den, return def.
"""
function av_gcd_q(a::AVRational, b::AVRational, max_den::Integer, def::AVRational)
    ccall((:av_gcd_q, libavutil), AVRational, (AVRational, AVRational, Cint, AVRational), a, b, max_den, def)
end

"""
    AVRC4

` lavu_rc4 RC4`

` lavu_crypto`

@{
"""
struct AVRC4
    state::NTuple{256, UInt8}
    x::Cint
    y::Cint
end

"""
    av_rc4_alloc()

Allocate an [`AVRC4`](@ref) context.
"""
function av_rc4_alloc()
    ccall((:av_rc4_alloc, libavutil), Ptr{AVRC4}, ())
end

"""
    av_rc4_init(d, key, key_bits::Integer, decrypt::Integer)

Initializes an [`AVRC4`](@ref) context.

### Parameters
* `key_bits`: must be a multiple of 8 

* `decrypt`: 0 for encryption, 1 for decryption, currently has no effect 

### Returns
zero on success, negative value otherwise
"""
function av_rc4_init(d, key, key_bits::Integer, decrypt::Integer)
    ccall((:av_rc4_init, libavutil), Cint, (Ptr{AVRC4}, Ptr{UInt8}, Cint, Cint), d, key, key_bits, decrypt)
end

"""
    av_rc4_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)

Encrypts / decrypts using the RC4 algorithm.

### Parameters
* `count`: number of bytes 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst, may be NULL 

* `iv`: not (yet) used for RC4, should be NULL 

* `decrypt`: 0 for encryption, 1 for decryption, not (yet) used
"""
function av_rc4_crypt(d, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_rc4_crypt, libavutil), Cvoid, (Ptr{AVRC4}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), d, dst, src, count, iv, decrypt)
end

"""
    AVReplayGain

ReplayGain information (see http://wiki.hydrogenaudio.org/index.php?title=ReplayGain\\_1.0\\_specification). The size of this struct is a part of the public ABI.
"""
struct AVReplayGain
    track_gain::Int32
    track_peak::UInt32
    album_gain::Int32
    album_peak::UInt32
end

mutable struct AVRIPEMD end

"""
    av_ripemd_alloc()

Allocate an [`AVRIPEMD`](@ref) context.
"""
function av_ripemd_alloc()
    ccall((:av_ripemd_alloc, libavutil), Ptr{AVRIPEMD}, ())
end

"""
    av_ripemd_init(context, bits::Integer)

Initialize RIPEMD hashing.

### Parameters
* `context`: pointer to the function context (of size av\\_ripemd\\_size) 

* `bits`: number of bits in digest (128, 160, 256 or 320 bits) 

### Returns
zero if initialization succeeded, -1 otherwise
"""
function av_ripemd_init(context, bits::Integer)
    ccall((:av_ripemd_init, libavutil), Cint, (Ptr{AVRIPEMD}, Cint), context, bits)
end

function av_ripemd_update(context, data, len::Integer)
    ccall((:av_ripemd_update, libavutil), Cvoid, (Ptr{AVRIPEMD}, Ptr{UInt8}, Cuint), context, data, len)
end

"""
    av_ripemd_final(context, digest)

Finish hashing and output digest value.

### Parameters
* `context`: hash function context 

* `digest`: buffer where output digest value is stored
"""
function av_ripemd_final(context, digest)
    ccall((:av_ripemd_final, libavutil), Cvoid, (Ptr{AVRIPEMD}, Ptr{UInt8}), context, digest)
end

"""
    av_get_sample_fmt_name(sample_fmt::AVSampleFormat)

Return the name of sample\\_fmt, or NULL if sample\\_fmt is not recognized.
"""
function av_get_sample_fmt_name(sample_fmt::AVSampleFormat)
    ccall((:av_get_sample_fmt_name, libavutil), Cstring, (AVSampleFormat,), sample_fmt)
end

"""
    av_get_sample_fmt(name)

Return a sample format corresponding to name, or AV\\_SAMPLE\\_FMT\\_NONE on error.
"""
function av_get_sample_fmt(name)
    ccall((:av_get_sample_fmt, libavutil), AVSampleFormat, (Cstring,), name)
end

"""
    av_get_alt_sample_fmt(sample_fmt::AVSampleFormat, planar::Integer)

Return the planar<->packed alternative form of the given sample format, or AV\\_SAMPLE\\_FMT\\_NONE on error. If the passed sample\\_fmt is already in the requested planar/packed format, the format returned is the same as the input.
"""
function av_get_alt_sample_fmt(sample_fmt::AVSampleFormat, planar::Integer)
    ccall((:av_get_alt_sample_fmt, libavutil), AVSampleFormat, (AVSampleFormat, Cint), sample_fmt, planar)
end

"""
    av_get_packed_sample_fmt(sample_fmt::AVSampleFormat)

Get the packed alternative form of the given sample format.

If the passed sample\\_fmt is already in packed format, the format returned is the same as the input.

### Returns
the packed alternative form of the given sample format or AV\\_SAMPLE\\_FMT\\_NONE on error.
"""
function av_get_packed_sample_fmt(sample_fmt::AVSampleFormat)
    ccall((:av_get_packed_sample_fmt, libavutil), AVSampleFormat, (AVSampleFormat,), sample_fmt)
end

"""
    av_get_planar_sample_fmt(sample_fmt::AVSampleFormat)

Get the planar alternative form of the given sample format.

If the passed sample\\_fmt is already in planar format, the format returned is the same as the input.

### Returns
the planar alternative form of the given sample format or AV\\_SAMPLE\\_FMT\\_NONE on error.
"""
function av_get_planar_sample_fmt(sample_fmt::AVSampleFormat)
    ccall((:av_get_planar_sample_fmt, libavutil), AVSampleFormat, (AVSampleFormat,), sample_fmt)
end

"""
    av_get_sample_fmt_string(buf, buf_size::Integer, sample_fmt::AVSampleFormat)

Generate a string corresponding to the sample format with sample\\_fmt, or a header if sample\\_fmt is negative.

### Parameters
* `buf`: the buffer where to write the string 

* `buf_size`: the size of buf 

* `sample_fmt`: the number of the sample format to print the corresponding info string, or a negative value to print the corresponding header. 

### Returns
the pointer to the filled buffer or NULL if sample\\_fmt is unknown or in case of other errors
"""
function av_get_sample_fmt_string(buf, buf_size::Integer, sample_fmt::AVSampleFormat)
    ccall((:av_get_sample_fmt_string, libavutil), Cstring, (Cstring, Cint, AVSampleFormat), buf, buf_size, sample_fmt)
end

"""
    av_get_bytes_per_sample(sample_fmt::AVSampleFormat)

Return number of bytes per sample.

### Parameters
* `sample_fmt`: the sample format 

### Returns
number of bytes per sample or zero if unknown for the given sample format
"""
function av_get_bytes_per_sample(sample_fmt::AVSampleFormat)
    ccall((:av_get_bytes_per_sample, libavutil), Cint, (AVSampleFormat,), sample_fmt)
end

"""
    av_sample_fmt_is_planar(sample_fmt::AVSampleFormat)

Check if the sample format is planar.

### Parameters
* `sample_fmt`: the sample format to inspect 

### Returns
1 if the sample format is planar, 0 if it is interleaved
"""
function av_sample_fmt_is_planar(sample_fmt::AVSampleFormat)
    ccall((:av_sample_fmt_is_planar, libavutil), Cint, (AVSampleFormat,), sample_fmt)
end

"""
    av_samples_get_buffer_size(linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)

Get the required buffer size for the given audio parameters.

### Parameters
* `linesize`:\\[out\\] calculated linesize, may be NULL 

* `nb_channels`: the number of channels 

* `nb_samples`: the number of samples in a single channel 

* `sample_fmt`: the sample format 

* `align`: buffer size alignment (0 = default, 1 = no alignment) 

### Returns
required buffer size, or negative error code on failure
"""
function av_samples_get_buffer_size(linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)
    ccall((:av_samples_get_buffer_size, libavutil), Cint, (Ptr{Cint}, Cint, Cint, AVSampleFormat, Cint), linesize, nb_channels, nb_samples, sample_fmt, align)
end

"""
    av_samples_fill_arrays(audio_data, linesize, buf, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)

Fill plane data pointers and linesize for samples with sample format sample\\_fmt.

The audio\\_data array is filled with the pointers to the samples data planes: for planar, set the start point of each channel's data within the buffer, for packed, set the start point of the entire buffer only.

The value pointed to by linesize is set to the aligned size of each channel's data buffer for planar layout, or to the aligned size of the buffer for all channels for packed layout.

The buffer in buf must be big enough to contain all the samples (use [`av_samples_get_buffer_size`](@ref)() to compute its minimum size), otherwise the audio\\_data pointers will point to invalid data.

\\todo return minimum size in bytes required for the buffer in case of success at the next bump

### Parameters
* `audio_data`:\\[out\\] array to be filled with the pointer for each channel 

* `linesize`:\\[out\\] calculated linesize, may be NULL 

* `buf`: the pointer to a buffer containing the samples 

* `nb_channels`: the number of channels 

* `nb_samples`: the number of samples in a single channel 

* `sample_fmt`: the sample format 

* `align`: buffer size alignment (0 = default, 1 = no alignment) 

### Returns
>=0 on success or a negative error code on failure 

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout.
"""
function av_samples_fill_arrays(audio_data, linesize, buf, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)
    ccall((:av_samples_fill_arrays, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Ptr{UInt8}, Cint, Cint, AVSampleFormat, Cint), audio_data, linesize, buf, nb_channels, nb_samples, sample_fmt, align)
end

"""
    av_samples_alloc(audio_data, linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)

Allocate a samples buffer for nb\\_samples samples, and fill data pointers and linesize accordingly. The allocated samples buffer can be freed by using [`av_freep`](@ref)(&audio\\_data[0]) Allocated data will be initialized to silence.

\\todo return the size of the allocated buffer in case of success at the next bump 

### Parameters
* `audio_data`:\\[out\\] array to be filled with the pointer for each channel 

* `linesize`:\\[out\\] aligned size for audio buffer(s), may be NULL 

* `nb_channels`: number of audio channels 

* `nb_samples`: number of samples per channel 

* `align`: buffer size alignment (0 = default, 1 = no alignment) 

### Returns
>=0 on success or a negative error code on failure 

### See also
enum [`AVSampleFormat`](@ref) The documentation for [`AVSampleFormat`](@ref) describes the data layout., [`av_samples_fill_arrays`](@ref)(), [`av_samples_alloc_array_and_samples`](@ref)()
"""
function av_samples_alloc(audio_data, linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)
    ccall((:av_samples_alloc, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Cint}, Cint, Cint, AVSampleFormat, Cint), audio_data, linesize, nb_channels, nb_samples, sample_fmt, align)
end

"""
    av_samples_alloc_array_and_samples(audio_data, linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)

Allocate a data pointers array, samples buffer for nb\\_samples samples, and fill data pointers and linesize accordingly.

This is the same as [`av_samples_alloc`](@ref)(), but also allocates the data pointers array.

### See also
[`av_samples_alloc`](@ref)()
"""
function av_samples_alloc_array_and_samples(audio_data, linesize, nb_channels::Integer, nb_samples::Integer, sample_fmt::AVSampleFormat, align::Integer)
    ccall((:av_samples_alloc_array_and_samples, libavutil), Cint, (Ptr{Ptr{Ptr{UInt8}}}, Ptr{Cint}, Cint, Cint, AVSampleFormat, Cint), audio_data, linesize, nb_channels, nb_samples, sample_fmt, align)
end

"""
    av_samples_copy(dst, src, dst_offset::Integer, src_offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)

Copy samples from src to dst.

### Parameters
* `dst`: destination array of pointers to data planes 

* `src`: source array of pointers to data planes 

* `dst_offset`: offset in samples at which the data will be written to dst 

* `src_offset`: offset in samples at which the data will be read from src 

* `nb_samples`: number of samples to be copied 

* `nb_channels`: number of audio channels 

* `sample_fmt`: audio sample format
"""
function av_samples_copy(dst, src, dst_offset::Integer, src_offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)
    ccall((:av_samples_copy, libavutil), Cint, (Ptr{Ptr{UInt8}}, Ptr{Ptr{UInt8}}, Cint, Cint, Cint, Cint, AVSampleFormat), dst, src, dst_offset, src_offset, nb_samples, nb_channels, sample_fmt)
end

"""
    av_samples_set_silence(audio_data, offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)

Fill an audio buffer with silence.

### Parameters
* `audio_data`: array of pointers to data planes 

* `offset`: offset in samples at which to start filling 

* `nb_samples`: number of samples to fill 

* `nb_channels`: number of audio channels 

* `sample_fmt`: audio sample format
"""
function av_samples_set_silence(audio_data, offset::Integer, nb_samples::Integer, nb_channels::Integer, sample_fmt::AVSampleFormat)
    ccall((:av_samples_set_silence, libavutil), Cint, (Ptr{Ptr{UInt8}}, Cint, Cint, Cint, AVSampleFormat), audio_data, offset, nb_samples, nb_channels, sample_fmt)
end

mutable struct AVSHA end

"""
    av_sha_alloc()

Allocate an [`AVSHA`](@ref) context.
"""
function av_sha_alloc()
    ccall((:av_sha_alloc, libavutil), Ptr{AVSHA}, ())
end

"""
    av_sha_init(context, bits::Integer)

Initialize SHA-1 or SHA-2 hashing.

### Parameters
* `context`: pointer to the function context (of size av\\_sha\\_size) 

* `bits`: number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits) 

### Returns
zero if initialization succeeded, -1 otherwise
"""
function av_sha_init(context, bits::Integer)
    ccall((:av_sha_init, libavutil), Cint, (Ptr{AVSHA}, Cint), context, bits)
end

function av_sha_update(ctx, data, len::Integer)
    ccall((:av_sha_update, libavutil), Cvoid, (Ptr{AVSHA}, Ptr{UInt8}, Cuint), ctx, data, len)
end

"""
    av_sha_final(context, digest)

Finish hashing and output digest value.

### Parameters
* `context`: hash function context 

* `digest`: buffer where output digest value is stored
"""
function av_sha_final(context, digest)
    ccall((:av_sha_final, libavutil), Cvoid, (Ptr{AVSHA}, Ptr{UInt8}), context, digest)
end

mutable struct AVSHA512 end

"""
    av_sha512_alloc()

Allocate an [`AVSHA512`](@ref) context.
"""
function av_sha512_alloc()
    ccall((:av_sha512_alloc, libavutil), Ptr{AVSHA512}, ())
end

"""
    av_sha512_init(context, bits::Integer)

Initialize SHA-2 512 hashing.

### Parameters
* `context`: pointer to the function context (of size av\\_sha512\\_size) 

* `bits`: number of bits in digest (224, 256, 384 or 512 bits) 

### Returns
zero if initialization succeeded, -1 otherwise
"""
function av_sha512_init(context, bits::Integer)
    ccall((:av_sha512_init, libavutil), Cint, (Ptr{AVSHA512}, Cint), context, bits)
end

function av_sha512_update(context, data, len::Integer)
    ccall((:av_sha512_update, libavutil), Cvoid, (Ptr{AVSHA512}, Ptr{UInt8}, Cuint), context, data, len)
end

"""
    av_sha512_final(context, digest)

Finish hashing and output digest value.

### Parameters
* `context`: hash function context 

* `digest`: buffer where output digest value is stored
"""
function av_sha512_final(context, digest)
    ccall((:av_sha512_final, libavutil), Cvoid, (Ptr{AVSHA512}, Ptr{UInt8}), context, digest)
end

"""
    AVSphericalProjection

Projection of the video surface(s) on a sphere.
"""
const AVSphericalProjection = UInt32
const AV_SPHERICAL_EQUIRECTANGULAR = 0 % UInt32
const AV_SPHERICAL_CUBEMAP = 1 % UInt32
const AV_SPHERICAL_EQUIRECTANGULAR_TILE = 2 % UInt32

"""
    AVSphericalMapping

This structure describes how to handle spherical videos, outlining information about projection, initial layout, and any other view modifier.

!!! note

    The struct must be allocated with [`av_spherical_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVSphericalMapping
    projection::AVSphericalProjection
    yaw::Int32
    pitch::Int32
    roll::Int32
    bound_left::UInt32
    bound_top::UInt32
    bound_right::UInt32
    bound_bottom::UInt32
    padding::UInt32
end

"""
    av_spherical_alloc(size)

Allocate a AVSphericalVideo structure and initialize its fields to default values.

### Returns
the newly allocated struct or NULL on failure
"""
function av_spherical_alloc(size)
    ccall((:av_spherical_alloc, libavutil), Ptr{AVSphericalMapping}, (Ptr{Csize_t},), size)
end

"""
    av_spherical_tile_bounds(map, width::Csize_t, height::Csize_t, left, top, right, bottom)

Convert the bounding fields from an AVSphericalVideo from 0.32 fixed point to pixels.

### Parameters
* `map`: The AVSphericalVideo map to read bound values from. 

* `width`: Width of the current frame or stream. 

* `height`: Height of the current frame or stream. 

* `left`: Pixels from the left edge. 

* `top`: Pixels from the top edge. 

* `right`: Pixels from the right edge. 

* `bottom`: Pixels from the bottom edge.
"""
function av_spherical_tile_bounds(map, width::Csize_t, height::Csize_t, left, top, right, bottom)
    ccall((:av_spherical_tile_bounds, libavutil), Cvoid, (Ptr{AVSphericalMapping}, Csize_t, Csize_t, Ptr{Csize_t}, Ptr{Csize_t}, Ptr{Csize_t}, Ptr{Csize_t}), map, width, height, left, top, right, bottom)
end

"""
    av_spherical_projection_name(projection::AVSphericalProjection)

Provide a human-readable name of a given [`AVSphericalProjection`](@ref).

### Parameters
* `projection`: The input [`AVSphericalProjection`](@ref).

### Returns
The name of the [`AVSphericalProjection`](@ref), or "unknown".
"""
function av_spherical_projection_name(projection::AVSphericalProjection)
    ccall((:av_spherical_projection_name, libavutil), Cstring, (AVSphericalProjection,), projection)
end

"""
    av_spherical_from_name(name)

Get the [`AVSphericalProjection`](@ref) form a human-readable name.

### Parameters
* `name`: The input string.

### Returns
The [`AVSphericalProjection`](@ref) value, or -1 if not found.
"""
function av_spherical_from_name(name)
    ccall((:av_spherical_from_name, libavutil), Cint, (Cstring,), name)
end

"""
    AVStereo3DType

List of possible 3D Types
"""
const AVStereo3DType = UInt32
const AV_STEREO3D_2D = 0 % UInt32
const AV_STEREO3D_SIDEBYSIDE = 1 % UInt32
const AV_STEREO3D_TOPBOTTOM = 2 % UInt32
const AV_STEREO3D_FRAMESEQUENCE = 3 % UInt32
const AV_STEREO3D_CHECKERBOARD = 4 % UInt32
const AV_STEREO3D_SIDEBYSIDE_QUINCUNX = 5 % UInt32
const AV_STEREO3D_LINES = 6 % UInt32
const AV_STEREO3D_COLUMNS = 7 % UInt32

"""
    AVStereo3DView

List of possible view types.
"""
const AVStereo3DView = UInt32
const AV_STEREO3D_VIEW_PACKED = 0 % UInt32
const AV_STEREO3D_VIEW_LEFT = 1 % UInt32
const AV_STEREO3D_VIEW_RIGHT = 2 % UInt32

"""
    AVStereo3D

Stereo 3D type: this structure describes how two videos are packed within a single video surface, with additional information as needed.

!!! note

    The struct must be allocated with [`av_stereo3d_alloc`](@ref)() and its size is not a part of the public ABI.
"""
struct AVStereo3D
    type::AVStereo3DType
    flags::Cint
    view::AVStereo3DView
end

"""
    av_stereo3d_alloc()

Allocate an [`AVStereo3D`](@ref) structure and set its fields to default values. The resulting struct can be freed using [`av_freep`](@ref)().

### Returns
An [`AVStereo3D`](@ref) filled with default values or NULL on failure.
"""
function av_stereo3d_alloc()
    ccall((:av_stereo3d_alloc, libavutil), Ptr{AVStereo3D}, ())
end

"""
    av_stereo3d_create_side_data(frame)

Allocate a complete [`AVFrameSideData`](@ref) and add it to the frame.

### Parameters
* `frame`: The frame which side data is added to.

### Returns
The [`AVStereo3D`](@ref) structure to be filled by caller.
"""
function av_stereo3d_create_side_data(frame)
    ccall((:av_stereo3d_create_side_data, libavutil), Ptr{AVStereo3D}, (Ptr{AVFrame},), frame)
end

"""
    av_stereo3d_type_name(type::Integer)

Provide a human-readable name of a given stereo3d type.

### Parameters
* `type`: The input stereo3d type value.

### Returns
The name of the stereo3d value, or "unknown".
"""
function av_stereo3d_type_name(type::Integer)
    ccall((:av_stereo3d_type_name, libavutil), Cstring, (Cuint,), type)
end

"""
    av_stereo3d_from_name(name)

Get the [`AVStereo3DType`](@ref) form a human-readable name.

### Parameters
* `name`: The input string.

### Returns
The [`AVStereo3DType`](@ref) value, or -1 if not found.
"""
function av_stereo3d_from_name(name)
    ccall((:av_stereo3d_from_name, libavutil), Cint, (Cstring,), name)
end

mutable struct AVTEA end

"""
    av_tea_alloc()

Allocate an [`AVTEA`](@ref) context To free the struct: [`av_free`](@ref)(ptr)
"""
function av_tea_alloc()
    ccall((:av_tea_alloc, libavutil), Ptr{AVTEA}, ())
end

"""
    av_tea_init(ctx, key, rounds::Integer)

Initialize an [`AVTEA`](@ref) context.

### Parameters
* `ctx`: an [`AVTEA`](@ref) context 

* `key`: a key of 16 bytes used for encryption/decryption 

* `rounds`: the number of rounds in TEA (64 is the "standard")
"""
function av_tea_init(ctx, key, rounds::Integer)
    ccall((:av_tea_init, libavutil), Cvoid, (Ptr{AVTEA}, Ptr{UInt8}, Cint), ctx, key, rounds)
end

"""
    av_tea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context.

### Parameters
* `ctx`: an [`AVTEA`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_tea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_tea_crypt, libavutil), Cvoid, (Ptr{AVTEA}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

mutable struct AVThreadMessageQueue end

const AVThreadMessageFlags = UInt32
const AV_THREAD_MESSAGE_NONBLOCK = 1 % UInt32

"""
    av_thread_message_queue_alloc(mq, nelem::Integer, elsize::Integer)

Allocate a new message queue.

### Parameters
* `mq`: pointer to the message queue 

* `nelem`: maximum number of elements in the queue 

* `elsize`: size of each element in the queue 

### Returns
>=0 for success; <0 for error, in particular [`AVERROR`](@ref)(ENOSYS) if lavu was built without thread support
"""
function av_thread_message_queue_alloc(mq, nelem::Integer, elsize::Integer)
    ccall((:av_thread_message_queue_alloc, libavutil), Cint, (Ptr{Ptr{AVThreadMessageQueue}}, Cuint, Cuint), mq, nelem, elsize)
end

"""
    av_thread_message_queue_free(mq)

Free a message queue.

The message queue must no longer be in use by another thread.
"""
function av_thread_message_queue_free(mq)
    ccall((:av_thread_message_queue_free, libavutil), Cvoid, (Ptr{Ptr{AVThreadMessageQueue}},), mq)
end

"""
    av_thread_message_queue_send(mq, msg, flags::Integer)

Send a message on the queue.
"""
function av_thread_message_queue_send(mq, msg, flags::Integer)
    ccall((:av_thread_message_queue_send, libavutil), Cint, (Ptr{AVThreadMessageQueue}, Ptr{Cvoid}, Cuint), mq, msg, flags)
end

"""
    av_thread_message_queue_recv(mq, msg, flags::Integer)

Receive a message from the queue.
"""
function av_thread_message_queue_recv(mq, msg, flags::Integer)
    ccall((:av_thread_message_queue_recv, libavutil), Cint, (Ptr{AVThreadMessageQueue}, Ptr{Cvoid}, Cuint), mq, msg, flags)
end

"""
    av_thread_message_queue_set_err_send(mq, err::Integer)

Set the sending error code.

If the error code is set to non-zero, [`av_thread_message_queue_send`](@ref)() will return it immediately. Conventional values, such as [`AVERROR_EOF`](@ref) or [`AVERROR`](@ref)(EAGAIN), can be used to cause the sending thread to stop or suspend its operation.
"""
function av_thread_message_queue_set_err_send(mq, err::Integer)
    ccall((:av_thread_message_queue_set_err_send, libavutil), Cvoid, (Ptr{AVThreadMessageQueue}, Cint), mq, err)
end

"""
    av_thread_message_queue_set_err_recv(mq, err::Integer)

Set the receiving error code.

If the error code is set to non-zero, [`av_thread_message_queue_recv`](@ref)() will return it immediately when there are no longer available messages. Conventional values, such as [`AVERROR_EOF`](@ref) or [`AVERROR`](@ref)(EAGAIN), can be used to cause the receiving thread to stop or suspend its operation.
"""
function av_thread_message_queue_set_err_recv(mq, err::Integer)
    ccall((:av_thread_message_queue_set_err_recv, libavutil), Cvoid, (Ptr{AVThreadMessageQueue}, Cint), mq, err)
end

"""
    av_thread_message_queue_set_free_func(mq, free_func)

Set the optional free message callback function which will be called if an operation is removing messages from the queue.
"""
function av_thread_message_queue_set_free_func(mq, free_func)
    ccall((:av_thread_message_queue_set_free_func, libavutil), Cvoid, (Ptr{AVThreadMessageQueue}, Ptr{Cvoid}), mq, free_func)
end

"""
    av_thread_message_queue_nb_elems(mq)

Return the current number of messages in the queue.

### Returns
the current number of messages or [`AVERROR`](@ref)(ENOSYS) if lavu was built without thread support
"""
function av_thread_message_queue_nb_elems(mq)
    ccall((:av_thread_message_queue_nb_elems, libavutil), Cint, (Ptr{AVThreadMessageQueue},), mq)
end

"""
    av_thread_message_flush(mq)

Flush the message queue

This function is mostly equivalent to reading and free-ing every message except that it will be done in a single operation (no lock/unlock between reads).
"""
function av_thread_message_flush(mq)
    ccall((:av_thread_message_flush, libavutil), Cvoid, (Ptr{AVThreadMessageQueue},), mq)
end

"""
    av_gettime()

Get the current time in microseconds.
"""
function av_gettime()
    ccall((:av_gettime, libavutil), Int64, ())
end

"""
    av_gettime_relative()

Get the current time in microseconds since some unspecified starting point. On platforms that support it, the time comes from a monotonic clock This property makes this time source ideal for measuring relative time. The returned values may not be monotonic on platforms where a monotonic clock is not available.
"""
function av_gettime_relative()
    ccall((:av_gettime_relative, libavutil), Int64, ())
end

"""
    av_gettime_relative_is_monotonic()

Indicates with a boolean result if the [`av_gettime_relative`](@ref)() time source is monotonic.
"""
function av_gettime_relative_is_monotonic()
    ccall((:av_gettime_relative_is_monotonic, libavutil), Cint, ())
end

"""
    av_usleep(usec::Integer)

Sleep for a period of time. Although the duration is expressed in microseconds, the actual delay may be rounded to the precision of the system timer.

### Parameters
* `usec`: Number of microseconds to sleep. 

### Returns
zero on success or (negative) error code.
"""
function av_usleep(usec::Integer)
    ccall((:av_usleep, libavutil), Cint, (Cuint,), usec)
end

const AVTimecodeFlag = UInt32
const AV_TIMECODE_FLAG_DROPFRAME = 1 % UInt32
const AV_TIMECODE_FLAG_24HOURSMAX = 2 % UInt32
const AV_TIMECODE_FLAG_ALLOWNEGATIVE = 4 % UInt32

struct AVTimecode
    start::Cint
    flags::UInt32
    rate::AVRational
    fps::Cuint
end

"""
    av_timecode_adjust_ntsc_framenum2(framenum::Integer, fps::Integer)

Adjust frame number for NTSC drop frame time code.

!!! warning

    adjustment is only valid for multiples of NTSC 29.97

### Parameters
* `framenum`: frame number to adjust 

* `fps`: frame per second, multiples of 30 

### Returns
adjusted frame number 
"""
function av_timecode_adjust_ntsc_framenum2(framenum::Integer, fps::Integer)
    ccall((:av_timecode_adjust_ntsc_framenum2, libavutil), Cint, (Cint, Cint), framenum, fps)
end

"""
    av_timecode_get_smpte_from_framenum(tc, framenum::Integer)

Convert frame number to SMPTE 12M binary representation.

See SMPTE ST 314M-2005 Sec 4.4.2.2.1 "Time code pack (TC)" the format description as follows: bits 0-5: hours, in BCD(6bits) bits 6: BGF1 bits 7: BGF2 (NTSC) or FIELD (PAL) bits 8-14: minutes, in BCD(7bits) bits 15: BGF0 (NTSC) or BGF2 (PAL) bits 16-22: seconds, in BCD(7bits) bits 23: FIELD (NTSC) or BGF0 (PAL) bits 24-29: frames, in BCD(6bits) bits 30: drop frame flag (0: non drop, 1: drop) bits 31: color frame flag (0: unsync mode, 1: sync mode) 

!!! note

    BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens. 

!!! note

    Frame number adjustment is automatically done in case of drop timecode, you do NOT have to call [`av_timecode_adjust_ntsc_framenum2`](@ref)(). 

!!! note

    The frame number is relative to tc->start. 

!!! note

    Color frame (CF) and binary group flags (BGF) bits are set to zero.

### Parameters
* `tc`: timecode data correctly initialized 

* `framenum`: frame number 

### Returns
the SMPTE binary representation
"""
function av_timecode_get_smpte_from_framenum(tc, framenum::Integer)
    ccall((:av_timecode_get_smpte_from_framenum, libavutil), UInt32, (Ptr{AVTimecode}, Cint), tc, framenum)
end

"""
    av_timecode_get_smpte(rate::AVRational, drop::Integer, hh::Integer, mm::Integer, ss::Integer, ff::Integer)

Convert sei info to SMPTE 12M binary representation.

### Parameters
* `rate`: frame rate in rational form 

* `drop`: drop flag 

* `hh`: hour 

* `mm`: minute 

* `ss`: second 

* `ff`: frame number 

### Returns
the SMPTE binary representation
"""
function av_timecode_get_smpte(rate::AVRational, drop::Integer, hh::Integer, mm::Integer, ss::Integer, ff::Integer)
    ccall((:av_timecode_get_smpte, libavutil), UInt32, (AVRational, Cint, Cint, Cint, Cint, Cint), rate, drop, hh, mm, ss, ff)
end

"""
    av_timecode_make_string(tc, buf, framenum::Integer)

Load timecode string in buf.

!!! note

    Timecode representation can be a negative timecode and have more than 24 hours, but will only be honored if the flags are correctly set. 

!!! note

    The frame number is relative to tc->start.

### Parameters
* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 

* `tc`: timecode data correctly initialized 

* `framenum`: frame number 

### Returns
the buf parameter
"""
function av_timecode_make_string(tc, buf, framenum::Integer)
    ccall((:av_timecode_make_string, libavutil), Cstring, (Ptr{AVTimecode}, Cstring, Cint), tc, buf, framenum)
end

"""
    av_timecode_make_smpte_tc_string2(buf, rate::AVRational, tcsmpte::Integer, prevent_df::Integer, skip_field::Integer)

Get the timecode string from the SMPTE timecode format.

In contrast to [`av_timecode_make_smpte_tc_string`](@ref) this function supports 50/60 fps timecodes by using the field bit.

### Parameters
* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 

* `rate`: frame rate of the timecode 

* `tcsmpte`: the 32-bit SMPTE timecode 

* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary 

* `skip_field`: prevent the use of a field flag when it is known the field bit is arbitrary (e.g. because it is used as PC flag) 

### Returns
the buf parameter
"""
function av_timecode_make_smpte_tc_string2(buf, rate::AVRational, tcsmpte::Integer, prevent_df::Integer, skip_field::Integer)
    ccall((:av_timecode_make_smpte_tc_string2, libavutil), Cstring, (Cstring, AVRational, UInt32, Cint, Cint), buf, rate, tcsmpte, prevent_df, skip_field)
end

"""
    av_timecode_make_smpte_tc_string(buf, tcsmpte::Integer, prevent_df::Integer)

Get the timecode string from the SMPTE timecode format.

### Parameters
* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 

* `tcsmpte`: the 32-bit SMPTE timecode 

* `prevent_df`: prevent the use of a drop flag when it is known the DF bit is arbitrary 

### Returns
the buf parameter
"""
function av_timecode_make_smpte_tc_string(buf, tcsmpte::Integer, prevent_df::Integer)
    ccall((:av_timecode_make_smpte_tc_string, libavutil), Cstring, (Cstring, UInt32, Cint), buf, tcsmpte, prevent_df)
end

"""
    av_timecode_make_mpeg_tc_string(buf, tc25bit::Integer)

Get the timecode string from the 25-bit timecode format (MPEG GOP format).

### Parameters
* `buf`: destination buffer, must be at least [`AV_TIMECODE_STR_SIZE`](@ref) long 

* `tc25bit`: the 25-bits timecode 

### Returns
the buf parameter
"""
function av_timecode_make_mpeg_tc_string(buf, tc25bit::Integer)
    ccall((:av_timecode_make_mpeg_tc_string, libavutil), Cstring, (Cstring, UInt32), buf, tc25bit)
end

"""
    av_timecode_init(tc, rate::AVRational, flags::Integer, frame_start::Integer, log_ctx)

Init a timecode struct with the passed parameters.

### Parameters
* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)) 

* `tc`: pointer to an allocated [`AVTimecode`](@ref) 

* `rate`: frame rate in rational form 

* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref)) 

* `frame_start`: the first frame number 

### Returns
0 on success, [`AVERROR`](@ref) otherwise
"""
function av_timecode_init(tc, rate::AVRational, flags::Integer, frame_start::Integer, log_ctx)
    ccall((:av_timecode_init, libavutil), Cint, (Ptr{AVTimecode}, AVRational, Cint, Cint, Ptr{Cvoid}), tc, rate, flags, frame_start, log_ctx)
end

"""
    av_timecode_init_from_components(tc, rate::AVRational, flags::Integer, hh::Integer, mm::Integer, ss::Integer, ff::Integer, log_ctx)

Init a timecode struct from the passed timecode components.

### Parameters
* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)) 

* `tc`: pointer to an allocated [`AVTimecode`](@ref) 

* `rate`: frame rate in rational form 

* `flags`: miscellaneous flags such as drop frame, +24 hours, ... (see [`AVTimecodeFlag`](@ref)) 

* `hh`: hours 

* `mm`: minutes 

* `ss`: seconds 

* `ff`: frames 

### Returns
0 on success, [`AVERROR`](@ref) otherwise
"""
function av_timecode_init_from_components(tc, rate::AVRational, flags::Integer, hh::Integer, mm::Integer, ss::Integer, ff::Integer, log_ctx)
    ccall((:av_timecode_init_from_components, libavutil), Cint, (Ptr{AVTimecode}, AVRational, Cint, Cint, Cint, Cint, Cint, Ptr{Cvoid}), tc, rate, flags, hh, mm, ss, ff, log_ctx)
end

"""
    av_timecode_init_from_string(tc, rate::AVRational, str, log_ctx)

Parse timecode representation (hh:mm:ss[:;.]ff).

### Parameters
* `log_ctx`: a pointer to an arbitrary struct of which the first field is a pointer to an [`AVClass`](@ref) struct (used for [`av_log`](@ref)). 

* `tc`: pointer to an allocated [`AVTimecode`](@ref) 

* `rate`: frame rate in rational form 

* `str`: timecode string which will determine the frame start 

### Returns
0 on success, [`AVERROR`](@ref) otherwise
"""
function av_timecode_init_from_string(tc, rate::AVRational, str, log_ctx)
    ccall((:av_timecode_init_from_string, libavutil), Cint, (Ptr{AVTimecode}, AVRational, Cstring, Ptr{Cvoid}), tc, rate, str, log_ctx)
end

"""
    av_timecode_check_frame_rate(rate::AVRational)

Check if the timecode feature is available for the given frame rate

### Returns
0 if supported, <0 otherwise
"""
function av_timecode_check_frame_rate(rate::AVRational)
    ccall((:av_timecode_check_frame_rate, libavutil), Cint, (AVRational,), rate)
end

"""
    av_ts_make_string(buf, ts::Int64)

Fill the provided buffer with a string containing a timestamp representation.

### Parameters
* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref) 

* `ts`: the timestamp to represent 

### Returns
the buffer in input
"""
function av_ts_make_string(buf, ts::Int64)
    ccall((:av_ts_make_string, libavutil), Cstring, (Cstring, Int64), buf, ts)
end

"""
    av_ts_make_time_string(buf, ts::Int64, tb)

Fill the provided buffer with a string containing a timestamp time representation.

### Parameters
* `buf`: a buffer with size in bytes of at least [`AV_TS_MAX_STRING_SIZE`](@ref) 

* `ts`: the timestamp to represent 

* `tb`: the timebase of the timestamp 

### Returns
the buffer in input
"""
function av_ts_make_time_string(buf, ts::Int64, tb)
    ccall((:av_ts_make_time_string, libavutil), Cstring, (Cstring, Int64, Ptr{AVRational}), buf, ts, tb)
end

"""
` lavu_tree AVTree`

` lavu_data`

Low-complexity tree container

Insertion, removal, finding equal, largest which is smaller than and smallest which is larger than, all have O(log n) worst-case complexity. @{
"""
mutable struct AVTreeNode end

"""
    av_tree_node_alloc()

Allocate an [`AVTreeNode`](@ref).
"""
function av_tree_node_alloc()
    ccall((:av_tree_node_alloc, libavutil), Ptr{AVTreeNode}, ())
end

"""
    av_tree_find(root, key, cmp, next)

Find an element. 

### Parameters
* `root`: a pointer to the root node of the tree 

* `next`: If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged. 

* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to [`av_tree_find`](@ref)(), thus it could if the user wants, be a different type (like an opaque context). 

### Returns
An element with cmp(key, elem) == 0 or NULL if no such element exists in the tree.
"""
function av_tree_find(root, key, cmp, next)
    ccall((:av_tree_find, libavutil), Ptr{Cvoid}, (Ptr{AVTreeNode}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Ptr{Cvoid}}), root, key, cmp, next)
end

"""
    av_tree_insert(rootp, key, cmp, next)

Insert or remove an element.

If *next is NULL, then the supplied element will be removed if it exists. If *next is non-NULL, then the supplied element will be inserted, unless it already exists in the tree.

```c++
             void *tree_insert(struct AVTreeNode **rootp, void *key,
                               int (*cmp)(void *key, const void *b),
                               AVTreeNode **next)
             {
                 if (!*next)
                     *next = av_mallocz(av_tree_node_size);
                 return av_tree_insert(rootp, key, cmp, next);
             }
             void *tree_remove(struct AVTreeNode **rootp, void *key,
                               int (*cmp)(void *key, const void *b, AVTreeNode **next))
             {
                 av_freep(next);
                 return av_tree_insert(rootp, key, cmp, next);
             }
```

### Parameters
* `rootp`: A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced. 

* `key`: pointer to the element key to insert in the tree 

* `next`: Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av\\_tree\\_node\\_size bytes size. [`av_tree_insert`](@ref)() will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user and [`av_tree_insert`](@ref)() will set it to the [`AVTreeNode`](@ref) which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like: 

* `cmp`: compare function used to compare elements in the tree, API identical to that of Standard C's qsort 

### Returns
If no insertion happened, the found element; if an insertion or removal happened, then either key or NULL will be returned. Which one it is depends on the tree state and the implementation. You should make no assumptions that it's one or the other in the code.
"""
function av_tree_insert(rootp, key, cmp, next)
    ccall((:av_tree_insert, libavutil), Ptr{Cvoid}, (Ptr{Ptr{AVTreeNode}}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Ptr{AVTreeNode}}), rootp, key, cmp, next)
end

function av_tree_destroy(t)
    ccall((:av_tree_destroy, libavutil), Cvoid, (Ptr{AVTreeNode},), t)
end

"""
    av_tree_enumerate(t, opaque, cmp, enu)

Apply enu(opaque, &elem) to all the elements in the tree in a given range.

!!! note

    The cmp function should use the same ordering used to construct the tree.

### Parameters
* `cmp`: a comparison function that returns < 0 for an element below the range, > 0 for an element above the range and == 0 for an element inside the range
"""
function av_tree_enumerate(t, opaque, cmp, enu)
    ccall((:av_tree_enumerate, libavutil), Cvoid, (Ptr{AVTreeNode}, Ptr{Cvoid}, Ptr{Cvoid}, Ptr{Cvoid}), t, opaque, cmp, enu)
end

mutable struct AVTWOFISH end

"""
    av_twofish_alloc()

Allocate an [`AVTWOFISH`](@ref) context To free the struct: [`av_free`](@ref)(ptr)
"""
function av_twofish_alloc()
    ccall((:av_twofish_alloc, libavutil), Ptr{AVTWOFISH}, ())
end

"""
    av_twofish_init(ctx, key, key_bits::Integer)

Initialize an [`AVTWOFISH`](@ref) context.

### Parameters
* `ctx`: an [`AVTWOFISH`](@ref) context 

* `key`: a key of size ranging from 1 to 32 bytes used for encryption/decryption 

* `key_bits`: number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key\\_bits is 128/192/256, -1 if less than 0, 1 otherwise
"""
function av_twofish_init(ctx, key, key_bits::Integer)
    ccall((:av_twofish_init, libavutil), Cint, (Ptr{AVTWOFISH}, Ptr{UInt8}, Cint), ctx, key, key_bits)
end

"""
    av_twofish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context

### Parameters
* `ctx`: an [`AVTWOFISH`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 16 byte blocks 

* `iv`: initialization vector for CBC mode, NULL for ECB mode 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_twofish_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_twofish_crypt, libavutil), Cvoid, (Ptr{AVTWOFISH}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

mutable struct AVTXContext end

struct AVComplexFloat
    re::Cfloat
    im::Cfloat
end

struct AVComplexDouble
    re::Cdouble
    im::Cdouble
end

struct AVComplexInt32
    re::Int32
    im::Int32
end

const AVTXType = UInt32
const AV_TX_FLOAT_FFT = 0 % UInt32
const AV_TX_FLOAT_MDCT = 1 % UInt32
const AV_TX_DOUBLE_FFT = 2 % UInt32
const AV_TX_DOUBLE_MDCT = 3 % UInt32
const AV_TX_INT32_FFT = 4 % UInt32
const AV_TX_INT32_MDCT = 5 % UInt32

# typedef void ( * av_tx_fn ) ( AVTXContext * s , void * out , void * in , ptrdiff_t stride )
"""
Function pointer to a function to perform the transform.

!!! note

    Using a different context than the one allocated during [`av_tx_init`](@ref)() is not allowed.

The out and in arrays must be aligned to the maximum required by the CPU architecture. The stride must follow the constraints the transform type has specified.

### Parameters
* `s`: the transform context 

* `out`: the output array 

* `in`: the input array 

* `stride`: the input or output stride in bytes
"""
const av_tx_fn = Ptr{Cvoid}

"""
    AVTXFlags

Flags for [`av_tx_init`](@ref)()
"""
const AVTXFlags = UInt32
const AV_TX_INPLACE = 1 % UInt32

"""
    av_tx_init(ctx, tx, type::AVTXType, inv::Integer, len::Integer, scale, flags::UInt64)

Initialize a transform context with the given configuration (i)MDCTs with an odd length are currently not supported.

### Parameters
* `ctx`: the context to allocate, will be NULL on error 

* `tx`: pointer to the transform function pointer to set 

* `type`: type the type of transform 

* `inv`: whether to do an inverse or a forward transform 

* `len`: the size of the transform in samples 

* `scale`: pointer to the value to scale the output if supported by type 

* `flags`: a bitmask of [`AVTXFlags`](@ref) or 0

### Returns
0 on success, negative error code on failure
"""
function av_tx_init(ctx, tx, type::AVTXType, inv::Integer, len::Integer, scale, flags::UInt64)
    ccall((:av_tx_init, libavutil), Cint, (Ptr{Ptr{AVTXContext}}, Ptr{av_tx_fn}, AVTXType, Cint, Cint, Ptr{Cvoid}, UInt64), ctx, tx, type, inv, len, scale, flags)
end

"""
    av_tx_uninit(ctx)

Frees a context and sets ctx to NULL, does nothing when ctx == NULL
"""
function av_tx_uninit(ctx)
    ccall((:av_tx_uninit, libavutil), Cvoid, (Ptr{Ptr{AVTXContext}},), ctx)
end

const AVVideoEncParamsType = Int32
const AV_VIDEO_ENC_PARAMS_NONE = -1 % Int32
const AV_VIDEO_ENC_PARAMS_VP9 = 0 % Int32
const AV_VIDEO_ENC_PARAMS_H264 = 1 % Int32
const AV_VIDEO_ENC_PARAMS_MPEG2 = 2 % Int32

"""
    AVVideoEncParams

Video encoding parameters for a given frame. This struct is allocated along with an optional array of per-block [`AVVideoBlockParams`](@ref) descriptors. Must be allocated with [`av_video_enc_params_alloc`](@ref)().
"""
struct AVVideoEncParams
    nb_blocks::Cuint
    blocks_offset::Csize_t
    block_size::Csize_t
    type::AVVideoEncParamsType
    qp::Int32
    delta_qp::NTuple{4, NTuple{2, Int32}}
end

"""
    AVVideoBlockParams

Data structure for storing block-level encoding information. It is allocated as a part of [`AVVideoEncParams`](@ref) and should be retrieved with [`av_video_enc_params_block`](@ref)().

sizeof([`AVVideoBlockParams`](@ref)) is not a part of the ABI and new fields may be added to it.
"""
struct AVVideoBlockParams
    src_x::Cint
    src_y::Cint
    w::Cint
    h::Cint
    delta_qp::Int32
end

function av_video_enc_params_block(par, idx::Integer)
    ccall((:av_video_enc_params_block, libavutil), Ptr{AVVideoBlockParams}, (Ptr{AVVideoEncParams}, Cuint), par, idx)
end

"""
    av_video_enc_params_alloc(type::AVVideoEncParamsType, nb_blocks::Integer, out_size)

Allocates memory for [`AVVideoEncParams`](@ref) of the given type, plus an array of {

```c++
 nb_blocks} AVVideoBlockParams and initializes the variables. Can be
 freed with a normal av_free() call.
 @param out_size if non-NULL, the size in bytes of the resulting data array is
 written here.
 

```
"""
function av_video_enc_params_alloc(type::AVVideoEncParamsType, nb_blocks::Integer, out_size)
    ccall((:av_video_enc_params_alloc, libavutil), Ptr{AVVideoEncParams}, (AVVideoEncParamsType, Cuint, Ptr{Csize_t}), type, nb_blocks, out_size)
end

"""
    av_video_enc_params_create_side_data(frame, type::AVVideoEncParamsType, nb_blocks::Integer)

Allocates memory for AVEncodeInfoFrame plus an array of {

```c++
 nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}
 as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS
 and initializes the variables.
 

```
"""
function av_video_enc_params_create_side_data(frame, type::AVVideoEncParamsType, nb_blocks::Integer)
    ccall((:av_video_enc_params_create_side_data, libavutil), Ptr{AVVideoEncParams}, (Ptr{AVFrame}, AVVideoEncParamsType, Cuint), frame, type, nb_blocks)
end

"""
    AVXTEA



Public header for libavutil XTEA algorithm 

` lavu_xtea XTEA`

` lavu_crypto`

@{
"""
struct AVXTEA
    key::NTuple{16, UInt32}
end

"""
    av_xtea_alloc()

Allocate an [`AVXTEA`](@ref) context.
"""
function av_xtea_alloc()
    ccall((:av_xtea_alloc, libavutil), Ptr{AVXTEA}, ())
end

"""
    av_xtea_init(ctx, key)

Initialize an [`AVXTEA`](@ref) context.

### Parameters
* `ctx`: an [`AVXTEA`](@ref) context 

* `key`: a key of 16 bytes used for encryption/decryption, interpreted as big endian 32 bit numbers
"""
function av_xtea_init(ctx, key)
    ccall((:av_xtea_init, libavutil), Cvoid, (Ptr{AVXTEA}, Ptr{UInt8}), ctx, key)
end

"""
    av_xtea_le_init(ctx, key)

Initialize an [`AVXTEA`](@ref) context.

### Parameters
* `ctx`: an [`AVXTEA`](@ref) context 

* `key`: a key of 16 bytes used for encryption/decryption, interpreted as little endian 32 bit numbers
"""
function av_xtea_le_init(ctx, key)
    ccall((:av_xtea_le_init, libavutil), Cvoid, (Ptr{AVXTEA}, Ptr{UInt8}), ctx, key)
end

"""
    av_xtea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context, in big endian format.

### Parameters
* `ctx`: an [`AVXTEA`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_xtea_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_xtea_crypt, libavutil), Cvoid, (Ptr{AVXTEA}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

"""
    av_xtea_le_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)

Encrypt or decrypt a buffer using a previously initialized context, in little endian format.

### Parameters
* `ctx`: an [`AVXTEA`](@ref) context 

* `dst`: destination array, can be equal to src 

* `src`: source array, can be equal to dst 

* `count`: number of 8 byte blocks 

* `iv`: initialization vector for CBC mode, if NULL then ECB will be used 

* `decrypt`: 0 for encryption, 1 for decryption
"""
function av_xtea_le_crypt(ctx, dst, src, count::Integer, iv, decrypt::Integer)
    ccall((:av_xtea_le_crypt, libavutil), Cvoid, (Ptr{AVXTEA}, Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}, Cint), ctx, dst, src, count, iv, decrypt)
end

"""
    swscale_version()

` libsws libswscale`

Color conversion and scaling library.

@{

Return the [`LIBSWSCALE_VERSION_INT`](@ref) constant.
"""
function swscale_version()
    ccall((:swscale_version, libswscale), Cuint, ())
end

"""
    swscale_configuration()

Return the libswscale build-time configuration.
"""
function swscale_configuration()
    ccall((:swscale_configuration, libswscale), Cstring, ())
end

"""
    swscale_license()

Return the libswscale license.
"""
function swscale_license()
    ccall((:swscale_license, libswscale), Cstring, ())
end

"""
    sws_getCoefficients(colorspace::Integer)

Return a pointer to yuv<->rgb coefficients for the given colorspace suitable for [`sws_setColorspaceDetails`](@ref)().

### Parameters
* `colorspace`: One of the SWS\\_CS\\_* macros. If invalid, [`SWS_CS_DEFAULT`](@ref) is used.
"""
function sws_getCoefficients(colorspace::Integer)
    ccall((:sws_getCoefficients, libswscale), Ptr{Cint}, (Cint,), colorspace)
end

struct SwsVector
    coeff::Ptr{Cdouble}
    length::Cint
end

struct SwsFilter
    lumH::Ptr{SwsVector}
    lumV::Ptr{SwsVector}
    chrH::Ptr{SwsVector}
    chrV::Ptr{SwsVector}
end

mutable struct SwsContext end

"""
    sws_isSupportedInput(pix_fmt::AVPixelFormat)

Return a positive value if pix\\_fmt is a supported input format, 0 otherwise.
"""
function sws_isSupportedInput(pix_fmt::AVPixelFormat)
    ccall((:sws_isSupportedInput, libswscale), Cint, (AVPixelFormat,), pix_fmt)
end

"""
    sws_isSupportedOutput(pix_fmt::AVPixelFormat)

Return a positive value if pix\\_fmt is a supported output format, 0 otherwise.
"""
function sws_isSupportedOutput(pix_fmt::AVPixelFormat)
    ccall((:sws_isSupportedOutput, libswscale), Cint, (AVPixelFormat,), pix_fmt)
end

"""
    sws_isSupportedEndiannessConversion(pix_fmt::AVPixelFormat)

### Parameters
* `pix_fmt`:\\[in\\] the pixel format 

### Returns
a positive value if an endianness conversion for pix\\_fmt is supported, 0 otherwise.
"""
function sws_isSupportedEndiannessConversion(pix_fmt::AVPixelFormat)
    ccall((:sws_isSupportedEndiannessConversion, libswscale), Cint, (AVPixelFormat,), pix_fmt)
end

"""
    sws_alloc_context()

Allocate an empty [`SwsContext`](@ref). This must be filled and passed to [`sws_init_context`](@ref)(). For filling see AVOptions, options.c and [`sws_setColorspaceDetails`](@ref)().
"""
function sws_alloc_context()
    ccall((:sws_alloc_context, libswscale), Ptr{SwsContext}, ())
end

"""
    sws_init_context(sws_context, srcFilter, dstFilter)

Initialize the swscaler context sws\\_context.

### Returns
zero or positive value on success, a negative value on error
"""
function sws_init_context(sws_context, srcFilter, dstFilter)
    ccall((:sws_init_context, libswscale), Cint, (Ptr{SwsContext}, Ptr{SwsFilter}, Ptr{SwsFilter}), sws_context, srcFilter, dstFilter)
end

"""
    sws_freeContext(swsContext)

Free the swscaler context swsContext. If swsContext is NULL, then does nothing.
"""
function sws_freeContext(swsContext)
    ccall((:sws_freeContext, libswscale), Cvoid, (Ptr{SwsContext},), swsContext)
end

"""
    sws_getContext(srcW::Integer, srcH::Integer, srcFormat::AVPixelFormat, dstW::Integer, dstH::Integer, dstFormat::AVPixelFormat, flags::Integer, srcFilter, dstFilter, param)

Allocate and return an [`SwsContext`](@ref). You need it to perform scaling/conversion operations using [`sws_scale`](@ref)().

!!! note

    this function is to be removed after a saner alternative is written

### Parameters
* `srcW`: the width of the source image 

* `srcH`: the height of the source image 

* `srcFormat`: the source image format 

* `dstW`: the width of the destination image 

* `dstH`: the height of the destination image 

* `dstFormat`: the destination image format 

* `flags`: specify which algorithm and options to use for rescaling 

* `param`: extra parameters to tune the used scaler For [`SWS_BICUBIC`](@ref) param[0] and [1] tune the shape of the basis function, param[0] tunes f(1) and param[1] f´(1) For [`SWS_GAUSS`](@ref) param[0] tunes the exponent and thus cutoff frequency For [`SWS_LANCZOS`](@ref) param[0] tunes the width of the window function 

### Returns
a pointer to an allocated context, or NULL in case of error 
"""
function sws_getContext(srcW::Integer, srcH::Integer, srcFormat::AVPixelFormat, dstW::Integer, dstH::Integer, dstFormat::AVPixelFormat, flags::Integer, srcFilter, dstFilter, param)
    ccall((:sws_getContext, libswscale), Ptr{SwsContext}, (Cint, Cint, AVPixelFormat, Cint, Cint, AVPixelFormat, Cint, Ptr{SwsFilter}, Ptr{SwsFilter}, Ptr{Cdouble}), srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param)
end

"""
    sws_scale(c, srcSlice, srcStride, srcSliceY::Integer, srcSliceH::Integer, dst, dstStride)

Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst. A slice is a sequence of consecutive rows in an image.

Slices have to be provided in sequential order, either in top-bottom or bottom-top order. If slices are provided in non-sequential order the behavior of the function is undefined.

### Parameters
* `c`: the scaling context previously created with [`sws_getContext`](@ref)() 

* `srcSlice`: the array containing the pointers to the planes of the source slice 

* `srcStride`: the array containing the strides for each plane of the source image 

* `srcSliceY`: the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice 

* `srcSliceH`: the height of the source slice, that is the number of rows in the slice 

* `dst`: the array containing the pointers to the planes of the destination image 

* `dstStride`: the array containing the strides for each plane of the destination image 

### Returns
the height of the output slice
"""
function sws_scale(c, srcSlice, srcStride, srcSliceY::Integer, srcSliceH::Integer, dst, dstStride)
    ccall((:sws_scale, libswscale), Cint, (Ptr{SwsContext}, Ptr{Ptr{UInt8}}, Ptr{Cint}, Cint, Cint, Ptr{Ptr{UInt8}}, Ptr{Cint}), c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride)
end

"""
    sws_setColorspaceDetails(c, inv_table, srcRange::Integer, table, dstRange::Integer, brightness::Integer, contrast::Integer, saturation::Integer)

### Parameters
* `dstRange`: flag indicating the while-black range of the output (1=jpeg / 0=mpeg) 

* `srcRange`: flag indicating the while-black range of the input (1=jpeg / 0=mpeg) 

* `table`: the yuv2rgb coefficients describing the output yuv space, normally ff\\_yuv2rgb\\_coeffs[x] 

* `inv_table`: the yuv2rgb coefficients describing the input yuv space, normally ff\\_yuv2rgb\\_coeffs[x] 

* `brightness`: 16.16 fixed point brightness correction 

* `contrast`: 16.16 fixed point contrast correction 

* `saturation`: 16.16 fixed point saturation correction 

### Returns
-1 if not supported
"""
function sws_setColorspaceDetails(c, inv_table, srcRange::Integer, table, dstRange::Integer, brightness::Integer, contrast::Integer, saturation::Integer)
    ccall((:sws_setColorspaceDetails, libswscale), Cint, (Ptr{SwsContext}, Ptr{Cint}, Cint, Ptr{Cint}, Cint, Cint, Cint, Cint), c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
end

"""
    sws_getColorspaceDetails(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)

### Returns
-1 if not supported
"""
function sws_getColorspaceDetails(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
    ccall((:sws_getColorspaceDetails, libswscale), Cint, (Ptr{SwsContext}, Ptr{Ptr{Cint}}, Ptr{Cint}, Ptr{Ptr{Cint}}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation)
end

"""
    sws_allocVec(length::Integer)

Allocate and return an uninitialized vector with length coefficients.
"""
function sws_allocVec(length::Integer)
    ccall((:sws_allocVec, libswscale), Ptr{SwsVector}, (Cint,), length)
end

"""
    sws_getGaussianVec(variance::Cdouble, quality::Cdouble)

Return a normalized Gaussian curve used to filter stuff quality = 3 is high quality, lower is lower quality.
"""
function sws_getGaussianVec(variance::Cdouble, quality::Cdouble)
    ccall((:sws_getGaussianVec, libswscale), Ptr{SwsVector}, (Cdouble, Cdouble), variance, quality)
end

"""
    sws_scaleVec(a, scalar::Cdouble)

Scale all the coefficients of a by the scalar value.
"""
function sws_scaleVec(a, scalar::Cdouble)
    ccall((:sws_scaleVec, libswscale), Cvoid, (Ptr{SwsVector}, Cdouble), a, scalar)
end

"""
    sws_normalizeVec(a, height::Cdouble)

Scale all the coefficients of a so that their sum equals height.
"""
function sws_normalizeVec(a, height::Cdouble)
    ccall((:sws_normalizeVec, libswscale), Cvoid, (Ptr{SwsVector}, Cdouble), a, height)
end

function sws_getConstVec(c::Cdouble, length::Integer)
    ccall((:sws_getConstVec, libswscale), Ptr{SwsVector}, (Cdouble, Cint), c, length)
end

function sws_getIdentityVec()
    ccall((:sws_getIdentityVec, libswscale), Ptr{SwsVector}, ())
end

function sws_convVec(a, b)
    ccall((:sws_convVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
end

function sws_addVec(a, b)
    ccall((:sws_addVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
end

function sws_subVec(a, b)
    ccall((:sws_subVec, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{SwsVector}), a, b)
end

function sws_shiftVec(a, shift::Integer)
    ccall((:sws_shiftVec, libswscale), Cvoid, (Ptr{SwsVector}, Cint), a, shift)
end

function sws_cloneVec(a)
    ccall((:sws_cloneVec, libswscale), Ptr{SwsVector}, (Ptr{SwsVector},), a)
end

function sws_printVec2(a, log_ctx, log_level::Integer)
    ccall((:sws_printVec2, libswscale), Cvoid, (Ptr{SwsVector}, Ptr{AVClass}, Cint), a, log_ctx, log_level)
end

function sws_freeVec(a)
    ccall((:sws_freeVec, libswscale), Cvoid, (Ptr{SwsVector},), a)
end

function sws_getDefaultFilter(lumaGBlur::Cfloat, chromaGBlur::Cfloat, lumaSharpen::Cfloat, chromaSharpen::Cfloat, chromaHShift::Cfloat, chromaVShift::Cfloat, verbose::Integer)
    ccall((:sws_getDefaultFilter, libswscale), Ptr{SwsFilter}, (Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cfloat, Cint), lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose)
end

function sws_freeFilter(filter)
    ccall((:sws_freeFilter, libswscale), Cvoid, (Ptr{SwsFilter},), filter)
end

"""
    sws_getCachedContext(context, srcW::Integer, srcH::Integer, srcFormat::AVPixelFormat, dstW::Integer, dstH::Integer, dstFormat::AVPixelFormat, flags::Integer, srcFilter, dstFilter, param)

Check if context can be reused, otherwise reallocate a new one.

If context is NULL, just calls [`sws_getContext`](@ref)() to get a new context. Otherwise, checks if the parameters are the ones already saved in context. If that is the case, returns the current context. Otherwise, frees context and gets a new context with the new parameters.

Be warned that srcFilter and dstFilter are not checked, they are assumed to remain the same.
"""
function sws_getCachedContext(context, srcW::Integer, srcH::Integer, srcFormat::AVPixelFormat, dstW::Integer, dstH::Integer, dstFormat::AVPixelFormat, flags::Integer, srcFilter, dstFilter, param)
    ccall((:sws_getCachedContext, libswscale), Ptr{SwsContext}, (Ptr{SwsContext}, Cint, Cint, AVPixelFormat, Cint, Cint, AVPixelFormat, Cint, Ptr{SwsFilter}, Ptr{SwsFilter}, Ptr{Cdouble}), context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param)
end

"""
    sws_convertPalette8ToPacked32(src, dst, num_pixels::Integer, palette)

Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.

The output frame will have the same packed format as the palette.

### Parameters
* `src`: source frame buffer 

* `dst`: destination frame buffer 

* `num_pixels`: number of pixels to convert 

* `palette`: array with [256] entries, which must match color arrangement (RGB or BGR) of src
"""
function sws_convertPalette8ToPacked32(src, dst, num_pixels::Integer, palette)
    ccall((:sws_convertPalette8ToPacked32, libswscale), Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}), src, dst, num_pixels, palette)
end

"""
    sws_convertPalette8ToPacked24(src, dst, num_pixels::Integer, palette)

Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.

With the palette format "ABCD", the destination frame ends up with the format "ABC".

### Parameters
* `src`: source frame buffer 

* `dst`: destination frame buffer 

* `num_pixels`: number of pixels to convert 

* `palette`: array with [256] entries, which must match color arrangement (RGB or BGR) of src
"""
function sws_convertPalette8ToPacked24(src, dst, num_pixels::Integer, palette)
    ccall((:sws_convertPalette8ToPacked24, libswscale), Cvoid, (Ptr{UInt8}, Ptr{UInt8}, Cint, Ptr{UInt8}), src, dst, num_pixels, palette)
end

"""
    sws_get_class()

Get the [`AVClass`](@ref) for swsContext. It can be used in combination with [`AV_OPT_SEARCH_FAKE_OBJ`](@ref) for examining options.

### See also
[`av_opt_find`](@ref)().
"""
function sws_get_class()
    ccall((:sws_get_class, libswscale), Ptr{AVClass}, ())
end

const AV_AAC_ADTS_HEADER_SIZE = 7

const AV_INPUT_BUFFER_PADDING_SIZE = 64

const AV_INPUT_BUFFER_MIN_SIZE = 16384

const AV_CODEC_FLAG_UNALIGNED = 1 << 0

const AV_CODEC_FLAG_QSCALE = 1 << 1

const AV_CODEC_FLAG_4MV = 1 << 2

const AV_CODEC_FLAG_OUTPUT_CORRUPT = 1 << 3

const AV_CODEC_FLAG_QPEL = 1 << 4

const AV_CODEC_FLAG_DROPCHANGED = 1 << 5

const AV_CODEC_FLAG_PASS1 = 1 << 9

const AV_CODEC_FLAG_PASS2 = 1 << 10

const AV_CODEC_FLAG_LOOP_FILTER = 1 << 11

const AV_CODEC_FLAG_GRAY = 1 << 13

const AV_CODEC_FLAG_PSNR = 1 << 15

const AV_CODEC_FLAG_TRUNCATED = 1 << 16

const AV_CODEC_FLAG_INTERLACED_DCT = 1 << 18

const AV_CODEC_FLAG_LOW_DELAY = 1 << 19

const AV_CODEC_FLAG_GLOBAL_HEADER = 1 << 22

const AV_CODEC_FLAG_BITEXACT = 1 << 23

const AV_CODEC_FLAG_AC_PRED = 1 << 24

const AV_CODEC_FLAG_INTERLACED_ME = 1 << 29

const AV_CODEC_FLAG_CLOSED_GOP = Cuint(1) << 31

const AV_CODEC_FLAG2_FAST = 1 << 0

const AV_CODEC_FLAG2_NO_OUTPUT = 1 << 2

const AV_CODEC_FLAG2_LOCAL_HEADER = 1 << 3

const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = 1 << 13

const AV_CODEC_FLAG2_CHUNKS = 1 << 15

const AV_CODEC_FLAG2_IGNORE_CROP = 1 << 16

const AV_CODEC_FLAG2_SHOW_ALL = 1 << 22

const AV_CODEC_FLAG2_EXPORT_MVS = 1 << 28

const AV_CODEC_FLAG2_SKIP_MANUAL = 1 << 29

const AV_CODEC_FLAG2_RO_FLUSH_NOOP = 1 << 30

const AV_CODEC_EXPORT_DATA_MVS = 1 << 0

const AV_CODEC_EXPORT_DATA_PRFT = 1 << 1

const AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = 1 << 2

const AV_CODEC_EXPORT_DATA_FILM_GRAIN = 1 << 3

const AV_GET_BUFFER_FLAG_REF = 1 << 0

const AV_GET_ENCODE_BUFFER_FLAG_REF = 1 << 0

const FF_COMPRESSION_DEFAULT = -1

const FF_PRED_LEFT = 0

const FF_PRED_PLANE = 1

const FF_PRED_MEDIAN = 2

const FF_CMP_SAD = 0

const FF_CMP_SSE = 1

const FF_CMP_SATD = 2

const FF_CMP_DCT = 3

const FF_CMP_PSNR = 4

const FF_CMP_BIT = 5

const FF_CMP_RD = 6

const FF_CMP_ZERO = 7

const FF_CMP_VSAD = 8

const FF_CMP_VSSE = 9

const FF_CMP_NSSE = 10

const FF_CMP_W53 = 11

const FF_CMP_W97 = 12

const FF_CMP_DCTMAX = 13

const FF_CMP_DCT264 = 14

const FF_CMP_MEDIAN_SAD = 15

const FF_CMP_CHROMA = 256

const SLICE_FLAG_CODED_ORDER = 0x0001

const SLICE_FLAG_ALLOW_FIELD = 0x0002

const SLICE_FLAG_ALLOW_PLANE = 0x0004

const FF_MB_DECISION_SIMPLE = 0

const FF_MB_DECISION_BITS = 1

const FF_MB_DECISION_RD = 2

const FF_CODER_TYPE_VLC = 0

const FF_CODER_TYPE_AC = 1

const FF_CODER_TYPE_RAW = 2

const FF_CODER_TYPE_RLE = 3

const FF_BUG_AUTODETECT = 1

const FF_BUG_XVID_ILACE = 4

const FF_BUG_UMP4 = 8

const FF_BUG_NO_PADDING = 16

const FF_BUG_AMV = 32

const FF_BUG_QPEL_CHROMA = 64

const FF_BUG_STD_QPEL = 128

const FF_BUG_QPEL_CHROMA2 = 256

const FF_BUG_DIRECT_BLOCKSIZE = 512

const FF_BUG_EDGE = 1024

const FF_BUG_HPEL_CHROMA = 2048

const FF_BUG_DC_CLIP = 4096

const FF_BUG_MS = 8192

const FF_BUG_TRUNCATED = 16384

const FF_BUG_IEDGE = 32768

const FF_COMPLIANCE_VERY_STRICT = 2

const FF_COMPLIANCE_STRICT = 1

const FF_COMPLIANCE_NORMAL = 0

const FF_COMPLIANCE_UNOFFICIAL = -1

const FF_COMPLIANCE_EXPERIMENTAL = -2

const FF_EC_GUESS_MVS = 1

const FF_EC_DEBLOCK = 2

const FF_EC_FAVOR_INTER = 256

const FF_DEBUG_PICT_INFO = 1

const FF_DEBUG_RC = 2

const FF_DEBUG_BITSTREAM = 4

const FF_DEBUG_MB_TYPE = 8

const FF_DEBUG_QP = 16

const FF_DEBUG_DCT_COEFF = 0x00000040

const FF_DEBUG_SKIP = 0x00000080

const FF_DEBUG_STARTCODE = 0x00000100

const FF_DEBUG_ER = 0x00000400

const FF_DEBUG_MMCO = 0x00000800

const FF_DEBUG_BUGS = 0x00001000

const FF_DEBUG_BUFFERS = 0x00008000

const FF_DEBUG_THREADS = 0x00010000

const FF_DEBUG_GREEN_MD = 0x00800000

const FF_DEBUG_NOMC = 0x01000000

const AV_EF_CRCCHECK = 1 << 0

const AV_EF_BITSTREAM = 1 << 1

const AV_EF_BUFFER = 1 << 2

const AV_EF_EXPLODE = 1 << 3

const AV_EF_IGNORE_ERR = 1 << 15

const AV_EF_CAREFUL = 1 << 16

const AV_EF_COMPLIANT = 1 << 17

const AV_EF_AGGRESSIVE = 1 << 18

const FF_DCT_AUTO = 0

const FF_DCT_FASTINT = 1

const FF_DCT_INT = 2

const FF_DCT_MMX = 3

const FF_DCT_ALTIVEC = 5

const FF_DCT_FAAN = 6

const FF_IDCT_AUTO = 0

const FF_IDCT_INT = 1

const FF_IDCT_SIMPLE = 2

const FF_IDCT_SIMPLEMMX = 3

const FF_IDCT_ARM = 7

const FF_IDCT_ALTIVEC = 8

const FF_IDCT_SIMPLEARM = 10

const FF_IDCT_XVID = 14

const FF_IDCT_SIMPLEARMV5TE = 16

const FF_IDCT_SIMPLEARMV6 = 17

const FF_IDCT_FAAN = 20

const FF_IDCT_SIMPLENEON = 22

const FF_IDCT_NONE = 24

const FF_IDCT_SIMPLEAUTO = 128

const FF_THREAD_FRAME = 1

const FF_THREAD_SLICE = 2

const FF_PROFILE_UNKNOWN = -99

const FF_PROFILE_RESERVED = -100

const FF_PROFILE_AAC_MAIN = 0

const FF_PROFILE_AAC_LOW = 1

const FF_PROFILE_AAC_SSR = 2

const FF_PROFILE_AAC_LTP = 3

const FF_PROFILE_AAC_HE = 4

const FF_PROFILE_AAC_HE_V2 = 28

const FF_PROFILE_AAC_LD = 22

const FF_PROFILE_AAC_ELD = 38

const FF_PROFILE_MPEG2_AAC_LOW = 128

const FF_PROFILE_MPEG2_AAC_HE = 131

const FF_PROFILE_DNXHD = 0

const FF_PROFILE_DNXHR_LB = 1

const FF_PROFILE_DNXHR_SQ = 2

const FF_PROFILE_DNXHR_HQ = 3

const FF_PROFILE_DNXHR_HQX = 4

const FF_PROFILE_DNXHR_444 = 5

const FF_PROFILE_DTS = 20

const FF_PROFILE_DTS_ES = 30

const FF_PROFILE_DTS_96_24 = 40

const FF_PROFILE_DTS_HD_HRA = 50

const FF_PROFILE_DTS_HD_MA = 60

const FF_PROFILE_DTS_EXPRESS = 70

const FF_PROFILE_MPEG2_422 = 0

const FF_PROFILE_MPEG2_HIGH = 1

const FF_PROFILE_MPEG2_SS = 2

const FF_PROFILE_MPEG2_SNR_SCALABLE = 3

const FF_PROFILE_MPEG2_MAIN = 4

const FF_PROFILE_MPEG2_SIMPLE = 5

const FF_PROFILE_H264_CONSTRAINED = 1 << 9

const FF_PROFILE_H264_INTRA = 1 << 11

const FF_PROFILE_H264_BASELINE = 66

const FF_PROFILE_H264_CONSTRAINED_BASELINE = 66 | FF_PROFILE_H264_CONSTRAINED

const FF_PROFILE_H264_MAIN = 77

const FF_PROFILE_H264_EXTENDED = 88

const FF_PROFILE_H264_HIGH = 100

const FF_PROFILE_H264_HIGH_10 = 110

const FF_PROFILE_H264_HIGH_10_INTRA = 110 | FF_PROFILE_H264_INTRA

const FF_PROFILE_H264_MULTIVIEW_HIGH = 118

const FF_PROFILE_H264_HIGH_422 = 122

const FF_PROFILE_H264_HIGH_422_INTRA = 122 | FF_PROFILE_H264_INTRA

const FF_PROFILE_H264_STEREO_HIGH = 128

const FF_PROFILE_H264_HIGH_444 = 144

const FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244

const FF_PROFILE_H264_HIGH_444_INTRA = 244 | FF_PROFILE_H264_INTRA

const FF_PROFILE_H264_CAVLC_444 = 44

const FF_PROFILE_VC1_SIMPLE = 0

const FF_PROFILE_VC1_MAIN = 1

const FF_PROFILE_VC1_COMPLEX = 2

const FF_PROFILE_VC1_ADVANCED = 3

const FF_PROFILE_MPEG4_SIMPLE = 0

const FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1

const FF_PROFILE_MPEG4_CORE = 2

const FF_PROFILE_MPEG4_MAIN = 3

const FF_PROFILE_MPEG4_N_BIT = 4

const FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5

const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6

const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7

const FF_PROFILE_MPEG4_HYBRID = 8

const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9

const FF_PROFILE_MPEG4_CORE_SCALABLE = 10

const FF_PROFILE_MPEG4_ADVANCED_CODING = 11

const FF_PROFILE_MPEG4_ADVANCED_CORE = 12

const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13

const FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14

const FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15

const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1

const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2

const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768

const FF_PROFILE_JPEG2000_DCINEMA_2K = 3

const FF_PROFILE_JPEG2000_DCINEMA_4K = 4

const FF_PROFILE_VP9_0 = 0

const FF_PROFILE_VP9_1 = 1

const FF_PROFILE_VP9_2 = 2

const FF_PROFILE_VP9_3 = 3

const FF_PROFILE_HEVC_MAIN = 1

const FF_PROFILE_HEVC_MAIN_10 = 2

const FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3

const FF_PROFILE_HEVC_REXT = 4

const FF_PROFILE_VVC_MAIN_10 = 1

const FF_PROFILE_VVC_MAIN_10_444 = 33

const FF_PROFILE_AV1_MAIN = 0

const FF_PROFILE_AV1_HIGH = 1

const FF_PROFILE_AV1_PROFESSIONAL = 2

const FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 0xc0

const FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 0xc1

const FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 0xc2

const FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 0xc3

const FF_PROFILE_MJPEG_JPEG_LS = 0xf7

const FF_PROFILE_SBC_MSBC = 1

const FF_PROFILE_PRORES_PROXY = 0

const FF_PROFILE_PRORES_LT = 1

const FF_PROFILE_PRORES_STANDARD = 2

const FF_PROFILE_PRORES_HQ = 3

const FF_PROFILE_PRORES_4444 = 4

const FF_PROFILE_PRORES_XQ = 5

const FF_PROFILE_ARIB_PROFILE_A = 0

const FF_PROFILE_ARIB_PROFILE_C = 1

const FF_PROFILE_KLVA_SYNC = 0

const FF_PROFILE_KLVA_ASYNC = 1

const FF_LEVEL_UNKNOWN = -99

const FF_SUB_CHARENC_MODE_DO_NOTHING = -1

const FF_SUB_CHARENC_MODE_AUTOMATIC = 0

const FF_SUB_CHARENC_MODE_PRE_DECODER = 1

const FF_SUB_CHARENC_MODE_IGNORE = 2

const FF_DEBUG_VIS_MV_P_FOR = 0x00000001

const FF_DEBUG_VIS_MV_B_FOR = 0x00000002

const FF_DEBUG_VIS_MV_B_BACK = 0x00000004

const FF_CODEC_PROPERTY_LOSSLESS = 0x00000001

const FF_CODEC_PROPERTY_CLOSED_CAPTIONS = 0x00000002

const FF_SUB_TEXT_FMT_ASS = 0

const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = 1

const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 0x0200

const AV_HWACCEL_FLAG_IGNORE_LEVEL = 1 << 0

const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = 1 << 1

const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = 1 << 2

const AV_SUBTITLE_FLAG_FORCED = 0x00000001

const AV_PARSER_PTS_NB = 4

const PARSER_FLAG_COMPLETE_FRAMES = 0x0001

const PARSER_FLAG_ONCE = 0x0002

const PARSER_FLAG_FETCHED_OFFSET = 0x0004

const PARSER_FLAG_USE_CODEC_TS = 0x1000

const AV_CODEC_CAP_DRAW_HORIZ_BAND = 1 << 0

const AV_CODEC_CAP_DR1 = 1 << 1

const AV_CODEC_CAP_TRUNCATED = 1 << 3

const AV_CODEC_CAP_DELAY = 1 << 5

const AV_CODEC_CAP_SMALL_LAST_FRAME = 1 << 6

const AV_CODEC_CAP_SUBFRAMES = 1 << 8

const AV_CODEC_CAP_EXPERIMENTAL = 1 << 9

const AV_CODEC_CAP_CHANNEL_CONF = 1 << 10

const AV_CODEC_CAP_FRAME_THREADS = 1 << 12

const AV_CODEC_CAP_SLICE_THREADS = 1 << 13

const AV_CODEC_CAP_PARAM_CHANGE = 1 << 14

const AV_CODEC_CAP_OTHER_THREADS = 1 << 15

const AV_CODEC_CAP_AUTO_THREADS = AV_CODEC_CAP_OTHER_THREADS

const AV_CODEC_CAP_VARIABLE_FRAME_SIZE = 1 << 16

const AV_CODEC_CAP_AVOID_PROBING = 1 << 17

const AV_CODEC_CAP_INTRA_ONLY = 0x40000000

const AV_CODEC_CAP_LOSSLESS = 0x80000000

const AV_CODEC_CAP_HARDWARE = 1 << 18

const AV_CODEC_CAP_HYBRID = 1 << 19

const AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = 1 << 20

const AV_CODEC_CAP_ENCODER_FLUSH = 1 << 21

const AV_CODEC_PROP_INTRA_ONLY = 1 << 0

const AV_CODEC_PROP_LOSSY = 1 << 1

const AV_CODEC_PROP_LOSSLESS = 1 << 2

const AV_CODEC_PROP_REORDER = 1 << 3

const AV_CODEC_PROP_BITMAP_SUB = 1 << 16

const AV_CODEC_PROP_TEXT_SUB = 1 << 17

const AV_CODEC_ID_IFF_BYTERUN1 = AV_CODEC_ID_IFF_ILBM

const AV_CODEC_ID_H265 = AV_CODEC_ID_HEVC

const AV_CODEC_ID_H266 = AV_CODEC_ID_VVC

const _WIN32_WINNT = 0x0602

const FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG = 1

const FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO = 2

const MAX_DWT_LEVELS = 5

const DV_PROFILE_BYTES = 6 * 80

const AV_PKT_DATA_QUALITY_FACTOR = AV_PKT_DATA_QUALITY_STATS

const AV_PKT_FLAG_KEY = 0x0001

const AV_PKT_FLAG_CORRUPT = 0x0002

const AV_PKT_FLAG_DISCARD = 0x0004

const AV_PKT_FLAG_TRUSTED = 0x0008

const AV_PKT_FLAG_DISPOSABLE = 0x0010

const LIBAVCODEC_VERSION_MAJOR = 58

const LIBAVCODEC_VERSION_MINOR = 134

const LIBAVCODEC_VERSION_MICRO = 100

const LIBAVCODEC_VERSION_INT = AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)

const LIBAVCODEC_VERSION = AV_VERSION(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)

const LIBAVCODEC_BUILD = LIBAVCODEC_VERSION_INT

const FF_API_AVCTX_TIMEBASE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_CODED_FRAME = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_SIDEDATA_ONLY_PKT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_VDPAU_PROFILE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_CONVERGENCE_DURATION = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_AVPICTURE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_AVPACKET_OLD_API = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_RTP_CALLBACK = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_VBV_DELAY = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_CODER_TYPE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_STAT_BITS = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_PRIVATE_OPT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_ASS_TIMING = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_OLD_BSF = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_COPY_CONTEXT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_GET_CONTEXT_DEFAULTS = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_NVENC_OLD_NAME = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_STRUCT_VAAPI_CONTEXT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_MERGE_SD_API = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_TAG_STRING = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_GETCHROMA = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_CODEC_GET_SET = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_USER_VISIBLE_AVHWACCEL = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_LOCKMGR = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_NEXT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_UNSANITIZED_BITRATES = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_OPENH264_SLICE_MODE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_OPENH264_CABAC = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_UNUSED_CODEC_CAPS = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_AVPRIV_PUT_BITS = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_OLD_ENCDEC = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_AVCODEC_PIX_FMT = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_MPV_RC_STRATEGY = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_PARSER_CHANGE = LIBAVCODEC_VERSION_MAJOR < 59

const FF_API_THREAD_SAFE_CALLBACKS = LIBAVCODEC_VERSION_MAJOR < 60

const FF_API_DEBUG_MV = LIBAVCODEC_VERSION_MAJOR < 60

const FF_API_GET_FRAME_CLASS = LIBAVCODEC_VERSION_MAJOR < 60

const FF_API_AUTO_THREADS = LIBAVCODEC_VERSION_MAJOR < 60

const FF_API_INIT_PACKET = LIBAVCODEC_VERSION_MAJOR < 60

const VORBIS_FLAG_HEADER = 0x00000001

const VORBIS_FLAG_COMMENT = 0x00000002

const VORBIS_FLAG_SETUP = 0x00000004

const AV_XVMC_ID = 0x1dc711c0

const LIBAVDEVICE_VERSION_MAJOR = 58

const LIBAVDEVICE_VERSION_MINOR = 13

const LIBAVDEVICE_VERSION_MICRO = 100

const LIBAVDEVICE_VERSION_INT = AV_VERSION_INT(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)

const LIBAVDEVICE_VERSION = AV_VERSION(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)

const LIBAVDEVICE_BUILD = LIBAVDEVICE_VERSION_INT

const FF_API_DEVICE_CAPABILITIES = LIBAVDEVICE_VERSION_MAJOR < 60

const AVFILTER_FLAG_DYNAMIC_INPUTS = 1 << 0

const AVFILTER_FLAG_DYNAMIC_OUTPUTS = 1 << 1

const AVFILTER_FLAG_SLICE_THREADS = 1 << 2

const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = 1 << 16

const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = 1 << 17

const AVFILTER_FLAG_SUPPORT_TIMELINE = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC | AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL

const AVFILTER_THREAD_SLICE = 1 << 0

const AVFILTER_CMD_FLAG_ONE = 1

const AVFILTER_CMD_FLAG_FAST = 2

const AV_BUFFERSINK_FLAG_PEEK = 1

const AV_BUFFERSINK_FLAG_NO_REQUEST = 2

const LIBAVFILTER_VERSION_MAJOR = 7

const LIBAVFILTER_VERSION_MINOR = 110

const LIBAVFILTER_VERSION_MICRO = 100

const LIBAVFILTER_VERSION_INT = AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)

const LIBAVFILTER_VERSION = AV_VERSION(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)

const LIBAVFILTER_BUILD = LIBAVFILTER_VERSION_INT

const FF_API_OLD_FILTER_OPTS_ERROR = LIBAVFILTER_VERSION_MAJOR < 8

const FF_API_LAVR_OPTS = LIBAVFILTER_VERSION_MAJOR < 8

const FF_API_FILTER_GET_SET = LIBAVFILTER_VERSION_MAJOR < 8

const FF_API_SWS_PARAM_OPTION = LIBAVFILTER_VERSION_MAJOR < 8

const FF_API_FILTER_LINK_SET_CLOSED = LIBAVFILTER_VERSION_MAJOR < 8

const FF_API_BUFFERSINK_ALLOC = LIBAVFILTER_VERSION_MAJOR < 9

const AVPROBE_SCORE_RETRY = AVPROBE_SCORE_MAX ÷ 4

const AVPROBE_SCORE_STREAM_RETRY = AVPROBE_SCORE_MAX ÷ 4 - 1

const AVPROBE_SCORE_EXTENSION = 50

const AVPROBE_SCORE_MIME = 75

const AVPROBE_PADDING_SIZE = 32

const AVFMT_NOFILE = 0x0001

const AVFMT_NEEDNUMBER = 0x0002

const AVFMT_SHOW_IDS = 0x0008

const AVFMT_GLOBALHEADER = 0x0040

const AVFMT_NOTIMESTAMPS = 0x0080

const AVFMT_GENERIC_INDEX = 0x0100

const AVFMT_TS_DISCONT = 0x0200

const AVFMT_VARIABLE_FPS = 0x0400

const AVFMT_NODIMENSIONS = 0x0800

const AVFMT_NOSTREAMS = 0x1000

const AVFMT_NOBINSEARCH = 0x2000

const AVFMT_NOGENSEARCH = 0x4000

const AVFMT_NO_BYTE_SEEK = 0x8000

const AVFMT_ALLOW_FLUSH = 0x00010000

const AVFMT_TS_NONSTRICT = 0x00020000

const AVFMT_TS_NEGATIVE = 0x00040000

const AVFMT_SEEK_TO_PTS = 0x04000000

const AVINDEX_KEYFRAME = 0x0001

const AVINDEX_DISCARD_FRAME = 0x0002

const AV_DISPOSITION_DEFAULT = 0x0001

const AV_DISPOSITION_DUB = 0x0002

const AV_DISPOSITION_ORIGINAL = 0x0004

const AV_DISPOSITION_COMMENT = 0x0008

const AV_DISPOSITION_LYRICS = 0x0010

const AV_DISPOSITION_KARAOKE = 0x0020

const AV_DISPOSITION_FORCED = 0x0040

const AV_DISPOSITION_HEARING_IMPAIRED = 0x0080

const AV_DISPOSITION_VISUAL_IMPAIRED = 0x0100

const AV_DISPOSITION_CLEAN_EFFECTS = 0x0200

const AV_DISPOSITION_ATTACHED_PIC = 0x0400

const AV_DISPOSITION_TIMED_THUMBNAILS = 0x0800

const AV_DISPOSITION_CAPTIONS = 0x00010000

const AV_DISPOSITION_DESCRIPTIONS = 0x00020000

const AV_DISPOSITION_METADATA = 0x00040000

const AV_DISPOSITION_DEPENDENT = 0x00080000

const AV_DISPOSITION_STILL_IMAGE = 0x00100000

const AV_PTS_WRAP_IGNORE = 0

const AV_PTS_WRAP_ADD_OFFSET = 1

const AV_PTS_WRAP_SUB_OFFSET = -1

const AVSTREAM_EVENT_FLAG_METADATA_UPDATED = 0x0001

const AVSTREAM_EVENT_FLAG_NEW_PACKETS = 1 << 1

const AV_PROGRAM_RUNNING = 1

const AVFMTCTX_NOHEADER = 0x0001

const AVFMTCTX_UNSEEKABLE = 0x0002

const AVFMT_FLAG_GENPTS = 0x0001

const AVFMT_FLAG_IGNIDX = 0x0002

const AVFMT_FLAG_NONBLOCK = 0x0004

const AVFMT_FLAG_IGNDTS = 0x0008

const AVFMT_FLAG_NOFILLIN = 0x0010

const AVFMT_FLAG_NOPARSE = 0x0020

const AVFMT_FLAG_NOBUFFER = 0x0040

const AVFMT_FLAG_CUSTOM_IO = 0x0080

const AVFMT_FLAG_DISCARD_CORRUPT = 0x0100

const AVFMT_FLAG_FLUSH_PACKETS = 0x0200

const AVFMT_FLAG_BITEXACT = 0x0400

const AVFMT_FLAG_MP4A_LATM = 0x8000

const AVFMT_FLAG_SORT_DTS = 0x00010000

const AVFMT_FLAG_PRIV_OPT = 0x00020000

const AVFMT_FLAG_KEEP_SIDE_DATA = 0x00040000

const AVFMT_FLAG_FAST_SEEK = 0x00080000

const AVFMT_FLAG_SHORTEST = 0x00100000

const AVFMT_FLAG_AUTO_BSF = 0x00200000

const FF_FDEBUG_TS = 0x0001

const AVFMT_EVENT_FLAG_METADATA_UPDATED = 0x0001

const AVFMT_AVOID_NEG_TS_AUTO = -1

const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1

const AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2

const AVSEEK_FLAG_BACKWARD = 1

const AVSEEK_FLAG_BYTE = 2

const AVSEEK_FLAG_ANY = 4

const AVSEEK_FLAG_FRAME = 8

const AVSTREAM_INIT_IN_WRITE_HEADER = 0

const AVSTREAM_INIT_IN_INIT_OUTPUT = 1

const AV_FRAME_FILENAME_FLAGS_MULTIPLE = 1

const AVIO_SEEKABLE_NORMAL = 1 << 0

const AVIO_SEEKABLE_TIME = 1 << 1

const AVSEEK_SIZE = 0x00010000

const AVSEEK_FORCE = 0x00020000

const AVIO_FLAG_READ = 1

const AVIO_FLAG_WRITE = 2

const AVIO_FLAG_READ_WRITE = AVIO_FLAG_READ | AVIO_FLAG_WRITE

const AVIO_FLAG_NONBLOCK = 8

const AVIO_FLAG_DIRECT = 0x8000

const LIBAVFORMAT_VERSION_MAJOR = 58

const LIBAVFORMAT_VERSION_MINOR = 76

const LIBAVFORMAT_VERSION_MICRO = 100

const LIBAVFORMAT_VERSION_INT = AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO)

const LIBAVFORMAT_VERSION = AV_VERSION(LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO)

const LIBAVFORMAT_BUILD = LIBAVFORMAT_VERSION_INT

const FF_API_COMPUTE_PKT_FIELDS2 = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_OLD_OPEN_CALLBACKS = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_LAVF_AVCTX = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_HTTP_USER_AGENT = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_HLS_WRAP = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_HLS_USE_LOCALTIME = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_LAVF_KEEPSIDE_FLAG = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_OLD_ROTATE_API = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_FORMAT_GET_SET = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_OLD_AVIO_EOF_0 = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_LAVF_FFSERVER = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_FORMAT_FILENAME = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_OLD_RTSP_OPTIONS = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_DASH_MIN_SEG_DURATION = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_LAVF_MP4A_LATM = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_AVIOFORMAT = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_DEMUXER_OPEN = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_CHAPTER_ID_INT = LIBAVFORMAT_VERSION_MAJOR < 59

const FF_API_LAVF_PRIV_OPT = LIBAVFORMAT_VERSION_MAJOR < 60

const FF_API_R_FRAME_RATE = 1

const AES_CTR_KEY_SIZE = 16

const AES_CTR_IV_SIZE = 8

# Skipping MacroDefinition: av_always_inline __attribute__ ( ( always_inline ) ) inline

# Skipping MacroDefinition: av_extern_inline extern inline

# Skipping MacroDefinition: av_warn_unused_result __attribute__ ( ( warn_unused_result ) )

# Skipping MacroDefinition: av_noinline __attribute__ ( ( noinline ) )

# Skipping MacroDefinition: av_pure __attribute__ ( ( pure ) )

# Skipping MacroDefinition: av_const __attribute__ ( ( const ) )

# Skipping MacroDefinition: av_cold __attribute__ ( ( cold ) )

# Skipping MacroDefinition: attribute_deprecated __attribute__ ( ( deprecated ) )

# Skipping MacroDefinition: av_unused __attribute__ ( ( unused ) )

# Skipping MacroDefinition: av_used __attribute__ ( ( used ) )

# Skipping MacroDefinition: av_alias __attribute__ ( ( may_alias ) )

# Skipping MacroDefinition: av_noreturn __attribute__ ( ( noreturn ) )

const AV_LOG_PANIC = 0

const AV_HAVE_BIGENDIAN = 0

const AV_HAVE_FAST_UNALIGNED = 1

const AV_ESCAPE_FLAG_WHITESPACE = 1 << 0

const AV_ESCAPE_FLAG_STRICT = 1 << 1

const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES = 1 << 2

const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES = 1 << 3

const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES = 1

const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS = 2

const AV_UTF8_FLAG_ACCEPT_SURROGATES = 4

const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES = 8

const AV_UTF8_FLAG_ACCEPT_ALL = (AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES | AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS) | AV_UTF8_FLAG_ACCEPT_SURROGATES

const FF_LAMBDA_SHIFT = 7

const FF_LAMBDA_SCALE = 1 << FF_LAMBDA_SHIFT

const FF_QP2LAMBDA = 118

const FF_LAMBDA_MAX = 256 * 128 - 1

const FF_QUALITY_SCALE = FF_LAMBDA_SCALE

const AV_TIME_BASE = 1000000

# Skipping MacroDefinition: AV_TIME_BASE_Q ( AVRational ) { 1 , AV_TIME_BASE }

const AV_FOURCC_MAX_STRING_SIZE = 32

const AV_BF_ROUNDS = 16

const AV_BPRINT_SIZE_AUTOMATIC = 1

const AV_BPRINT_SIZE_COUNT_ONLY = 0

const AV_BUFFER_FLAG_READONLY = 1 << 0

const AV_CH_FRONT_LEFT = 0x00000001

const AV_CH_FRONT_RIGHT = 0x00000002

const AV_CH_FRONT_CENTER = 0x00000004

const AV_CH_LOW_FREQUENCY = 0x00000008

const AV_CH_BACK_LEFT = 0x00000010

const AV_CH_BACK_RIGHT = 0x00000020

const AV_CH_FRONT_LEFT_OF_CENTER = 0x00000040

const AV_CH_FRONT_RIGHT_OF_CENTER = 0x00000080

const AV_CH_BACK_CENTER = 0x00000100

const AV_CH_SIDE_LEFT = 0x00000200

const AV_CH_SIDE_RIGHT = 0x00000400

const AV_CH_TOP_CENTER = 0x00000800

const AV_CH_TOP_FRONT_LEFT = 0x00001000

const AV_CH_TOP_FRONT_CENTER = 0x00002000

const AV_CH_TOP_FRONT_RIGHT = 0x00004000

const AV_CH_TOP_BACK_LEFT = 0x00008000

const AV_CH_TOP_BACK_CENTER = 0x00010000

const AV_CH_TOP_BACK_RIGHT = 0x00020000

const AV_CH_STEREO_LEFT = 0x20000000

const AV_CH_STEREO_RIGHT = 0x40000000

const AV_CH_WIDE_LEFT = Culonglong(0x0000000080000000)

const AV_CH_WIDE_RIGHT = Culonglong(0x0000000100000000)

const AV_CH_SURROUND_DIRECT_LEFT = Culonglong(0x0000000200000000)

const AV_CH_SURROUND_DIRECT_RIGHT = Culonglong(0x0000000400000000)

const AV_CH_LOW_FREQUENCY_2 = Culonglong(0x0000000800000000)

const AV_CH_TOP_SIDE_LEFT = Culonglong(0x0000001000000000)

const AV_CH_TOP_SIDE_RIGHT = Culonglong(0x0000002000000000)

const AV_CH_BOTTOM_FRONT_CENTER = Culonglong(0x0000004000000000)

const AV_CH_BOTTOM_FRONT_LEFT = Culonglong(0x0000008000000000)

const AV_CH_BOTTOM_FRONT_RIGHT = Culonglong(0x0000010000000000)

const AV_CH_LAYOUT_NATIVE = Culonglong(0x8000000000000000)

const AV_CH_LAYOUT_MONO = AV_CH_FRONT_CENTER

const AV_CH_LAYOUT_STEREO = AV_CH_FRONT_LEFT | AV_CH_FRONT_RIGHT

const AV_CH_LAYOUT_2POINT1 = AV_CH_LAYOUT_STEREO | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_2_1 = AV_CH_LAYOUT_STEREO | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_SURROUND = AV_CH_LAYOUT_STEREO | AV_CH_FRONT_CENTER

const AV_CH_LAYOUT_3POINT1 = AV_CH_LAYOUT_SURROUND | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_4POINT0 = AV_CH_LAYOUT_SURROUND | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_4POINT1 = AV_CH_LAYOUT_4POINT0 | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_2_2 = (AV_CH_LAYOUT_STEREO | AV_CH_SIDE_LEFT) | AV_CH_SIDE_RIGHT

const AV_CH_LAYOUT_QUAD = (AV_CH_LAYOUT_STEREO | AV_CH_BACK_LEFT) | AV_CH_BACK_RIGHT

const AV_CH_LAYOUT_5POINT0 = (AV_CH_LAYOUT_SURROUND | AV_CH_SIDE_LEFT) | AV_CH_SIDE_RIGHT

const AV_CH_LAYOUT_5POINT1 = AV_CH_LAYOUT_5POINT0 | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_5POINT0_BACK = (AV_CH_LAYOUT_SURROUND | AV_CH_BACK_LEFT) | AV_CH_BACK_RIGHT

const AV_CH_LAYOUT_5POINT1_BACK = AV_CH_LAYOUT_5POINT0_BACK | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_6POINT0 = AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_6POINT0_FRONT = (AV_CH_LAYOUT_2_2 | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER

const AV_CH_LAYOUT_HEXAGONAL = AV_CH_LAYOUT_5POINT0_BACK | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_6POINT1 = AV_CH_LAYOUT_5POINT1 | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_6POINT1_BACK = AV_CH_LAYOUT_5POINT1_BACK | AV_CH_BACK_CENTER

const AV_CH_LAYOUT_6POINT1_FRONT = AV_CH_LAYOUT_6POINT0_FRONT | AV_CH_LOW_FREQUENCY

const AV_CH_LAYOUT_7POINT0 = (AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_LEFT) | AV_CH_BACK_RIGHT

const AV_CH_LAYOUT_7POINT0_FRONT = (AV_CH_LAYOUT_5POINT0 | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER

const AV_CH_LAYOUT_7POINT1 = (AV_CH_LAYOUT_5POINT1 | AV_CH_BACK_LEFT) | AV_CH_BACK_RIGHT

const AV_CH_LAYOUT_7POINT1_WIDE = (AV_CH_LAYOUT_5POINT1 | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER

const AV_CH_LAYOUT_7POINT1_WIDE_BACK = (AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER

const AV_CH_LAYOUT_OCTAGONAL = ((AV_CH_LAYOUT_5POINT0 | AV_CH_BACK_LEFT) | AV_CH_BACK_CENTER) | AV_CH_BACK_RIGHT

const AV_CH_LAYOUT_HEXADECAGONAL = (((((((AV_CH_LAYOUT_OCTAGONAL | AV_CH_WIDE_LEFT) | AV_CH_WIDE_RIGHT) | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT) | AV_CH_TOP_BACK_CENTER) | AV_CH_TOP_FRONT_CENTER) | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT

const AV_CH_LAYOUT_STEREO_DOWNMIX = AV_CH_STEREO_LEFT | AV_CH_STEREO_RIGHT

const AV_CH_LAYOUT_22POINT2 = (((((((((((((((((AV_CH_LAYOUT_5POINT1_BACK | AV_CH_FRONT_LEFT_OF_CENTER) | AV_CH_FRONT_RIGHT_OF_CENTER) | AV_CH_BACK_CENTER) | AV_CH_LOW_FREQUENCY_2) | AV_CH_SIDE_LEFT) | AV_CH_SIDE_RIGHT) | AV_CH_TOP_FRONT_LEFT) | AV_CH_TOP_FRONT_RIGHT) | AV_CH_TOP_FRONT_CENTER) | AV_CH_TOP_CENTER) | AV_CH_TOP_BACK_LEFT) | AV_CH_TOP_BACK_RIGHT) | AV_CH_TOP_SIDE_LEFT) | AV_CH_TOP_SIDE_RIGHT) | AV_CH_TOP_BACK_CENTER) | AV_CH_BOTTOM_FRONT_CENTER) | AV_CH_BOTTOM_FRONT_LEFT) | AV_CH_BOTTOM_FRONT_RIGHT

const av_ceil_log2 = av_ceil_log2_c

const av_clip = av_clip_c

const av_clip64 = av_clip64_c

const av_clip_uint8 = av_clip_uint8_c

const av_clip_int8 = av_clip_int8_c

const av_clip_uint16 = av_clip_uint16_c

const av_clip_int16 = av_clip_int16_c

const av_clipl_int32 = av_clipl_int32_c

const av_clip_intp2 = av_clip_intp2_c

const av_clip_uintp2 = av_clip_uintp2_c

const av_mod_uintp2 = av_mod_uintp2_c

const av_sat_add32 = av_sat_add32_c

const av_sat_dadd32 = av_sat_dadd32_c

const av_sat_sub32 = av_sat_sub32_c

const av_sat_dsub32 = av_sat_dsub32_c

const av_sat_add64 = av_sat_add64_c

const av_sat_sub64 = av_sat_sub64_c

const av_clipf = av_clipf_c

const av_clipd = av_clipd_c

const av_popcount = av_popcount_c

const av_popcount64 = av_popcount64_c

const av_parity = av_parity_c

const AV_CPU_FLAG_FORCE = 0x80000000

const AV_CPU_FLAG_MMX = 0x0001

const AV_CPU_FLAG_MMXEXT = 0x0002

const AV_CPU_FLAG_MMX2 = 0x0002

const AV_CPU_FLAG_3DNOW = 0x0004

const AV_CPU_FLAG_SSE = 0x0008

const AV_CPU_FLAG_SSE2 = 0x0010

const AV_CPU_FLAG_SSE2SLOW = 0x40000000

const AV_CPU_FLAG_3DNOWEXT = 0x0020

const AV_CPU_FLAG_SSE3 = 0x0040

const AV_CPU_FLAG_SSE3SLOW = 0x20000000

const AV_CPU_FLAG_SSSE3 = 0x0080

const AV_CPU_FLAG_SSSE3SLOW = 0x04000000

const AV_CPU_FLAG_ATOM = 0x10000000

const AV_CPU_FLAG_SSE4 = 0x0100

const AV_CPU_FLAG_SSE42 = 0x0200

const AV_CPU_FLAG_AESNI = 0x00080000

const AV_CPU_FLAG_AVX = 0x4000

const AV_CPU_FLAG_AVXSLOW = 0x08000000

const AV_CPU_FLAG_XOP = 0x0400

const AV_CPU_FLAG_FMA4 = 0x0800

const AV_CPU_FLAG_CMOV = 0x1000

const AV_CPU_FLAG_AVX2 = 0x8000

const AV_CPU_FLAG_FMA3 = 0x00010000

const AV_CPU_FLAG_BMI1 = 0x00020000

const AV_CPU_FLAG_BMI2 = 0x00040000

const AV_CPU_FLAG_AVX512 = 0x00100000

const AV_CPU_FLAG_ALTIVEC = 0x0001

const AV_CPU_FLAG_VSX = 0x0002

const AV_CPU_FLAG_POWER8 = 0x0004

const AV_CPU_FLAG_ARMV5TE = 1 << 0

const AV_CPU_FLAG_ARMV6 = 1 << 1

const AV_CPU_FLAG_ARMV6T2 = 1 << 2

const AV_CPU_FLAG_VFP = 1 << 3

const AV_CPU_FLAG_VFPV3 = 1 << 4

const AV_CPU_FLAG_NEON = 1 << 5

const AV_CPU_FLAG_ARMV8 = 1 << 6

const AV_CPU_FLAG_VFP_VM = 1 << 7

const AV_CPU_FLAG_SETEND = 1 << 16

const AV_CPU_FLAG_MMI = 1 << 0

const AV_CPU_FLAG_MSA = 1 << 1

const AV_DICT_MATCH_CASE = 1

const AV_DICT_IGNORE_SUFFIX = 2

const AV_DICT_DONT_STRDUP_KEY = 4

const AV_DICT_DONT_STRDUP_VAL = 8

const AV_DICT_DONT_OVERWRITE = 16

const AV_DICT_APPEND = 32

const AV_DICT_MULTIKEY = 64

const AVERROR_BSF_NOT_FOUND = FFERRTAG(0xf8, Cchar('B'), Cchar('S'), Cchar('F'))

const AVERROR_BUG = FFERRTAG(Cchar('B'), Cchar('U'), Cchar('G'), Cchar('!'))

const AVERROR_BUFFER_TOO_SMALL = FFERRTAG(Cchar('B'), Cchar('U'), Cchar('F'), Cchar('S'))

const AVERROR_DECODER_NOT_FOUND = FFERRTAG(0xf8, Cchar('D'), Cchar('E'), Cchar('C'))

const AVERROR_DEMUXER_NOT_FOUND = FFERRTAG(0xf8, Cchar('D'), Cchar('E'), Cchar('M'))

const AVERROR_ENCODER_NOT_FOUND = FFERRTAG(0xf8, Cchar('E'), Cchar('N'), Cchar('C'))

const AVERROR_EOF = FFERRTAG(Cchar('E'), Cchar('O'), Cchar('F'), Cchar(' '))

const AVERROR_EXIT = FFERRTAG(Cchar('E'), Cchar('X'), Cchar('I'), Cchar('T'))

const AVERROR_EXTERNAL = FFERRTAG(Cchar('E'), Cchar('X'), Cchar('T'), Cchar(' '))

const AVERROR_FILTER_NOT_FOUND = FFERRTAG(0xf8, Cchar('F'), Cchar('I'), Cchar('L'))

const AVERROR_INVALIDDATA = FFERRTAG(Cchar('I'), Cchar('N'), Cchar('D'), Cchar('A'))

const AVERROR_MUXER_NOT_FOUND = FFERRTAG(0xf8, Cchar('M'), Cchar('U'), Cchar('X'))

const AVERROR_OPTION_NOT_FOUND = FFERRTAG(0xf8, Cchar('O'), Cchar('P'), Cchar('T'))

const AVERROR_PATCHWELCOME = FFERRTAG(Cchar('P'), Cchar('A'), Cchar('W'), Cchar('E'))

const AVERROR_PROTOCOL_NOT_FOUND = FFERRTAG(0xf8, Cchar('P'), Cchar('R'), Cchar('O'))

const AVERROR_STREAM_NOT_FOUND = FFERRTAG(0xf8, Cchar('S'), Cchar('T'), Cchar('R'))

const AVERROR_BUG2 = FFERRTAG(Cchar('B'), Cchar('U'), Cchar('G'), Cchar(' '))

const AVERROR_UNKNOWN = FFERRTAG(Cchar('U'), Cchar('N'), Cchar('K'), Cchar('N'))

const AVERROR_EXPERIMENTAL = -0x2bb2afa8

const AVERROR_INPUT_CHANGED = -0x636e6701

const AVERROR_OUTPUT_CHANGED = -0x636e6702

const AVERROR_HTTP_BAD_REQUEST = FFERRTAG(0xf8, Cchar('4'), Cchar('0'), Cchar('0'))

const AVERROR_HTTP_UNAUTHORIZED = FFERRTAG(0xf8, Cchar('4'), Cchar('0'), Cchar('1'))

const AVERROR_HTTP_FORBIDDEN = FFERRTAG(0xf8, Cchar('4'), Cchar('0'), Cchar('3'))

const AVERROR_HTTP_NOT_FOUND = FFERRTAG(0xf8, Cchar('4'), Cchar('0'), Cchar('4'))

const AVERROR_HTTP_OTHER_4XX = FFERRTAG(0xf8, Cchar('4'), Cchar('X'), Cchar('X'))

const AVERROR_HTTP_SERVER_ERROR = FFERRTAG(0xf8, Cchar('5'), Cchar('X'), Cchar('X'))

const AV_ERROR_MAX_STRING_SIZE = 64

const FFMPEG_VERSION = "4.4"

const AV_NUM_DATA_POINTERS = 8

const AV_FRAME_FLAG_CORRUPT = 1 << 0

const AV_FRAME_FLAG_DISCARD = 1 << 2

const FF_DECODE_ERROR_INVALID_BITSTREAM = 1

const FF_DECODE_ERROR_MISSING_REFERENCE = 2

const FF_DECODE_ERROR_CONCEALMENT_ACTIVE = 4

const FF_DECODE_ERROR_DECODE_SLICES = 8

const AV_HASH_MAX_SIZE = 64

const AV_CUDA_USE_PRIMARY_CONTEXT = 1 << 0

const AV_LOG_QUIET = -8

const AV_LOG_FATAL = 8

const AV_LOG_ERROR = 16

const AV_LOG_WARNING = 24

const AV_LOG_INFO = 32

const AV_LOG_VERBOSE = 40

const AV_LOG_DEBUG = 48

const AV_LOG_TRACE = 56

const AV_LOG_MAX_OFFSET = AV_LOG_TRACE - AV_LOG_QUIET

const AV_LOG_SKIP_REPEATED = 1

const AV_LOG_PRINT_LEVEL = 2

const AV_LZO_INPUT_DEPLETED = 1

const AV_LZO_OUTPUT_FULL = 2

const AV_LZO_INVALID_BACKPTR = 4

const AV_LZO_ERROR = 8

const AV_LZO_INPUT_PADDING = 8

const AV_LZO_OUTPUT_PADDING = 12

const M_LOG2_10 = 3.321928094887362

const M_PHI = 1.618033988749895

# Skipping MacroDefinition: av_malloc_attrib __attribute__ ( ( __malloc__ ) )

const AV_OPT_FLAG_ENCODING_PARAM = 1

const AV_OPT_FLAG_DECODING_PARAM = 2

const AV_OPT_FLAG_AUDIO_PARAM = 8

const AV_OPT_FLAG_VIDEO_PARAM = 16

const AV_OPT_FLAG_SUBTITLE_PARAM = 32

const AV_OPT_FLAG_EXPORT = 64

const AV_OPT_FLAG_READONLY = 128

const AV_OPT_FLAG_BSF_PARAM = 1 << 8

const AV_OPT_FLAG_RUNTIME_PARAM = 1 << 15

const AV_OPT_FLAG_FILTERING_PARAM = 1 << 16

const AV_OPT_FLAG_DEPRECATED = 1 << 17

const AV_OPT_FLAG_CHILD_CONSTS = 1 << 18

const AV_OPT_SEARCH_CHILDREN = 1 << 0

const AV_OPT_SEARCH_FAKE_OBJ = 1 << 1

const AV_OPT_ALLOW_NULL = 1 << 2

const AV_OPT_MULTI_COMPONENT_RANGE = 1 << 12

const AV_OPT_SERIALIZE_SKIP_DEFAULTS = 0x00000001

const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = 0x00000002

const AV_PIX_FMT_FLAG_BE = 1 << 0

const AV_PIX_FMT_FLAG_PAL = 1 << 1

const AV_PIX_FMT_FLAG_BITSTREAM = 1 << 2

const AV_PIX_FMT_FLAG_HWACCEL = 1 << 3

const AV_PIX_FMT_FLAG_PLANAR = 1 << 4

const AV_PIX_FMT_FLAG_RGB = 1 << 5

const AV_PIX_FMT_FLAG_PSEUDOPAL = 1 << 6

const AV_PIX_FMT_FLAG_ALPHA = 1 << 7

const AV_PIX_FMT_FLAG_BAYER = 1 << 8

const AV_PIX_FMT_FLAG_FLOAT = 1 << 9

const FF_LOSS_RESOLUTION = 0x0001

const FF_LOSS_DEPTH = 0x0002

const FF_LOSS_COLORSPACE = 0x0004

const FF_LOSS_ALPHA = 0x0008

const FF_LOSS_COLORQUANT = 0x0010

const FF_LOSS_CHROMA = 0x0020

const AVPALETTE_SIZE = 1024

const AVPALETTE_COUNT = 256

const AV_PIX_FMT_RGB32 = @AV_PIX_FMT_NE(ARGB, BGRA)

const AV_PIX_FMT_RGB32_1 = @AV_PIX_FMT_NE(RGBA, ABGR)

const AV_PIX_FMT_BGR32 = @AV_PIX_FMT_NE(ABGR, RGBA)

const AV_PIX_FMT_BGR32_1 = @AV_PIX_FMT_NE(BGRA, ARGB)

const AV_PIX_FMT_0RGB32 = @AV_PIX_FMT_NE(0RGB, BGR0)

const AV_PIX_FMT_0BGR32 = @AV_PIX_FMT_NE(0BGR, RGB0)

const AV_PIX_FMT_GRAY9 = @AV_PIX_FMT_NE(GRAY9BE, GRAY9LE)

const AV_PIX_FMT_GRAY10 = @AV_PIX_FMT_NE(GRAY10BE, GRAY10LE)

const AV_PIX_FMT_GRAY12 = @AV_PIX_FMT_NE(GRAY12BE, GRAY12LE)

const AV_PIX_FMT_GRAY14 = @AV_PIX_FMT_NE(GRAY14BE, GRAY14LE)

const AV_PIX_FMT_GRAY16 = @AV_PIX_FMT_NE(GRAY16BE, GRAY16LE)

const AV_PIX_FMT_YA16 = @AV_PIX_FMT_NE(YA16BE, YA16LE)

const AV_PIX_FMT_RGB48 = @AV_PIX_FMT_NE(RGB48BE, RGB48LE)

const AV_PIX_FMT_RGB565 = @AV_PIX_FMT_NE(RGB565BE, RGB565LE)

const AV_PIX_FMT_RGB555 = @AV_PIX_FMT_NE(RGB555BE, RGB555LE)

const AV_PIX_FMT_RGB444 = @AV_PIX_FMT_NE(RGB444BE, RGB444LE)

const AV_PIX_FMT_RGBA64 = @AV_PIX_FMT_NE(RGBA64BE, RGBA64LE)

const AV_PIX_FMT_BGR48 = @AV_PIX_FMT_NE(BGR48BE, BGR48LE)

const AV_PIX_FMT_BGR565 = @AV_PIX_FMT_NE(BGR565BE, BGR565LE)

const AV_PIX_FMT_BGR555 = @AV_PIX_FMT_NE(BGR555BE, BGR555LE)

const AV_PIX_FMT_BGR444 = @AV_PIX_FMT_NE(BGR444BE, BGR444LE)

const AV_PIX_FMT_BGRA64 = @AV_PIX_FMT_NE(BGRA64BE, BGRA64LE)

const AV_PIX_FMT_YUV420P9 = @AV_PIX_FMT_NE(YUV420P9BE, YUV420P9LE)

const AV_PIX_FMT_YUV422P9 = @AV_PIX_FMT_NE(YUV422P9BE, YUV422P9LE)

const AV_PIX_FMT_YUV444P9 = @AV_PIX_FMT_NE(YUV444P9BE, YUV444P9LE)

const AV_PIX_FMT_YUV420P10 = @AV_PIX_FMT_NE(YUV420P10BE, YUV420P10LE)

const AV_PIX_FMT_YUV422P10 = @AV_PIX_FMT_NE(YUV422P10BE, YUV422P10LE)

const AV_PIX_FMT_YUV440P10 = @AV_PIX_FMT_NE(YUV440P10BE, YUV440P10LE)

const AV_PIX_FMT_YUV444P10 = @AV_PIX_FMT_NE(YUV444P10BE, YUV444P10LE)

const AV_PIX_FMT_YUV420P12 = @AV_PIX_FMT_NE(YUV420P12BE, YUV420P12LE)

const AV_PIX_FMT_YUV422P12 = @AV_PIX_FMT_NE(YUV422P12BE, YUV422P12LE)

const AV_PIX_FMT_YUV440P12 = @AV_PIX_FMT_NE(YUV440P12BE, YUV440P12LE)

const AV_PIX_FMT_YUV444P12 = @AV_PIX_FMT_NE(YUV444P12BE, YUV444P12LE)

const AV_PIX_FMT_YUV420P14 = @AV_PIX_FMT_NE(YUV420P14BE, YUV420P14LE)

const AV_PIX_FMT_YUV422P14 = @AV_PIX_FMT_NE(YUV422P14BE, YUV422P14LE)

const AV_PIX_FMT_YUV444P14 = @AV_PIX_FMT_NE(YUV444P14BE, YUV444P14LE)

const AV_PIX_FMT_YUV420P16 = @AV_PIX_FMT_NE(YUV420P16BE, YUV420P16LE)

const AV_PIX_FMT_YUV422P16 = @AV_PIX_FMT_NE(YUV422P16BE, YUV422P16LE)

const AV_PIX_FMT_YUV444P16 = @AV_PIX_FMT_NE(YUV444P16BE, YUV444P16LE)

const AV_PIX_FMT_GBRP9 = @AV_PIX_FMT_NE(GBRP9BE, GBRP9LE)

const AV_PIX_FMT_GBRP10 = @AV_PIX_FMT_NE(GBRP10BE, GBRP10LE)

const AV_PIX_FMT_GBRP12 = @AV_PIX_FMT_NE(GBRP12BE, GBRP12LE)

const AV_PIX_FMT_GBRP14 = @AV_PIX_FMT_NE(GBRP14BE, GBRP14LE)

const AV_PIX_FMT_GBRP16 = @AV_PIX_FMT_NE(GBRP16BE, GBRP16LE)

const AV_PIX_FMT_GBRAP10 = @AV_PIX_FMT_NE(GBRAP10BE, GBRAP10LE)

const AV_PIX_FMT_GBRAP12 = @AV_PIX_FMT_NE(GBRAP12BE, GBRAP12LE)

const AV_PIX_FMT_GBRAP16 = @AV_PIX_FMT_NE(GBRAP16BE, GBRAP16LE)

const AV_PIX_FMT_BAYER_BGGR16 = @AV_PIX_FMT_NE(BAYER_BGGR16BE, BAYER_BGGR16LE)

const AV_PIX_FMT_BAYER_RGGB16 = @AV_PIX_FMT_NE(BAYER_RGGB16BE, BAYER_RGGB16LE)

const AV_PIX_FMT_BAYER_GBRG16 = @AV_PIX_FMT_NE(BAYER_GBRG16BE, BAYER_GBRG16LE)

const AV_PIX_FMT_BAYER_GRBG16 = @AV_PIX_FMT_NE(BAYER_GRBG16BE, BAYER_GRBG16LE)

const AV_PIX_FMT_GBRPF32 = @AV_PIX_FMT_NE(GBRPF32BE, GBRPF32LE)

const AV_PIX_FMT_GBRAPF32 = @AV_PIX_FMT_NE(GBRAPF32BE, GBRAPF32LE)

const AV_PIX_FMT_GRAYF32 = @AV_PIX_FMT_NE(GRAYF32BE, GRAYF32LE)

const AV_PIX_FMT_YUVA420P9 = @AV_PIX_FMT_NE(YUVA420P9BE, YUVA420P9LE)

const AV_PIX_FMT_YUVA422P9 = @AV_PIX_FMT_NE(YUVA422P9BE, YUVA422P9LE)

const AV_PIX_FMT_YUVA444P9 = @AV_PIX_FMT_NE(YUVA444P9BE, YUVA444P9LE)

const AV_PIX_FMT_YUVA420P10 = @AV_PIX_FMT_NE(YUVA420P10BE, YUVA420P10LE)

const AV_PIX_FMT_YUVA422P10 = @AV_PIX_FMT_NE(YUVA422P10BE, YUVA422P10LE)

const AV_PIX_FMT_YUVA444P10 = @AV_PIX_FMT_NE(YUVA444P10BE, YUVA444P10LE)

const AV_PIX_FMT_YUVA422P12 = @AV_PIX_FMT_NE(YUVA422P12BE, YUVA422P12LE)

const AV_PIX_FMT_YUVA444P12 = @AV_PIX_FMT_NE(YUVA444P12BE, YUVA444P12LE)

const AV_PIX_FMT_YUVA420P16 = @AV_PIX_FMT_NE(YUVA420P16BE, YUVA420P16LE)

const AV_PIX_FMT_YUVA422P16 = @AV_PIX_FMT_NE(YUVA422P16BE, YUVA422P16LE)

const AV_PIX_FMT_YUVA444P16 = @AV_PIX_FMT_NE(YUVA444P16BE, YUVA444P16LE)

const AV_PIX_FMT_XYZ12 = @AV_PIX_FMT_NE(XYZ12BE, XYZ12LE)

const AV_PIX_FMT_NV20 = @AV_PIX_FMT_NE(NV20BE, NV20LE)

const AV_PIX_FMT_AYUV64 = @AV_PIX_FMT_NE(AYUV64BE, AYUV64LE)

const AV_PIX_FMT_P010 = @AV_PIX_FMT_NE(P010BE, P010LE)

const AV_PIX_FMT_P016 = @AV_PIX_FMT_NE(P016BE, P016LE)

const AV_PIX_FMT_Y210 = @AV_PIX_FMT_NE(Y210BE, Y210LE)

const AV_PIX_FMT_X2RGB10 = @AV_PIX_FMT_NE(X2RGB10BE, X2RGB10LE)

const AV_STEREO3D_FLAG_INVERT = 1 << 0

const AV_TIMECODE_STR_SIZE = 23

const AV_TS_MAX_STRING_SIZE = 32

const LIBAVUTIL_VERSION_MAJOR = 56

const LIBAVUTIL_VERSION_MINOR = 70

const LIBAVUTIL_VERSION_MICRO = 100

const LIBAVUTIL_VERSION_INT = AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO)

const LIBAVUTIL_VERSION = AV_VERSION(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO)

const LIBAVUTIL_BUILD = LIBAVUTIL_VERSION_INT

const FF_API_VAAPI = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_FRAME_QP = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_PLUS1_MINUS1 = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_ERROR_FRAME = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_PKT_PTS = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_CRYPTO_SIZE_T = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_FRAME_GET_SET = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_PSEUDOPAL = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_CHILD_CLASS_NEXT = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_BUFFER_SIZE_T = LIBAVUTIL_VERSION_MAJOR < 57

const FF_API_D2STR = LIBAVUTIL_VERSION_MAJOR < 58

const FF_API_DECLARE_ALIGNED = LIBAVUTIL_VERSION_MAJOR < 58

const SWS_FAST_BILINEAR = 1

const SWS_BILINEAR = 2

const SWS_BICUBIC = 4

const SWS_X = 8

const SWS_POINT = 0x10

const SWS_AREA = 0x20

const SWS_BICUBLIN = 0x40

const SWS_GAUSS = 0x80

const SWS_SINC = 0x0100

const SWS_LANCZOS = 0x0200

const SWS_SPLINE = 0x0400

const SWS_SRC_V_CHR_DROP_MASK = 0x00030000

const SWS_SRC_V_CHR_DROP_SHIFT = 16

const SWS_PARAM_DEFAULT = 123456

const SWS_PRINT_INFO = 0x1000

const SWS_FULL_CHR_H_INT = 0x2000

const SWS_FULL_CHR_H_INP = 0x4000

const SWS_DIRECT_BGR = 0x8000

const SWS_ACCURATE_RND = 0x00040000

const SWS_BITEXACT = 0x00080000

const SWS_ERROR_DIFFUSION = 0x00800000

const SWS_MAX_REDUCE_CUTOFF = 0.002

const SWS_CS_ITU709 = 1

const SWS_CS_FCC = 4

const SWS_CS_ITU601 = 5

const SWS_CS_ITU624 = 5

const SWS_CS_SMPTE170M = 5

const SWS_CS_SMPTE240M = 7

const SWS_CS_DEFAULT = 5

const SWS_CS_BT2020 = 9

const LIBSWSCALE_VERSION_MAJOR = 5

const LIBSWSCALE_VERSION_MINOR = 9

const LIBSWSCALE_VERSION_MICRO = 100

const LIBSWSCALE_VERSION_INT = AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)

const LIBSWSCALE_VERSION = AV_VERSION(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)

const LIBSWSCALE_BUILD = LIBSWSCALE_VERSION_INT

const FF_API_SWS_VECTOR = LIBSWSCALE_VERSION_MAJOR < 6

struct_types = Type[]
# Export everything
for name in names(@__MODULE__, all=true)
    name in [Symbol("#eval"), Symbol("#include"), :include, :eval] && continue
    @eval begin
        export $name
        $name isa Type && isstructtype($name) && push!(struct_types, $name)
    end
end


function Base.getproperty(x::Ptr{<:Union{struct_types...}}, f::Symbol)
    T = eltype(x)
    fieldpos = Base.fieldindex(T, f)
    field_pointer = convert(Ptr{fieldtype(T, fieldpos)}, x + fieldoffset(T, fieldpos))
    return field_pointer
end


end # module
