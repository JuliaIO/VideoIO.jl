<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reading Videos · VideoIO.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-143027902-2"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-143027902-2', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://juliaio.github.io/VideoIO.jl/stable/reading/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="VideoIO.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">VideoIO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Reading Videos</a><ul class="internal"><li><a class="tocitem" href="#Reading-Video-Files"><span>Reading Video Files</span></a></li><li><a class="tocitem" href="#Video-Playback"><span>Video Playback</span></a></li><li><a class="tocitem" href="#Reading-Camera-Output"><span>Reading Camera Output</span></a></li><li><a class="tocitem" href="#Video-Properties-and-Metadata"><span>Video Properties &amp; Metadata</span></a></li></ul></li><li><a class="tocitem" href="../writing/">Writing Videos</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../lowlevel/">Low Level Functionality</a></li><li><a class="tocitem" href="../functionindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reading Videos</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reading Videos</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaIO/VideoIO.jl/blob/master/docs/src/reading.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Video-Reading"><a class="docs-heading-anchor" href="#Video-Reading">Video Reading</a><a id="Video-Reading-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Reading" title="Permalink"></a></h1><p>Note: Reading of audio streams is not yet implemented</p><h2 id="Reading-Video-Files"><a class="docs-heading-anchor" href="#Reading-Video-Files">Reading Video Files</a><a id="Reading-Video-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-Video-Files" title="Permalink"></a></h2><p>VideoIO contains a simple high-level interface which allows reading of video frames from a supported video file (or from a camera device, shown later).</p><p>The simplest form will load the entire video into memory as a vector of image arrays.</p><pre><code class="language-julia hljs">using VideoIO
VideoIO.load(&quot;video.mp4&quot;)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VideoIO.load" href="#VideoIO.load"><code>VideoIO.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load(filename::String, args...; kwargs...)</code></pre><p>Load video file <code>filename</code> into memory as vector of image arrays, setting <code>args</code> and <code>kwargs</code> on the <code>openvideo</code> process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L77-L81">source</a></section></article><p>Frames can be read sequentially until the end of the file:</p><pre><code class="language-julia hljs">using VideoIO

# Construct a AVInput object to access the video and audio streams in a video container
# io = VideoIO.open(video_file)
io = VideoIO.testvideo(&quot;annie_oakley&quot;) # for testing purposes

# Access the video stream in an AVInput, and return a VideoReader object:
f = VideoIO.openvideo(io) # you can also use a file name, instead of a AVInput

img = read(f)

while !eof(f)
    read!(f, img)
    # Do something with frames
end
close(f)</code></pre><article class="docstring"><header><a class="docstring-binding" id="VideoIO.openvideo" href="#VideoIO.openvideo"><code>VideoIO.openvideo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">openvideo(file[, video_stream = 1]; &lt;keyword arguments&gt;) -&gt; reader
openvideo(f, ...)</code></pre><p>Open <code>file</code> and create an object to read and decode video stream number <code>video_stream</code>. <code>file</code> can either be a <code>AVInput</code> created by <code>VideoIO.open</code>, the name of a file as an <code>AbstractString</code>, or instead an <code>IO</code> object. However, support for <code>IO</code> objects is incomplete, and does not currently work with common video containers such as <code>*.mp4</code> files.</p><p>Frames can be read from the <code>reader</code> with <code>read</code> or <code>read!</code>, or alternatively by using the iterator interface provided for <code>reader</code>. To close the <code>reader</code>, simply use <code>close</code>. Seeking within the reader can be accomplished using <code>seek</code>, <code>seekstart</code>. Frames can be skipped with <code>skipframe</code>, or <code>skipframes</code>. The current time in the video stream can be accessed with <code>gettime</code>. Details about the frame dimension can be found with <code>out_frame_size</code>. The total number of frames can be found with <code>counttotalframes</code>.</p><p>If called with a single argument function as the first argument, the <code>reader</code> will be passed to the function, and will be closed once the call returns whether or not an error occurred.</p><p>The decoder options and conversion to Julia arrays is controlled by the keyword arguments listed below.</p><p><strong>Keyword arguments</strong></p><ul><li><code>transcode::Bool = true</code>: Determines whether decoded frames are transferred   into a Julia matrix with easily interpretable element type, or instead   returned as raw byte buffers.</li><li><code>target_format::Union{Nothing, Cint} = nothing</code>: Determines the target pixel   format that decoded frames will be transformed into before being transferred   to an output array. This can either by a <code>VideoIO.AV_PIX_FMT_*</code> value   corresponding to a FFmpeg   <a href="https://ffmpeg.org/doxygen/4.1/pixfmt_8h.html#a9a8e335cf3be472042bc9f0cf80cd4c5"><code>AVPixelFormat</code></a>,   and must then also be a format supported by the VideoIO, or instead   <code>nothing</code>, in which case the format will be automatically chosen by FFmpeg.   This list of currently supported pixel formats, and the matrix element type   that each pixel format corresponds with, are elements of   <code>VideoIO.VIO_PIX_FMT_DEF_ELTYPE_LU</code>.</li><li><code>pix_fmt_loss_flags = 0</code>: Loss flags to control how transfer pixel format is   chosen. Only valid if <code>target_format = nothing</code>. Flags must correspond to   FFmpeg   <a href="http://ffmpeg.org/doxygen/2.5/pixdesc_8h.html#a445e6541dde2408332c216b8d0accb2d">loss flags</a>.</li><li><code>target_colorspace_details = nothing</code>: Information about the color space   of output Julia arrays. If <code>nothing</code>, then this will correspond to a   best-effort interpretation of <code>Colors.jl</code> for the corresponding element   type. To override these defaults, create a <code>VideoIO.VioColorspaceDetails</code>   object using the appropriate <code>AVCOL_</code> definitions from FFmpeg, or use   <code>VideoIO.VioColorspaceDetails()</code> to use the FFmpeg defaults. To avoid   rescaling limited color range data (mpeg) to full color range output (jpeg),   then set this to <code>VideoIO.VioColorspaceDetails()</code> to avoid additional   scaling by <code>sws_scale</code>.</li><li><code>allow_vio_gray_transform = true</code>: Instead of using <code>sws_scale</code> for gray data,   use a more accurate color space transformation implemented in <code>VideoIO</code> if   <code>allow_vio_gray_gransform = true</code>. Otherwise, use <code>sws_scale</code>.</li><li><code>swscale_options::OptionsT = (;)</code>: A <code>Namedtuple</code>, or <code>Dict{Symbol, Any}</code> of   options for the swscale object used to perform color space scaling. Options   must correspond with options for FFmpeg&#39;s   <a href="https://ffmpeg.org/ffmpeg-all.html#Scaler-Options">scaler</a> filter.</li><li><code>sws_color_options::OptionsT = (;)</code>: Additional keyword arguments passed to   <a href="http://ffmpeg.org/doxygen/2.5/group__libsws.html#ga541bdffa8149f5f9203664f955faa040">sws_setColorspaceDetails</a>.</li><li><code>thread_count::Union{Nothing, Int} = Sys.CPU_THREADS</code>: The number of threads the codec is   allowed to use or <code>nothing</code> for default codec behavior. Defaults to <code>Sys.CPU_THREADS</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L533-L599">source</a></section></article><p>Alternatively, you can open the video stream in a file directly with <code>VideoIO.openvideo(filename)</code>, without making an intermediate <code>AVInput</code> object, if you only need the video.</p><p>VideoIO also provides an iterator interface for <code>VideoReader</code>, which behaves like other mutable iterators in Julia (e.g. Channels). If iteration is stopped early, for example with a <code>break</code> statement, then it can be resumed in the same spot by iterating on the same <code>VideoReader</code> object. Consequently, if you have already iterated over all the frames of a <code>VideoReader</code> object, then it will be empty for further iteration unless its position in the video is changed with <code>seek</code>.</p><pre><code class="language-julia hljs">using VideoIO

f = VideoIO.openvideo(&quot;video.mp4&quot;)
for img in f
    # Do something with img
end
# Alternatively use collect(f) to get all of the frames

# Further iteration will show that f is now empty
@assert isempty(f)

close(f)</code></pre><p>Seeking through the video can be achieved via <code>seek(f, seconds::Float64)</code> and <code>seekstart(f)</code> to return to the start.</p><article class="docstring"><header><a class="docstring-binding" id="Base.seek" href="#Base.seek"><code>Base.seek</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seek(reader::VideoReader, seconds)</code></pre><p>Seeks into the parent <code>AVInput</code> using this video stream&#39;s index. See [<code>seek</code>] for <code>AVInput</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L802-L807">source</a></section><section><div><pre><code class="nohighlight hljs">seek(avin::AVInput, seconds::AbstractFloat, video_stream::Integer=1)</code></pre><p>Seek through the container format <code>avin</code> so that the next frame returned by the stream indicated by <code>video_stream</code> will have a timestamp greater than or equal to <code>seconds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L833-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.seekstart" href="#Base.seekstart"><code>Base.seekstart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seekstart(reader::VideoReader)</code></pre><p>Seek to time zero of the parent <code>AVInput</code> using <code>reader</code>&#39;s stream index. See <code>seekstart</code> for <code>AVInput</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L856-L861">source</a></section><section><div><pre><code class="nohighlight hljs">seekstart(avin::AVInput{T}, video_stream_index=1) where T &lt;: AbstractString</code></pre><p>Seek to time zero of AVInput object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L864-L868">source</a></section></article><p>Frames can be skipped without reading frame content via <code>skipframe(f)</code> and <code>skipframes(f, n)</code></p><article class="docstring"><header><a class="docstring-binding" id="VideoIO.skipframe" href="#VideoIO.skipframe"><code>VideoIO.skipframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">skipframe(s::VideoReader; throwEOF=true)</code></pre><p>Skip the next frame. If End of File is reached, EOFError thrown if throwEOF=true. Otherwise returns true if EOF reached, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L874-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VideoIO.skipframes" href="#VideoIO.skipframes"><code>VideoIO.skipframes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">skipframes(s::VideoReader, n::Int; throwEOF=true) -&gt; n</code></pre><p>Skip the next <code>n</code> frames. If End of File is reached and <code>throwEOF=true</code>, a <code>EOFError</code> will be thrown. Returns the number of frames that were skipped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L886-L891">source</a></section></article><p>Total available frame count is available via <code>counttotalframes(f)</code></p><article class="docstring"><header><a class="docstring-binding" id="VideoIO.counttotalframes" href="#VideoIO.counttotalframes"><code>VideoIO.counttotalframes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">counttotalframes(reader) -&gt; n::Int</code></pre><p>Count the total number of frames in the video by seeking to start, skipping through each frame, and seeking back to the start.</p><p>For a faster alternative that relies on video container metadata, try <code>get_number_frames</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/avio.jl#L899-L906">source</a></section></article><p>!!! note H264 videos encoded with <code>crf&gt;0</code> have been observed to have 4-fewer frames available for reading.</p><h3 id="Changing-the-target-pixel-format-for-reading"><a class="docs-heading-anchor" href="#Changing-the-target-pixel-format-for-reading">Changing the target pixel format for reading</a><a id="Changing-the-target-pixel-format-for-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-the-target-pixel-format-for-reading" title="Permalink"></a></h3><p>It can be helpful to be explicit in which pixel format you wish to read frames as. Here a grayscale video is read and parsed into a <code>Vector(Array{UInt8}}</code></p><pre><code class="language-julia hljs">f = VideoIO.openvideo(filename, target_format=VideoIO.AV_PIX_FMT_GRAY8)

while !eof(f)
    img = reinterpret(UInt8, read(f))
end
close(f)</code></pre><h2 id="Video-Playback"><a class="docs-heading-anchor" href="#Video-Playback">Video Playback</a><a id="Video-Playback-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Playback" title="Permalink"></a></h2><p>A trivial video player interface exists (no audio) through <code>GLMakie.jl</code>. Note: <code>GLMakie</code> must be imported first to enable playback functionality.</p><pre><code class="language-julia hljs">using GLMakie
using VideoIO

f = VideoIO.testvideo(&quot;annie_oakley&quot;)  # downloaded if not available
VideoIO.playvideo(f)  # no sound</code></pre><p>Customization of playback can be achieved by looking at the basic expanded version of this function:</p><pre><code class="language-julia hljs">import GLMakie
import VideoIO

#io = VideoIO.open(video_file)
io = VideoIO.testvideo(&quot;annie_oakley&quot;) # for testing purposes
f = VideoIO.openvideo(io)

img = read(f)
scene = GLMakie.Scene(resolution = reverse(size(img)))
makieimg = GLMakie.image!(scene, img, show_axis = false, scale_plot = true)
GLMakie.rotate!(scene, -0.5pi)
display(scene)

while !eof(f)
    read!(f, img)
    makieimg.image = img
    sleep(1/VideoIO.framerate(f))
end</code></pre><p>This code is essentially the code in <code>playvideo</code>, and will read and (without the <code>sleep</code>) play a movie file as fast as possible.</p><h2 id="Reading-Camera-Output"><a class="docs-heading-anchor" href="#Reading-Camera-Output">Reading Camera Output</a><a id="Reading-Camera-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-Camera-Output" title="Permalink"></a></h2><p>Frames can be read iteratively</p><pre><code class="language-julia hljs">using VideoIO
cam = VideoIO.opencamera()
for i in 1:100
    img = read(cam)
    sleep(1/VideoIO.framerate(cam))
end</code></pre><h3 id="Webcam-playback"><a class="docs-heading-anchor" href="#Webcam-playback">Webcam playback</a><a id="Webcam-playback-1"></a><a class="docs-heading-anchor-permalink" href="#Webcam-playback" title="Permalink"></a></h3><p>The default system webcam can be viewed directly</p><pre><code class="language-julia hljs">using GLMakie
using VideoIO
VideoIO.viewcam()</code></pre><p>An expanded version of this approach:</p><pre><code class="language-julia hljs">import GLMakie, VideoIO

cam = VideoIO.opencamera()

img = read(cam)
scene = GLMakie.Scene(resolution = size(img&#39;))
makieimg = GLMakie.image!(scene, img, show_axis = false, scale_plot = false)
GLMakie.rotate!(scene, -0.5pi)
display(scene)

while isopen(scene)
    read!(cam, img)
    makieimg.image = img
    sleep(1/VideoIO.framerate(cam))
end

close(cam)</code></pre><h2 id="Video-Properties-and-Metadata"><a class="docs-heading-anchor" href="#Video-Properties-and-Metadata">Video Properties &amp; Metadata</a><a id="Video-Properties-and-Metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Video-Properties-and-Metadata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VideoIO.get_start_time" href="#VideoIO.get_start_time"><code>VideoIO.get_start_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_start_time(file::String) -&gt; DateTime</code></pre><p>Return the starting date &amp; time of the video <code>file</code>. Note that if the starting date &amp; time are missing, this function will return the Unix epoch (00:00 1st January 1970).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/info.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VideoIO.get_time_duration" href="#VideoIO.get_time_duration"><code>VideoIO.get_time_duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_time_duration(file::String) -&gt; (DateTime, Microsecond)</code></pre><p>Return the starting date &amp; time as well as the duration of the video <code>file</code>. Note that if the starting date &amp; time are missing, this function will return the Unix epoch (00:00 1st January 1970).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/info.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VideoIO.get_duration" href="#VideoIO.get_duration"><code>VideoIO.get_duration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_duration(file::String) -&gt; Float64</code></pre><p>Return the duration of the video <code>file</code> in seconds (float).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/info.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VideoIO.get_number_frames" href="#VideoIO.get_number_frames"><code>VideoIO.get_number_frames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_number_frames(file [, streamno])</code></pre><p>Query the the container <code>file</code> for the number of frames in video stream <code>streamno</code> if applicable, instead returning <code>nothing</code> if the container does not report the number of frames. Will not decode the video to count the number of frames in a video.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaIO/VideoIO.jl/blob/41aeb0f3512d6e3566f1a93c2b6e9bcec732d992/src/info.jl#L49-L56">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../writing/">Writing Videos »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Tuesday 19 April 2022 18:48">Tuesday 19 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
